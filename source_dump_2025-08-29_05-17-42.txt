========================================================================================================================
PROJECT SNAPSHOT
Root: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI
Timestamp: 2025-08-29_05-17-42
Included directories:
 - C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge  (excluding C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\vendor)
 - C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\examples
 - C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src
 - C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests
========================================================================================================================


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\bridge.js
# SIZE: 7268 bytes
# HASH: a7929dd400002783c397ec0e2f19fcdade277f12a7326a9012a459fc30f7614f
# MODIFIED: 2025-08-29T04:23:40.780689
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

"use strict";
/**
 * AnswerChain cryptographic bridge (Node.js <-> Python), NDJSON over stdio.
 * Requires noble single-file bundles placed NEXT TO this file:
 *   - noble-hashes.js  (exports { sha3_256, hmac, hkdf, sha256, argon2id })
 *   - noble-ciphers.js (exports { gcm, chacha20poly1305, xchacha20poly1305 })
 */
const fs = require("node:fs");
const vm = require("node:vm");
const crypto = require("node:crypto");
const path = require("node:path");

function loadBundle(p, globalNameCandidates) {
  const code = fs.readFileSync(p, "utf8");
  const ctx = { console: undefined, module: {}, exports: {} };
  vm.createContext(ctx);
  vm.runInContext(code, ctx, { filename: p, displayErrors: true });

  // Try UMD/CommonJS exports first
  if (ctx.module && ctx.module.exports && Object.keys(ctx.module.exports).length) return ctx.module.exports;
  if (ctx.exports && Object.keys(ctx.exports).length) return ctx.exports;

  // Otherwise, fall back to known global names
  for (const name of globalNameCandidates) {
    if (name in ctx) return ctx[name];
  }
  throw new Error(`Bundle ${p} did not expose expected exports or globals`);
}

const DIR = __dirname;
const hashesPath = path.join(DIR, "noble-hashes.js");
const ciphersPath = path.join(DIR, "noble-ciphers.js");

if (!fs.existsSync(hashesPath)) throw new Error(`Missing ${hashesPath}`);
if (!fs.existsSync(ciphersPath)) throw new Error(`Missing ${ciphersPath}`);

const nobleHashes = loadBundle(hashesPath, ["nobleHashes"]);
const nobleCiphers = loadBundle(ciphersPath, ["nobleCiphers"]);

const { sha3_256, hmac, hkdf, sha256, argon2id } = nobleHashes;
const { gcm, chacha20poly1305, xchacha20poly1305 } = nobleCiphers;

function b64(buf) { return Buffer.from(buf).toString("base64"); }
function b64d(s) {
  if (typeof s !== "string") throw new Error("expected base64 string");
  return Buffer.from(s, "base64");
}
function toU8(b) {
  if (Buffer.isBuffer(b)) return new Uint8Array(b);
  if (b instanceof Uint8Array) return b;
  return new Uint8Array(Buffer.from(b));
}
function assertLen(name, bytes, len) {
  if (bytes.length !== len) throw new Error(`${name} must be exactly ${len} bytes`);
}
function assertMinLen(name, bytes, min) {
  if (bytes.length < min) throw new Error(`${name} must be at least ${min} bytes`);
}
function optBytes(s) { return s == null ? undefined : toU8(b64d(s)); }

function ok(id, result) { process.stdout.write(JSON.stringify({ id, ok: true, result }) + "\n"); }
function fail(id, error) { process.stdout.write(JSON.stringify({ id, ok: false, error: String(error) }) + "\n"); }
function safe(id, fn) { try { fn(); } catch (e) { fail(id, e && e.stack || e); } }

const OPS = {
  ping: () => ({ pong: 1 }),

  sha3_256: ({ data }) => {
    const out = sha3_256(toU8(b64d(data)));
    return { digest: b64(Buffer.from(out)) };
  },

  hmac_sha256: ({ key, data }) => {
    const out = hmac.create(sha256, toU8(b64d(key))).update(toU8(b64d(data))).digest();
    return { digest: b64(Buffer.from(out)) };
  },

  hkdf_sha256: ({ ikm, salt = "", info = "", length }) => {
    const L = Number(length);
    if (!Number.isInteger(L) || L <= 0 || L > 255 * 32) throw new Error("length must be in (0, 8160]");
    const out = hkdf(sha256, toU8(b64d(ikm)), toU8(b64d(salt)), toU8(b64d(info)), L);
    return { okm: b64(Buffer.from(out)) };
  },

  argon2id: ({ password, salt, t = 2, m = 65536, p = 1, dkLen = 32, version = 19 }) => {
    const pwd = toU8(b64d(password));
    const slt = toU8(b64d(salt));
    assertMinLen("salt", slt, 16);
    const opts = { t: Number(t), m: Number(m), p: Number(p), dkLen: Number(dkLen), version: Number(version) };
    if (!(opts.t >= 1 && opts.m >= 8 && opts.p >= 1 && opts.dkLen >= 16 && opts.dkLen <= 1024)) {
      throw new Error("invalid argon2id parameters");
    }
    const out = argon2id(pwd, slt, opts);
    return { okm: b64(Buffer.from(out)) };
  },

  aes_gcm_encrypt: ({ key, nonce, aad, plaintext }) => {
    const K = toU8(b64d(key));  assertLen("key", K, 32);
    const N = toU8(b64d(nonce));assertLen("nonce", N, 12);
    const A = aad == null ? undefined : toU8(b64d(aad));
    const P = toU8(b64d(plaintext));
    const C = gcm(K, N, A).encrypt(P);
    return { ciphertext: b64(Buffer.from(C)) };
  },

  aes_gcm_decrypt: ({ key, nonce, aad, ciphertext }) => {
    const K = toU8(b64d(key));  assertLen("key", K, 32);
    const N = toU8(b64d(nonce));assertLen("nonce", N, 12);
    const A = aad == null ? undefined : toU8(b64d(aad));
    const C = toU8(b64d(ciphertext));
    const P = gcm(K, N, A).decrypt(C);
    return { plaintext: b64(Buffer.from(P)) };
  },

  chacha20poly1305_encrypt: ({ key, nonce, aad, plaintext }) => {
    const K = toU8(b64d(key));  assertLen("key", K, 32);
    const N = toU8(b64d(nonce));assertLen("nonce", N, 12);
    const A = aad == null ? undefined : toU8(b64d(aad));
    const P = toU8(b64d(plaintext));
    const C = chacha20poly1305(K, N, A).encrypt(P);
    return { ciphertext: b64(Buffer.from(C)) };
  },

  chacha20poly1305_decrypt: ({ key, nonce, aad, ciphertext }) => {
    const K = toU8(b64d(key));  assertLen("key", K, 32);
    const N = toU8(b64d(nonce));assertLen("nonce", N, 12);
    const A = aad == null ? undefined : toU8(b64d(aad));
    const C = toU8(b64d(ciphertext));
    const P = chacha20poly1305(K, N, A).decrypt(C);
    return { plaintext: b64(Buffer.from(P)) };
  },

  xchacha20poly1305_encrypt: ({ key, nonce, aad, plaintext }) => {
    const K = toU8(b64d(key));  assertLen("key", K, 32);
    const N = toU8(b64d(nonce));assertLen("nonce", N, 24);
    const A = aad == null ? undefined : toU8(b64d(aad));
    const P = toU8(b64d(plaintext));
    const C = xchacha20poly1305(K, N, A).encrypt(P);
    return { ciphertext: b64(Buffer.from(C)) };
  },

  xchacha20poly1305_decrypt: ({ key, nonce, aad, ciphertext }) => {
    const K = toU8(b64d(key));  assertLen("key", K, 32);
    const N = toU8(b64d(nonce));assertLen("nonce", N, 24);
    const A = aad == null ? undefined : toU8(b64d(aad));
    const C = toU8(b64d(ciphertext));
    const P = xchacha20poly1305(K, N, A).decrypt(C);
    return { plaintext: b64(Buffer.from(P)) };
  },

  ct_equal: ({ a, b }) => {
    const A = b64d(a), B = b64d(b);
    if (A.length !== B.length) return { equal: false };
    return { equal: crypto.timingSafeEqual(A, B) };
  }
};

function handle(line) {
  let msg;
  try { msg = JSON.parse(line); } catch { return fail(null, "invalid json"); }
  const { id, op, args } = msg || {};
  if (typeof op !== "string" || !(op in OPS)) return fail(id, "unknown op");
  safe(id, () => ok(id, OPS[op](args || {})));
}

function main() {
  delete process.env.NODE_OPTIONS; // avoid user overrides
  process.stdin.setEncoding("utf8");
  let buf = "";
  process.stdin.on("data", (chunk) => {
    buf += chunk;
    while (true) {
      const idx = buf.indexOf("\n");
      if (idx === -1) break;
      const line = buf.slice(0, idx).trim();
      buf = buf.slice(idx + 1);
      if (line.length) handle(line);
    }
  });
  process.stdin.on("end", () => process.exit(0));
}
if (require.main === module) main();



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\bridge.js
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\noble-ciphers.js
# SIZE: 68374 bytes
# HASH: cd2657f0470154d8eb274951b6e6e7480a634e83d9d65ae5176cba37f64db81d
# MODIFIED: 2025-08-29T04:23:40.781689
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

var nobleCiphers = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // input.js
  var input_exports = {};
  __export(input_exports, {
    aeskw: () => aeskw,
    aeskwp: () => aeskwp,
    cbc: () => cbc,
    chacha12: () => chacha12,
    chacha20: () => chacha20,
    chacha20poly1305: () => chacha20poly1305,
    chacha8: () => chacha8,
    ctr: () => ctr,
    ecb: () => ecb,
    gcm: () => gcm,
    salsa20: () => salsa20,
    siv: () => siv,
    utils: () => utils,
    xchacha20poly1305: () => xchacha20poly1305,
    xsalsa20poly1305: () => xsalsa20poly1305
  });

  // ../../utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function abool(b) {
    if (typeof b !== "boolean")
      throw new Error(`boolean expected, not ${b}`);
  }
  function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error("positive integer expected, got " + n);
  }
  function abytes(value, length, title = "") {
    const bytes = isBytes(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes || needsLen && len !== length) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out, void 0, "output");
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least " + min);
    }
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  function overlapBytes(a, b) {
    return a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
    b.byteOffset < a.byteOffset + a.byteLength;
  }
  function complexOverlapBytes(input, output) {
    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
      throw new Error("complex overlap of input and output is not supported");
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== "object")
      throw new Error("options must be defined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function equalBytes(a, b) {
    if (a.length !== b.length)
      return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
      diff |= a[i] ^ b[i];
    return diff === 0;
  }
  var wrapCipher = /* @__NO_SIDE_EFFECTS__ */ (params, constructor) => {
    function wrappedCipher(key, ...args) {
      abytes(key, void 0, "key");
      if (!isLE)
        throw new Error("Non little-endian hardware is not yet supported");
      if (params.nonceLength !== void 0) {
        const nonce = args[0];
        abytes(nonce, params.varSizeNonce ? void 0 : params.nonceLength, "nonce");
      }
      const tagl = params.tagLength;
      if (tagl && args[1] !== void 0)
        abytes(args[1], void 0, "AAD");
      const cipher = constructor(key, ...args);
      const checkOutput = (fnLength, output) => {
        if (output !== void 0) {
          if (fnLength !== 2)
            throw new Error("cipher output not supported");
          abytes(output, void 0, "output");
        }
      };
      let called = false;
      const wrCipher = {
        encrypt(data, output) {
          if (called)
            throw new Error("cannot encrypt() twice with same key + nonce");
          called = true;
          abytes(data);
          checkOutput(cipher.encrypt.length, output);
          return cipher.encrypt(data, output);
        },
        decrypt(data, output) {
          abytes(data);
          if (tagl && data.length < tagl)
            throw new Error('"ciphertext" expected length bigger than tagLength=' + tagl);
          checkOutput(cipher.decrypt.length, output);
          return cipher.decrypt(data, output);
        }
      };
      return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
  };
  function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === void 0)
      return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
      throw new Error('"output" expected Uint8Array of length ' + expectedLength + ", got: " + out.length);
    if (onlyAligned && !isAligned32(out))
      throw new Error("invalid output, must be aligned");
    return out;
  }
  function u64Lengths(dataLength, aadLength, isLE2) {
    abool(isLE2);
    const num = new Uint8Array(16);
    const view = createView(num);
    view.setBigUint64(0, BigInt(aadLength), isLE2);
    view.setBigUint64(8, BigInt(dataLength), isLE2);
    return num;
  }
  function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
  }
  function copyBytes(bytes) {
    return Uint8Array.from(bytes);
  }
  function randomBytes(bytesLength = 32) {
    const cr = typeof globalThis === "object" ? globalThis.crypto : null;
    if (typeof cr?.getRandomValues !== "function")
      throw new Error("crypto.getRandomValues must be defined");
    return cr.getRandomValues(new Uint8Array(bytesLength));
  }
  function managedNonce(fn, randomBytes_ = randomBytes) {
    const { nonceLength } = fn;
    anumber(nonceLength);
    const addNonce = (nonce, ciphertext) => {
      const out = concatBytes(nonce, ciphertext);
      ciphertext.fill(0);
      return out;
    };
    return (key, ...args) => ({
      encrypt(plaintext) {
        abytes(plaintext);
        const nonce = randomBytes_(nonceLength);
        const encrypted = fn(key, nonce, ...args).encrypt(plaintext);
        if (encrypted instanceof Promise)
          return encrypted.then((ct) => addNonce(nonce, ct));
        return addNonce(nonce, encrypted);
      },
      decrypt(ciphertext) {
        abytes(ciphertext);
        const nonce = ciphertext.subarray(0, nonceLength);
        const decrypted = ciphertext.subarray(nonceLength);
        return fn(key, nonce, ...args).decrypt(decrypted);
      }
    });
  }

  // ../../_polyval.js
  var BLOCK_SIZE = 16;
  var ZEROS16 = /* @__PURE__ */ new Uint8Array(16);
  var ZEROS32 = u32(ZEROS16);
  var POLY = 225;
  var mul2 = (s0, s1, s2, s3) => {
    const hiBit = s3 & 1;
    return {
      s3: s2 << 31 | s3 >>> 1,
      s2: s1 << 31 | s2 >>> 1,
      s1: s0 << 31 | s1 >>> 1,
      s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
      // reduce % poly
    };
  };
  var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
  function _toGHASHKey(k) {
    k.reverse();
    const hiBit = k[15] & 1;
    let carry = 0;
    for (let i = 0; i < k.length; i++) {
      const t = k[i];
      k[i] = t >>> 1 | carry;
      carry = (t & 1) << 7;
    }
    k[0] ^= -hiBit & 225;
    return k;
  }
  var estimateWindow = (bytes) => {
    if (bytes > 64 * 1024)
      return 8;
    if (bytes > 1024)
      return 4;
    return 2;
  };
  var GHASH = class {
    blockLen = BLOCK_SIZE;
    outputLen = BLOCK_SIZE;
    s0 = 0;
    s1 = 0;
    s2 = 0;
    s3 = 0;
    finished = false;
    t;
    W;
    windowSize;
    // We select bits per window adaptively based on expectedLength
    constructor(key, expectedLength) {
      abytes(key, 16, "key");
      key = copyBytes(key);
      const kView = createView(key);
      let k0 = kView.getUint32(0, false);
      let k1 = kView.getUint32(4, false);
      let k2 = kView.getUint32(8, false);
      let k3 = kView.getUint32(12, false);
      const doubles = [];
      for (let i = 0; i < 128; i++) {
        doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
        ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
      }
      const W = estimateWindow(expectedLength || 1024);
      if (![1, 2, 4, 8].includes(W))
        throw new Error("ghash: invalid window size, expected 2, 4 or 8");
      this.W = W;
      const bits = 128;
      const windows = bits / W;
      const windowSize = this.windowSize = 2 ** W;
      const items = [];
      for (let w = 0; w < windows; w++) {
        for (let byte = 0; byte < windowSize; byte++) {
          let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
          for (let j = 0; j < W; j++) {
            const bit = byte >>> W - j - 1 & 1;
            if (!bit)
              continue;
            const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
            s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
          }
          items.push({ s0, s1, s2, s3 });
        }
      }
      this.t = items;
    }
    _updateBlock(s0, s1, s2, s3) {
      s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
      const { W, t, windowSize } = this;
      let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
      const mask = (1 << W) - 1;
      let w = 0;
      for (const num of [s0, s1, s2, s3]) {
        for (let bytePos = 0; bytePos < 4; bytePos++) {
          const byte = num >>> 8 * bytePos & 255;
          for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
            const bit = byte >>> W * bitPos & mask;
            const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
            o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
            w += 1;
          }
        }
      }
      this.s0 = o0;
      this.s1 = o1;
      this.s2 = o2;
      this.s3 = o3;
    }
    update(data) {
      aexists(this);
      abytes(data);
      data = copyBytes(data);
      const b32 = u32(data);
      const blocks = Math.floor(data.length / BLOCK_SIZE);
      const left = data.length % BLOCK_SIZE;
      for (let i = 0; i < blocks; i++) {
        this._updateBlock(b32[i * 4 + 0], b32[i * 4 + 1], b32[i * 4 + 2], b32[i * 4 + 3]);
      }
      if (left) {
        ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
        this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
        clean(ZEROS32);
      }
      return this;
    }
    destroy() {
      const { t } = this;
      for (const elm of t) {
        elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
      }
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { s0, s1, s2, s3 } = this;
      const o32 = u32(out);
      o32[0] = s0;
      o32[1] = s1;
      o32[2] = s2;
      o32[3] = s3;
      return out;
    }
    digest() {
      const res = new Uint8Array(BLOCK_SIZE);
      this.digestInto(res);
      this.destroy();
      return res;
    }
  };
  var Polyval = class extends GHASH {
    constructor(key, expectedLength) {
      abytes(key);
      const ghKey = _toGHASHKey(copyBytes(key));
      super(ghKey, expectedLength);
      clean(ghKey);
    }
    update(data) {
      aexists(this);
      abytes(data);
      data = copyBytes(data);
      const b32 = u32(data);
      const left = data.length % BLOCK_SIZE;
      const blocks = Math.floor(data.length / BLOCK_SIZE);
      for (let i = 0; i < blocks; i++) {
        this._updateBlock(swapLE(b32[i * 4 + 3]), swapLE(b32[i * 4 + 2]), swapLE(b32[i * 4 + 1]), swapLE(b32[i * 4 + 0]));
      }
      if (left) {
        ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
        this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
        clean(ZEROS32);
      }
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { s0, s1, s2, s3 } = this;
      const o32 = u32(out);
      o32[0] = s0;
      o32[1] = s1;
      o32[2] = s2;
      o32[3] = s3;
      return out.reverse();
    }
  };
  function wrapConstructorWithKey(hashCons) {
    const hashC = (msg, key) => hashCons(key, msg.length).update(msg).digest();
    const tmp = hashCons(new Uint8Array(16), 0);
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
    return hashC;
  }
  var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
  var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

  // ../../aes.js
  var BLOCK_SIZE2 = 16;
  var BLOCK_SIZE32 = 4;
  var EMPTY_BLOCK = /* @__PURE__ */ new Uint8Array(BLOCK_SIZE2);
  var POLY2 = 283;
  function validateKeyLength(key) {
    if (![16, 24, 32].includes(key.length))
      throw new Error('"aes key" expected Uint8Array of length 16/24/32, got length=' + key.length);
  }
  function mul22(n) {
    return n << 1 ^ POLY2 & -(n >> 7);
  }
  function mul(a, b) {
    let res = 0;
    for (; b > 0; b >>= 1) {
      res ^= a & -(b & 1);
      a = mul22(a);
    }
    return res;
  }
  var incBytes = (data, isLE2, carry = 1) => {
    if (!Number.isSafeInteger(carry))
      throw new Error("incBytes: wrong carry " + carry);
    abytes(data);
    for (let i = 0; i < data.length; i++) {
      const pos = !isLE2 ? data.length - 1 - i : i;
      carry = carry + (data[pos] & 255) | 0;
      data[pos] = carry & 255;
      carry >>>= 8;
    }
  };
  var sbox = /* @__PURE__ */ (() => {
    const t = new Uint8Array(256);
    for (let i = 0, x = 1; i < 256; i++, x ^= mul22(x))
      t[i] = x;
    const box = new Uint8Array(256);
    box[0] = 99;
    for (let i = 0; i < 255; i++) {
      let x = t[255 - i];
      x |= x << 8;
      box[t[i]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
    }
    clean(t);
    return box;
  })();
  var invSbox = /* @__PURE__ */ sbox.map((_, j) => sbox.indexOf(j));
  var rotr32_8 = (n) => n << 24 | n >>> 8;
  var rotl32_8 = (n) => n << 8 | n >>> 24;
  var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  function genTtable(sbox2, fn) {
    if (sbox2.length !== 256)
      throw new Error("Wrong sbox length");
    const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
    const T1 = T0.map(rotl32_8);
    const T2 = T1.map(rotl32_8);
    const T3 = T2.map(rotl32_8);
    const T01 = new Uint32Array(256 * 256);
    const T23 = new Uint32Array(256 * 256);
    const sbox22 = new Uint16Array(256 * 256);
    for (let i = 0; i < 256; i++) {
      for (let j = 0; j < 256; j++) {
        const idx = i * 256 + j;
        T01[idx] = T0[i] ^ T1[j];
        T23[idx] = T2[i] ^ T3[j];
        sbox22[idx] = sbox2[i] << 8 | sbox2[j];
      }
    }
    return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
  }
  var tableEncoding = /* @__PURE__ */ genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
  var tableDecoding = /* @__PURE__ */ genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
  var xPowers = /* @__PURE__ */ (() => {
    const p = new Uint8Array(16);
    for (let i = 0, x = 1; i < 16; i++, x = mul22(x))
      p[i] = x;
    return p;
  })();
  function expandKeyLE(key) {
    abytes(key);
    const len = key.length;
    validateKeyLength(key);
    const { sbox2 } = tableEncoding;
    const toClean = [];
    if (!isAligned32(key))
      toClean.push(key = copyBytes(key));
    const k32 = u32(key);
    const Nk = k32.length;
    const subByte = (n) => applySbox(sbox2, n, n, n, n);
    const xk = new Uint32Array(len + 28);
    xk.set(k32);
    for (let i = Nk; i < xk.length; i++) {
      let t = xk[i - 1];
      if (i % Nk === 0)
        t = subByte(rotr32_8(t)) ^ xPowers[i / Nk - 1];
      else if (Nk > 6 && i % Nk === 4)
        t = subByte(t);
      xk[i] = xk[i - Nk] ^ t;
    }
    clean(...toClean);
    return xk;
  }
  function expandKeyDecLE(key) {
    const encKey = expandKeyLE(key);
    const xk = encKey.slice();
    const Nk = encKey.length;
    const { sbox2 } = tableEncoding;
    const { T0, T1, T2, T3 } = tableDecoding;
    for (let i = 0; i < Nk; i += 4) {
      for (let j = 0; j < 4; j++)
        xk[i + j] = encKey[Nk - i - 4 + j];
    }
    clean(encKey);
    for (let i = 4; i < Nk - 4; i++) {
      const x = xk[i];
      const w = applySbox(sbox2, x, x, x, x);
      xk[i] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
    }
    return xk;
  }
  function apply0123(T01, T23, s0, s1, s2, s3) {
    return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
  }
  function applySbox(sbox2, s0, s1, s2, s3) {
    return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
  }
  function encrypt(xk, s0, s1, s2, s3) {
    const { sbox2, T01, T23 } = tableEncoding;
    let k = 0;
    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
    const rounds = xk.length / 4 - 2;
    for (let i = 0; i < rounds; i++) {
      const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
      const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
      const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
      const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
      s0 = t02, s1 = t12, s2 = t22, s3 = t32;
    }
    const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
    const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
    const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
    const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
    return { s0: t0, s1: t1, s2: t2, s3: t3 };
  }
  function decrypt(xk, s0, s1, s2, s3) {
    const { sbox2, T01, T23 } = tableDecoding;
    let k = 0;
    s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
    const rounds = xk.length / 4 - 2;
    for (let i = 0; i < rounds; i++) {
      const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
      const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
      const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
      const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
      s0 = t02, s1 = t12, s2 = t22, s3 = t32;
    }
    const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
    const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
    const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
    const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
    return { s0: t0, s1: t1, s2: t2, s3: t3 };
  }
  function ctrCounter(xk, nonce, src, dst) {
    abytes(nonce, BLOCK_SIZE2, "nonce");
    abytes(src);
    const srcLen = src.length;
    dst = getOutput(srcLen, dst);
    complexOverlapBytes(src, dst);
    const ctr2 = nonce;
    const c32 = u32(ctr2);
    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
    const src32 = u32(src);
    const dst32 = u32(dst);
    for (let i = 0; i + 4 <= src32.length; i += 4) {
      dst32[i + 0] = src32[i + 0] ^ s0;
      dst32[i + 1] = src32[i + 1] ^ s1;
      dst32[i + 2] = src32[i + 2] ^ s2;
      dst32[i + 3] = src32[i + 3] ^ s3;
      incBytes(ctr2, false, 1);
      ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
    }
    const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start < srcLen) {
      const b32 = new Uint32Array([s0, s1, s2, s3]);
      const buf = u8(b32);
      for (let i = start, pos = 0; i < srcLen; i++, pos++)
        dst[i] = src[i] ^ buf[pos];
      clean(b32);
    }
    return dst;
  }
  function ctr32(xk, isLE2, nonce, src, dst) {
    abytes(nonce, BLOCK_SIZE2, "nonce");
    abytes(src);
    dst = getOutput(src.length, dst);
    const ctr2 = nonce;
    const c32 = u32(ctr2);
    const view = createView(ctr2);
    const src32 = u32(src);
    const dst32 = u32(dst);
    const ctrPos = isLE2 ? 0 : 12;
    const srcLen = src.length;
    let ctrNum = view.getUint32(ctrPos, isLE2);
    let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
    for (let i = 0; i + 4 <= src32.length; i += 4) {
      dst32[i + 0] = src32[i + 0] ^ s0;
      dst32[i + 1] = src32[i + 1] ^ s1;
      dst32[i + 2] = src32[i + 2] ^ s2;
      dst32[i + 3] = src32[i + 3] ^ s3;
      ctrNum = ctrNum + 1 >>> 0;
      view.setUint32(ctrPos, ctrNum, isLE2);
      ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
    }
    const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start < srcLen) {
      const b32 = new Uint32Array([s0, s1, s2, s3]);
      const buf = u8(b32);
      for (let i = start, pos = 0; i < srcLen; i++, pos++)
        dst[i] = src[i] ^ buf[pos];
      clean(b32);
    }
    return dst;
  }
  var ctr = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aesctr(key, nonce) {
    function processCtr(buf, dst) {
      abytes(buf);
      if (dst !== void 0) {
        abytes(dst);
        if (!isAligned32(dst))
          throw new Error("unaligned destination");
      }
      const xk = expandKeyLE(key);
      const n = copyBytes(nonce);
      const toClean = [xk, n];
      if (!isAligned32(buf))
        toClean.push(buf = copyBytes(buf));
      const out = ctrCounter(xk, n, buf, dst);
      clean(...toClean);
      return out;
    }
    return {
      encrypt: (plaintext, dst) => processCtr(plaintext, dst),
      decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
    };
  });
  function validateBlockDecrypt(data) {
    abytes(data);
    if (data.length % BLOCK_SIZE2 !== 0) {
      throw new Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size " + BLOCK_SIZE2);
    }
  }
  function validateBlockEncrypt(plaintext, pcks5, dst) {
    abytes(plaintext);
    let outLen = plaintext.length;
    const remaining = outLen % BLOCK_SIZE2;
    if (!pcks5 && remaining !== 0)
      throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
    if (!isAligned32(plaintext))
      plaintext = copyBytes(plaintext);
    const b = u32(plaintext);
    if (pcks5) {
      let left = BLOCK_SIZE2 - remaining;
      if (!left)
        left = BLOCK_SIZE2;
      outLen = outLen + left;
    }
    dst = getOutput(outLen, dst);
    complexOverlapBytes(plaintext, dst);
    const o = u32(dst);
    return { b, o, out: dst };
  }
  function validatePCKS(data, pcks5) {
    if (!pcks5)
      return data;
    const len = data.length;
    if (!len)
      throw new Error("aes/pcks5: empty ciphertext not allowed");
    const lastByte = data[len - 1];
    if (lastByte <= 0 || lastByte > 16)
      throw new Error("aes/pcks5: wrong padding");
    const out = data.subarray(0, -lastByte);
    for (let i = 0; i < lastByte; i++)
      if (data[len - i - 1] !== lastByte)
        throw new Error("aes/pcks5: wrong padding");
    return out;
  }
  function padPCKS(left) {
    const tmp = new Uint8Array(16);
    const tmp32 = u32(tmp);
    tmp.set(left);
    const paddingByte = BLOCK_SIZE2 - left.length;
    for (let i = BLOCK_SIZE2 - paddingByte; i < BLOCK_SIZE2; i++)
      tmp[i] = paddingByte;
    return tmp32;
  }
  var ecb = /* @__PURE__ */ wrapCipher({ blockSize: 16 }, function aesecb(key, opts = {}) {
    const pcks5 = !opts.disablePadding;
    return {
      encrypt(plaintext, dst) {
        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
        const xk = expandKeyLE(key);
        let i = 0;
        for (; i + 4 <= b.length; ) {
          const { s0, s1, s2, s3 } = encrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
          o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
        }
        if (pcks5) {
          const tmp32 = padPCKS(plaintext.subarray(i * 4));
          const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
          o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
        }
        clean(xk);
        return _out;
      },
      decrypt(ciphertext, dst) {
        validateBlockDecrypt(ciphertext);
        const xk = expandKeyDecLE(key);
        dst = getOutput(ciphertext.length, dst);
        const toClean = [xk];
        if (!isAligned32(ciphertext))
          toClean.push(ciphertext = copyBytes(ciphertext));
        complexOverlapBytes(ciphertext, dst);
        const b = u32(ciphertext);
        const o = u32(dst);
        for (let i = 0; i + 4 <= b.length; ) {
          const { s0, s1, s2, s3 } = decrypt(xk, b[i + 0], b[i + 1], b[i + 2], b[i + 3]);
          o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
        }
        clean(...toClean);
        return validatePCKS(dst, pcks5);
      }
    };
  });
  var cbc = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 16 }, function aescbc(key, iv, opts = {}) {
    const pcks5 = !opts.disablePadding;
    return {
      encrypt(plaintext, dst) {
        const xk = expandKeyLE(key);
        const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
        let _iv = iv;
        const toClean = [xk];
        if (!isAligned32(_iv))
          toClean.push(_iv = copyBytes(_iv));
        const n32 = u32(_iv);
        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
        let i = 0;
        for (; i + 4 <= b.length; ) {
          s0 ^= b[i + 0], s1 ^= b[i + 1], s2 ^= b[i + 2], s3 ^= b[i + 3];
          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
          o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
        }
        if (pcks5) {
          const tmp32 = padPCKS(plaintext.subarray(i * 4));
          s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
          ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
          o[i++] = s0, o[i++] = s1, o[i++] = s2, o[i++] = s3;
        }
        clean(...toClean);
        return _out;
      },
      decrypt(ciphertext, dst) {
        validateBlockDecrypt(ciphertext);
        const xk = expandKeyDecLE(key);
        let _iv = iv;
        const toClean = [xk];
        if (!isAligned32(_iv))
          toClean.push(_iv = copyBytes(_iv));
        const n32 = u32(_iv);
        dst = getOutput(ciphertext.length, dst);
        if (!isAligned32(ciphertext))
          toClean.push(ciphertext = copyBytes(ciphertext));
        complexOverlapBytes(ciphertext, dst);
        const b = u32(ciphertext);
        const o = u32(dst);
        let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
        for (let i = 0; i + 4 <= b.length; ) {
          const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
          s0 = b[i + 0], s1 = b[i + 1], s2 = b[i + 2], s3 = b[i + 3];
          const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
          o[i++] = o0 ^ ps0, o[i++] = o1 ^ ps1, o[i++] = o2 ^ ps2, o[i++] = o3 ^ ps3;
        }
        clean(...toClean);
        return validatePCKS(dst, pcks5);
      }
    };
  });
  function computeTag(fn, isLE2, key, data, AAD) {
    const aadLength = AAD ? AAD.length : 0;
    const h = fn.create(key, data.length + aadLength);
    if (AAD)
      h.update(AAD);
    const num = u64Lengths(8 * data.length, 8 * aadLength, isLE2);
    h.update(data);
    h.update(num);
    const res = h.digest();
    clean(num);
    return res;
  }
  var gcm = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aesgcm(key, nonce, AAD) {
    if (nonce.length < 8)
      throw new Error("aes/gcm: invalid nonce length");
    const tagLength = 16;
    function _computeTag(authKey, tagMask, data) {
      const tag = computeTag(ghash, false, authKey, data, AAD);
      for (let i = 0; i < tagMask.length; i++)
        tag[i] ^= tagMask[i];
      return tag;
    }
    function deriveKeys() {
      const xk = expandKeyLE(key);
      const authKey = EMPTY_BLOCK.slice();
      const counter = EMPTY_BLOCK.slice();
      ctr32(xk, false, counter, counter, authKey);
      if (nonce.length === 12) {
        counter.set(nonce);
      } else {
        const nonceLen = EMPTY_BLOCK.slice();
        const view = createView(nonceLen);
        view.setBigUint64(8, BigInt(nonce.length * 8), false);
        const g = ghash.create(authKey).update(nonce).update(nonceLen);
        g.digestInto(counter);
        g.destroy();
      }
      const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
      return { xk, authKey, counter, tagMask };
    }
    return {
      encrypt(plaintext) {
        const { xk, authKey, counter, tagMask } = deriveKeys();
        const out = new Uint8Array(plaintext.length + tagLength);
        const toClean = [xk, authKey, counter, tagMask];
        if (!isAligned32(plaintext))
          toClean.push(plaintext = copyBytes(plaintext));
        ctr32(xk, false, counter, plaintext, out.subarray(0, plaintext.length));
        const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
        toClean.push(tag);
        out.set(tag, plaintext.length);
        clean(...toClean);
        return out;
      },
      decrypt(ciphertext) {
        const { xk, authKey, counter, tagMask } = deriveKeys();
        const toClean = [xk, authKey, tagMask, counter];
        if (!isAligned32(ciphertext))
          toClean.push(ciphertext = copyBytes(ciphertext));
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = _computeTag(authKey, tagMask, data);
        toClean.push(tag);
        if (!equalBytes(tag, passedTag))
          throw new Error("aes/gcm: invalid ghash tag");
        const out = ctr32(xk, false, counter, data);
        clean(...toClean);
        return out;
      }
    };
  });
  var limit = (name, min, max) => (value) => {
    if (!Number.isSafeInteger(value) || min > value || value > max) {
      const minmax = "[" + min + ".." + max + "]";
      throw new Error("" + name + ": expected value in range " + minmax + ", got " + value);
    }
  };
  var gcmsiv = /* @__PURE__ */ wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16, varSizeNonce: true }, function aessiv(key, nonce, AAD) {
    const tagLength = 16;
    const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
    const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
    const NONCE_LIMIT = limit("nonce", 12, 12);
    const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
    abytes(key);
    validateKeyLength(key);
    NONCE_LIMIT(nonce.length);
    if (AAD !== void 0)
      AAD_LIMIT(AAD.length);
    function deriveKeys() {
      const xk = expandKeyLE(key);
      const encKey = new Uint8Array(key.length);
      const authKey = new Uint8Array(16);
      const toClean = [xk, encKey];
      let _nonce = nonce;
      if (!isAligned32(_nonce))
        toClean.push(_nonce = copyBytes(_nonce));
      const n32 = u32(_nonce);
      let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
      let counter = 0;
      for (const derivedKey of [authKey, encKey].map(u32)) {
        const d32 = u32(derivedKey);
        for (let i = 0; i < d32.length; i += 2) {
          const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);
          d32[i + 0] = o0;
          d32[i + 1] = o1;
          s0 = ++counter;
        }
      }
      const res = { authKey, encKey: expandKeyLE(encKey) };
      clean(...toClean);
      return res;
    }
    function _computeTag(encKey, authKey, data) {
      const tag = computeTag(polyval, true, authKey, data, AAD);
      for (let i = 0; i < 12; i++)
        tag[i] ^= nonce[i];
      tag[15] &= 127;
      const t32 = u32(tag);
      let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
      ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));
      t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
      return tag;
    }
    function processSiv(encKey, tag, input) {
      let block = copyBytes(tag);
      block[15] |= 128;
      const res = ctr32(encKey, true, block, input);
      clean(block);
      return res;
    }
    return {
      encrypt(plaintext) {
        PLAIN_LIMIT(plaintext.length);
        const { encKey, authKey } = deriveKeys();
        const tag = _computeTag(encKey, authKey, plaintext);
        const toClean = [encKey, authKey, tag];
        if (!isAligned32(plaintext))
          toClean.push(plaintext = copyBytes(plaintext));
        const out = new Uint8Array(plaintext.length + tagLength);
        out.set(tag, plaintext.length);
        out.set(processSiv(encKey, tag, plaintext));
        clean(...toClean);
        return out;
      },
      decrypt(ciphertext) {
        CIPHER_LIMIT(ciphertext.length);
        const tag = ciphertext.subarray(-tagLength);
        const { encKey, authKey } = deriveKeys();
        const toClean = [encKey, authKey];
        if (!isAligned32(ciphertext))
          toClean.push(ciphertext = copyBytes(ciphertext));
        const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
        const expectedTag = _computeTag(encKey, authKey, plaintext);
        toClean.push(expectedTag);
        if (!equalBytes(tag, expectedTag)) {
          clean(...toClean);
          throw new Error("invalid polyval tag");
        }
        clean(...toClean);
        return plaintext;
      }
    };
  });
  var siv = gcmsiv;
  function isBytes32(a) {
    return a instanceof Uint32Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint32Array";
  }
  function encryptBlock(xk, block) {
    abytes(block, 16, "block");
    if (!isBytes32(xk))
      throw new Error("_encryptBlock accepts result of expandKeyLE");
    const b32 = u32(block);
    let { s0, s1, s2, s3 } = encrypt(xk, b32[0], b32[1], b32[2], b32[3]);
    b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
    return block;
  }
  function decryptBlock(xk, block) {
    abytes(block, 16, "block");
    if (!isBytes32(xk))
      throw new Error("_decryptBlock accepts result of expandKeyLE");
    const b32 = u32(block);
    let { s0, s1, s2, s3 } = decrypt(xk, b32[0], b32[1], b32[2], b32[3]);
    b32[0] = s0, b32[1] = s1, b32[2] = s2, b32[3] = s3;
    return block;
  }
  var AESW = {
    /*
    High-level pseudocode:
    ```
    A: u64 = IV
    out = []
    for (let i=0, ctr = 0; i<6; i++) {
      for (const chunk of chunks(plaintext, 8)) {
        A ^= swapEndianess(ctr++)
        [A, res] = chunks(encrypt(A || chunk), 8);
        out ||= res
      }
    }
    out = A || out
    ```
    Decrypt is the same, but reversed.
    */
    encrypt(kek, out) {
      if (out.length >= 2 ** 32)
        throw new Error("plaintext should be less than 4gb");
      const xk = expandKeyLE(kek);
      if (out.length === 16)
        encryptBlock(xk, out);
      else {
        const o32 = u32(out);
        let a0 = o32[0], a1 = o32[1];
        for (let j = 0, ctr2 = 1; j < 6; j++) {
          for (let pos = 2; pos < o32.length; pos += 2, ctr2++) {
            const { s0, s1, s2, s3 } = encrypt(xk, a0, a1, o32[pos], o32[pos + 1]);
            a0 = s0, a1 = s1 ^ byteSwap(ctr2), o32[pos] = s2, o32[pos + 1] = s3;
          }
        }
        o32[0] = a0, o32[1] = a1;
      }
      xk.fill(0);
    },
    decrypt(kek, out) {
      if (out.length - 8 >= 2 ** 32)
        throw new Error("ciphertext should be less than 4gb");
      const xk = expandKeyDecLE(kek);
      const chunks = out.length / 8 - 1;
      if (chunks === 1)
        decryptBlock(xk, out);
      else {
        const o32 = u32(out);
        let a0 = o32[0], a1 = o32[1];
        for (let j = 0, ctr2 = chunks * 6; j < 6; j++) {
          for (let pos = chunks * 2; pos >= 1; pos -= 2, ctr2--) {
            a1 ^= byteSwap(ctr2);
            const { s0, s1, s2, s3 } = decrypt(xk, a0, a1, o32[pos], o32[pos + 1]);
            a0 = s0, a1 = s1, o32[pos] = s2, o32[pos + 1] = s3;
          }
        }
        o32[0] = a0, o32[1] = a1;
      }
      xk.fill(0);
    }
  };
  var AESKW_IV = /* @__PURE__ */ new Uint8Array(8).fill(166);
  var aeskw = /* @__PURE__ */ wrapCipher({ blockSize: 8 }, (kek) => ({
    encrypt(plaintext) {
      if (!plaintext.length || plaintext.length % 8 !== 0)
        throw new Error("invalid plaintext length");
      if (plaintext.length === 8)
        throw new Error("8-byte keys not allowed in AESKW, use AESKWP instead");
      const out = concatBytes(AESKW_IV, plaintext);
      AESW.encrypt(kek, out);
      return out;
    },
    decrypt(ciphertext) {
      if (ciphertext.length % 8 !== 0 || ciphertext.length < 3 * 8)
        throw new Error("invalid ciphertext length");
      const out = copyBytes(ciphertext);
      AESW.decrypt(kek, out);
      if (!equalBytes(out.subarray(0, 8), AESKW_IV))
        throw new Error("integrity check failed");
      out.subarray(0, 8).fill(0);
      return out.subarray(8);
    }
  }));
  var AESKWP_IV = 2790873510;
  var aeskwp = /* @__PURE__ */ wrapCipher({ blockSize: 8 }, (kek) => ({
    encrypt(plaintext) {
      if (!plaintext.length)
        throw new Error("invalid plaintext length");
      const padded = Math.ceil(plaintext.length / 8) * 8;
      const out = new Uint8Array(8 + padded);
      out.set(plaintext, 8);
      const out32 = u32(out);
      out32[0] = AESKWP_IV;
      out32[1] = byteSwap(plaintext.length);
      AESW.encrypt(kek, out);
      return out;
    },
    decrypt(ciphertext) {
      if (ciphertext.length < 16)
        throw new Error("invalid ciphertext length");
      const out = copyBytes(ciphertext);
      const o32 = u32(out);
      AESW.decrypt(kek, out);
      const len = byteSwap(o32[1]) >>> 0;
      const padded = Math.ceil(len / 8) * 8;
      if (o32[0] !== AESKWP_IV || out.length - 8 !== padded)
        throw new Error("integrity check failed");
      for (let i = len; i < padded; i++)
        if (out[8 + i] !== 0)
          throw new Error("integrity check failed");
      out.subarray(0, 8).fill(0);
      return out.subarray(8, 8 + len);
    }
  }));

  // ../../_arx.js
  var encodeStr = (str) => Uint8Array.from(str.split(""), (c) => c.charCodeAt(0));
  var sigma16 = encodeStr("expand 16-byte k");
  var sigma32 = encodeStr("expand 32-byte k");
  var sigma16_32 = u32(sigma16);
  var sigma32_32 = u32(sigma32);
  function rotl(a, b) {
    return a << b | a >>> 32 - b;
  }
  function isAligned322(b) {
    return b.byteOffset % 4 === 0;
  }
  var BLOCK_LEN = 64;
  var BLOCK_LEN32 = 16;
  var MAX_COUNTER = 2 ** 32 - 1;
  var U32_EMPTY = Uint32Array.of();
  function runCipher(core, sigma, key, nonce, data, output, counter, rounds) {
    const len = data.length;
    const block = new Uint8Array(BLOCK_LEN);
    const b32 = u32(block);
    const isAligned = isAligned322(data) && isAligned322(output);
    const d32 = isAligned ? u32(data) : U32_EMPTY;
    const o32 = isAligned ? u32(output) : U32_EMPTY;
    for (let pos = 0; pos < len; counter++) {
      core(sigma, key, nonce, b32, counter, rounds);
      if (counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      const take = Math.min(BLOCK_LEN, len - pos);
      if (isAligned && take === BLOCK_LEN) {
        const pos32 = pos / 4;
        if (pos % 4 !== 0)
          throw new Error("arx: invalid block position");
        for (let j = 0, posj; j < BLOCK_LEN32; j++) {
          posj = pos32 + j;
          o32[posj] = d32[posj] ^ b32[j];
        }
        pos += BLOCK_LEN;
        continue;
      }
      for (let j = 0, posj; j < take; j++) {
        posj = pos + j;
        output[posj] = data[posj] ^ block[j];
      }
      pos += take;
    }
  }
  function createCipher(core, opts) {
    const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
    if (typeof core !== "function")
      throw new Error("core must be a function");
    anumber(counterLength);
    anumber(rounds);
    abool(counterRight);
    abool(allowShortKeys);
    return (key, nonce, data, output, counter = 0) => {
      abytes(key, void 0, "key");
      abytes(nonce, void 0, "nonce");
      abytes(data, void 0, "data");
      const len = data.length;
      if (output === void 0)
        output = new Uint8Array(len);
      abytes(output, void 0, "output");
      anumber(counter);
      if (counter < 0 || counter >= MAX_COUNTER)
        throw new Error("arx: counter overflow");
      if (output.length < len)
        throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);
      const toClean = [];
      let l = key.length;
      let k;
      let sigma;
      if (l === 32) {
        toClean.push(k = copyBytes(key));
        sigma = sigma32_32;
      } else if (l === 16 && allowShortKeys) {
        k = new Uint8Array(32);
        k.set(key);
        k.set(key, 16);
        sigma = sigma16_32;
        toClean.push(k);
      } else {
        abytes(key, 32, "arx key");
        throw new Error("invalid key size");
      }
      if (!isAligned322(nonce))
        toClean.push(nonce = copyBytes(nonce));
      const k32 = u32(k);
      if (extendNonceFn) {
        if (nonce.length !== 24)
          throw new Error(`arx: extended nonce must be 24 bytes`);
        extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);
        nonce = nonce.subarray(16);
      }
      const nonceNcLen = 16 - counterLength;
      if (nonceNcLen !== nonce.length)
        throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
      if (nonceNcLen !== 12) {
        const nc = new Uint8Array(12);
        nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
        nonce = nc;
        toClean.push(nonce);
      }
      const n32 = u32(nonce);
      runCipher(core, sigma, k32, n32, data, output, counter, rounds);
      clean(...toClean);
      return output;
    };
  }

  // ../../_poly1305.js
  function u8to16(a, i) {
    return a[i++] & 255 | (a[i++] & 255) << 8;
  }
  var Poly1305 = class {
    blockLen = 16;
    outputLen = 16;
    buffer = new Uint8Array(16);
    r = new Uint16Array(10);
    // Allocating 1 array with .subarray() here is slower than 3
    h = new Uint16Array(10);
    pad = new Uint16Array(8);
    pos = 0;
    finished = false;
    // Can be speed-up using BigUint64Array, at the cost of complexity
    constructor(key) {
      key = copyBytes(abytes(key, 32, "key"));
      const t0 = u8to16(key, 0);
      const t1 = u8to16(key, 2);
      const t2 = u8to16(key, 4);
      const t3 = u8to16(key, 6);
      const t4 = u8to16(key, 8);
      const t5 = u8to16(key, 10);
      const t6 = u8to16(key, 12);
      const t7 = u8to16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i = 0; i < 8; i++)
        this.pad[i] = u8to16(key, 16 + 2 * i);
    }
    process(data, offset, isLast = false) {
      const hibit = isLast ? 0 : 1 << 11;
      const { h, r } = this;
      const r0 = r[0];
      const r1 = r[1];
      const r2 = r[2];
      const r3 = r[3];
      const r4 = r[4];
      const r5 = r[5];
      const r6 = r[6];
      const r7 = r[7];
      const r8 = r[8];
      const r9 = r[9];
      const t0 = u8to16(data, offset + 0);
      const t1 = u8to16(data, offset + 2);
      const t2 = u8to16(data, offset + 4);
      const t3 = u8to16(data, offset + 6);
      const t4 = u8to16(data, offset + 8);
      const t5 = u8to16(data, offset + 10);
      const t6 = u8to16(data, offset + 12);
      const t7 = u8to16(data, offset + 14);
      let h0 = h[0] + (t0 & 8191);
      let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
      let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
      let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
      let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
      let h5 = h[5] + (t4 >>> 1 & 8191);
      let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
      let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
      let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
      let h9 = h[9] + (t7 >>> 5 | hibit);
      let c = 0;
      let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
      c = d0 >>> 13;
      d0 &= 8191;
      d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
      c += d0 >>> 13;
      d0 &= 8191;
      let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
      c = d1 >>> 13;
      d1 &= 8191;
      d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
      c += d1 >>> 13;
      d1 &= 8191;
      let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
      c = d2 >>> 13;
      d2 &= 8191;
      d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
      c += d2 >>> 13;
      d2 &= 8191;
      let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
      c = d3 >>> 13;
      d3 &= 8191;
      d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
      c += d3 >>> 13;
      d3 &= 8191;
      let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
      c = d4 >>> 13;
      d4 &= 8191;
      d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
      c += d4 >>> 13;
      d4 &= 8191;
      let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
      c = d5 >>> 13;
      d5 &= 8191;
      d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
      c += d5 >>> 13;
      d5 &= 8191;
      let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
      c = d6 >>> 13;
      d6 &= 8191;
      d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
      c += d6 >>> 13;
      d6 &= 8191;
      let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
      c = d7 >>> 13;
      d7 &= 8191;
      d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
      c += d7 >>> 13;
      d7 &= 8191;
      let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
      c = d8 >>> 13;
      d8 &= 8191;
      d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
      c += d8 >>> 13;
      d8 &= 8191;
      let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
      c = d9 >>> 13;
      d9 &= 8191;
      d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
      c += d9 >>> 13;
      d9 &= 8191;
      c = (c << 2) + c | 0;
      c = c + d0 | 0;
      d0 = c & 8191;
      c = c >>> 13;
      d1 += c;
      h[0] = d0;
      h[1] = d1;
      h[2] = d2;
      h[3] = d3;
      h[4] = d4;
      h[5] = d5;
      h[6] = d6;
      h[7] = d7;
      h[8] = d8;
      h[9] = d9;
    }
    finalize() {
      const { h, pad } = this;
      const g = new Uint16Array(10);
      let c = h[1] >>> 13;
      h[1] &= 8191;
      for (let i = 2; i < 10; i++) {
        h[i] += c;
        c = h[i] >>> 13;
        h[i] &= 8191;
      }
      h[0] += c * 5;
      c = h[0] >>> 13;
      h[0] &= 8191;
      h[1] += c;
      c = h[1] >>> 13;
      h[1] &= 8191;
      h[2] += c;
      g[0] = h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i = 1; i < 10; i++) {
        g[i] = h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      g[9] -= 1 << 13;
      let mask = (c ^ 1) - 1;
      for (let i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (let i = 0; i < 10; i++)
        h[i] = h[i] & mask | g[i];
      h[0] = (h[0] | h[1] << 13) & 65535;
      h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
      h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
      h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
      h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
      h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
      h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
      h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
      let f = h[0] + pad[0];
      h[0] = f & 65535;
      for (let i = 1; i < 8; i++) {
        f = (h[i] + pad[i] | 0) + (f >>> 16) | 0;
        h[i] = f & 65535;
      }
      clean(g);
    }
    update(data) {
      aexists(this);
      abytes(data);
      data = copyBytes(data);
      const { buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(data, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(buffer, 0, false);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      clean(this.h, this.r, this.buffer, this.pad);
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, h } = this;
      let { pos } = this;
      if (pos) {
        buffer[pos++] = 1;
        for (; pos < 16; pos++)
          buffer[pos] = 0;
        this.process(buffer, 0, true);
      }
      this.finalize();
      let opos = 0;
      for (let i = 0; i < 8; i++) {
        out[opos++] = h[i] >>> 0;
        out[opos++] = h[i] >>> 8;
      }
      return out;
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  function wrapConstructorWithKey2(hashCons) {
    const hashC = (msg, key) => hashCons(key).update(msg).digest();
    const tmp = hashCons(new Uint8Array(32));
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (key) => hashCons(key);
    return hashC;
  }
  var poly1305 = /* @__PURE__ */ (() => wrapConstructorWithKey2((key) => new Poly1305(key)))();

  // ../../chacha.js
  function chachaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hchacha(s, k, i, out) {
    let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for (let r = 0; r < 20; r += 2) {
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 16);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 12);
      x00 = x00 + x04 | 0;
      x12 = rotl(x12 ^ x00, 8);
      x08 = x08 + x12 | 0;
      x04 = rotl(x04 ^ x08, 7);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 16);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 12);
      x01 = x01 + x05 | 0;
      x13 = rotl(x13 ^ x01, 8);
      x09 = x09 + x13 | 0;
      x05 = rotl(x05 ^ x09, 7);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 16);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 12);
      x02 = x02 + x06 | 0;
      x14 = rotl(x14 ^ x02, 8);
      x10 = x10 + x14 | 0;
      x06 = rotl(x06 ^ x10, 7);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 16);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 12);
      x03 = x03 + x07 | 0;
      x15 = rotl(x15 ^ x03, 8);
      x11 = x11 + x15 | 0;
      x07 = rotl(x07 ^ x11, 7);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 16);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 12);
      x00 = x00 + x05 | 0;
      x15 = rotl(x15 ^ x00, 8);
      x10 = x10 + x15 | 0;
      x05 = rotl(x05 ^ x10, 7);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 16);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 12);
      x01 = x01 + x06 | 0;
      x12 = rotl(x12 ^ x01, 8);
      x11 = x11 + x12 | 0;
      x06 = rotl(x06 ^ x11, 7);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 16);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 12);
      x02 = x02 + x07 | 0;
      x13 = rotl(x13 ^ x02, 8);
      x08 = x08 + x13 | 0;
      x07 = rotl(x07 ^ x08, 7);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 16);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 12);
      x03 = x03 + x04 | 0;
      x14 = rotl(x14 ^ x03, 8);
      x09 = x09 + x14 | 0;
      x04 = rotl(x04 ^ x09, 7);
    }
    let oi = 0;
    out[oi++] = x00;
    out[oi++] = x01;
    out[oi++] = x02;
    out[oi++] = x03;
    out[oi++] = x12;
    out[oi++] = x13;
    out[oi++] = x14;
    out[oi++] = x15;
  }
  var chacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    allowShortKeys: false
  });
  var xchacha20 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 8,
    extendNonceFn: hchacha,
    allowShortKeys: false
  });
  var chacha8 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    rounds: 8
  });
  var chacha12 = /* @__PURE__ */ createCipher(chachaCore, {
    counterRight: false,
    counterLength: 4,
    rounds: 12
  });
  var ZEROS162 = /* @__PURE__ */ new Uint8Array(16);
  var updatePadded = (h, msg) => {
    h.update(msg);
    const leftover = msg.length % 16;
    if (leftover)
      h.update(ZEROS162.subarray(leftover));
  };
  var ZEROS322 = /* @__PURE__ */ new Uint8Array(32);
  function computeTag2(fn, key, nonce, ciphertext, AAD) {
    if (AAD !== void 0)
      abytes(AAD, void 0, "AAD");
    const authKey = fn(key, nonce, ZEROS322);
    const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);
    const h = poly1305.create(authKey);
    if (AAD)
      updatePadded(h, AAD);
    updatePadded(h, ciphertext);
    h.update(lengths);
    const res = h.digest();
    clean(authKey, lengths);
    return res;
  }
  var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
    const tagLength = 16;
    return {
      encrypt(plaintext, output) {
        const plength = plaintext.length;
        output = getOutput(plength + tagLength, output, false);
        output.set(plaintext);
        const oPlain = output.subarray(0, -tagLength);
        xorStream(key, nonce, oPlain, oPlain, 1);
        const tag = computeTag2(xorStream, key, nonce, oPlain, AAD);
        output.set(tag, plength);
        clean(tag);
        return output;
      },
      decrypt(ciphertext, output) {
        output = getOutput(ciphertext.length - tagLength, output, false);
        const data = ciphertext.subarray(0, -tagLength);
        const passedTag = ciphertext.subarray(-tagLength);
        const tag = computeTag2(xorStream, key, nonce, data, AAD);
        if (!equalBytes(passedTag, tag))
          throw new Error("invalid tag");
        output.set(ciphertext.subarray(0, -tagLength));
        xorStream(key, nonce, output, output, 1);
        clean(tag);
        return output;
      }
    };
  };
  var chacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
  var xchacha20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

  // ../../salsa.js
  function salsaCore(s, k, n, out, cnt, rounds = 20) {
    let y00 = s[0], y01 = k[0], y02 = k[1], y03 = k[2], y04 = k[3], y05 = s[1], y06 = n[0], y07 = n[1], y08 = cnt, y09 = 0, y10 = s[2], y11 = k[4], y12 = k[5], y13 = k[6], y14 = k[7], y15 = s[3];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let r = 0; r < rounds; r += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    let oi = 0;
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function hsalsa(s, k, i, out) {
    let x00 = s[0], x01 = k[0], x02 = k[1], x03 = k[2], x04 = k[3], x05 = s[1], x06 = i[0], x07 = i[1], x08 = i[2], x09 = i[3], x10 = s[2], x11 = k[4], x12 = k[5], x13 = k[6], x14 = k[7], x15 = s[3];
    for (let r = 0; r < 20; r += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    let oi = 0;
    out[oi++] = x00;
    out[oi++] = x05;
    out[oi++] = x10;
    out[oi++] = x15;
    out[oi++] = x06;
    out[oi++] = x07;
    out[oi++] = x08;
    out[oi++] = x09;
  }
  var salsa20 = /* @__PURE__ */ createCipher(salsaCore, {
    allowShortKeys: true,
    counterRight: true
  });
  var xsalsa20 = /* @__PURE__ */ createCipher(salsaCore, {
    counterRight: true,
    extendNonceFn: hsalsa
  });
  var xsalsa20poly1305 = /* @__PURE__ */ wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, (key, nonce) => {
    return {
      encrypt(plaintext, output) {
        output = getOutput(plaintext.length + 32, output, false);
        const authKey = output.subarray(0, 32);
        const ciphPlaintext = output.subarray(32);
        output.set(plaintext, 32);
        clean(authKey);
        xsalsa20(key, nonce, output, output);
        const tag = poly1305(ciphPlaintext, authKey);
        output.set(tag, 16);
        clean(output.subarray(0, 16), tag);
        return output.subarray(16);
      },
      decrypt(ciphertext, output) {
        abytes(ciphertext);
        output = getOutput(ciphertext.length + 32, output, false);
        const tmp = output.subarray(0, 32);
        const passedTag = output.subarray(32, 48);
        const ciphPlaintext = output.subarray(48);
        output.set(ciphertext, 32);
        clean(tmp);
        const authKey = xsalsa20(key, nonce, tmp, tmp);
        const tag = poly1305(ciphPlaintext, authKey);
        if (!equalBytes(passedTag, tag))
          throw new Error("invalid tag");
        xsalsa20(key, nonce, output.subarray(16), output.subarray(16));
        clean(tmp, passedTag, tag);
        return ciphPlaintext;
      }
    };
  });

  // input.js
  var utils = { bytesToHex, hexToBytes, managedNonce, randomBytes };
  return __toCommonJS(input_exports);
})();
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\noble-ciphers.js
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\noble-hashes.js
# SIZE: 122487 bytes
# HASH: d61b81b0c71bb128e65d984e0161aedf527b40280f67970e9a061e5b09f14d89
# MODIFIED: 2025-08-29T04:23:40.782690
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

var nobleHashes = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // input.js
  var input_exports = {};
  __export(input_exports, {
    argon2id: () => argon2id,
    blake224: () => blake224,
    blake256: () => blake256,
    blake2b: () => blake2b,
    blake2s: () => blake2s,
    blake3: () => blake3,
    blake384: () => blake384,
    blake512: () => blake512,
    cshake128: () => cshake128,
    cshake256: () => cshake256,
    eskdf: () => eskdf,
    hkdf: () => hkdf,
    hmac: () => hmac,
    keccak_224: () => keccak_224,
    keccak_256: () => keccak_256,
    keccak_384: () => keccak_384,
    keccak_512: () => keccak_512,
    keccakprg: () => keccakprg,
    kmac128: () => kmac128,
    kmac256: () => kmac256,
    kt128: () => kt128,
    kt256: () => kt256,
    md5: () => md5,
    pbkdf2: () => pbkdf2,
    pbkdf2Async: () => pbkdf2Async,
    ripemd160: () => ripemd160,
    scrypt: () => scrypt,
    scryptAsync: () => scryptAsync,
    sha1: () => sha1,
    sha224: () => sha224,
    sha256: () => sha256,
    sha384: () => sha384,
    sha3_224: () => sha3_224,
    sha3_256: () => sha3_256,
    sha3_384: () => sha3_384,
    sha3_512: () => sha3_512,
    sha512: () => sha512,
    sha512_224: () => sha512_224,
    sha512_256: () => sha512_256,
    shake128: () => shake128,
    shake256: () => shake256,
    turboshake128: () => turboshake128,
    turboshake256: () => turboshake256,
    utils: () => utils,
    webcrypto: () => webcrypto_exports
  });

  // ../../utils.js
  function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
  }
  function anumber(n, title = "") {
    if (!Number.isSafeInteger(n) || n < 0) {
      const prefix = title && `"${title}" `;
      throw new Error(`${prefix}expected integer >0, got ${n}`);
    }
  }
  function abytes(value, length, title = "") {
    const bytes = isBytes(value);
    const len = value?.length;
    const needsLen = length !== void 0;
    if (!bytes || needsLen && len !== length) {
      const prefix = title && `"${title}" `;
      const ofLen = needsLen ? ` of length ${length}` : "";
      const got = bytes ? `length=${len}` : `type=${typeof value}`;
      throw new Error(prefix + "expected Uint8Array" + ofLen + ", got " + got);
    }
    return value;
  }
  function ahash(h) {
    if (typeof h !== "function" || typeof h.create !== "function")
      throw new Error("Hash must wrapped by utils.createHasher");
    anumber(h.outputLen);
    anumber(h.blockLen);
  }
  function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function aoutput(out, instance) {
    abytes(out, void 0, "digestInto() output");
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error('"digestInto() output" expected to be of length >=' + min);
    }
  }
  function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }
  function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
      arrays[i].fill(0);
    }
  }
  function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }
  function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }
  function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
  }
  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
  function byteSwap(word) {
    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
  }
  var swap8IfBE = isLE ? (n) => n : (n) => byteSwap(n);
  function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
      arr[i] = byteSwap(arr[i]);
    }
    return arr;
  }
  var swap32IfBE = isLE ? (u) => u : byteSwap32;
  var hasHexBuiltin = /* @__PURE__ */ (() => (
    // @ts-ignore
    typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
  ))();
  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  function bytesToHex(bytes) {
    abytes(bytes);
    if (hasHexBuiltin)
      return bytes.toHex();
    let hex = "";
    for (let i = 0; i < bytes.length; i++) {
      hex += hexes[bytes[i]];
    }
    return hex;
  }
  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
      return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F)
      return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f)
      return ch - (asciis.a - 10);
    return;
  }
  function hexToBytes(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    if (hasHexBuiltin)
      return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("hex string expected, got unpadded hex of length " + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
      const n1 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n1 === void 0 || n2 === void 0) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array[ai] = n1 * 16 + n2;
    }
    return array;
  }
  var nextTick = async () => {
  };
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await nextTick();
      ts += diff;
    }
  }
  function utf8ToBytes(str) {
    if (typeof str !== "string")
      throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function kdfInputToBytes(data, errorTitle = "") {
    if (typeof data === "string")
      return utf8ToBytes(data);
    return abytes(data, void 0, errorTitle);
  }
  function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
      const a = arrays[i];
      abytes(a);
      sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
      const a = arrays[i];
      res.set(a, pad);
      pad += a.length;
    }
    return res;
  }
  function checkOpts(defaults, opts) {
    if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
      throw new Error("options must be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  }
  function createHasher(hashCons, info = {}) {
    const hashC = (msg, opts) => hashCons(opts).update(msg).digest();
    const tmp = hashCons(void 0);
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    Object.assign(hashC, info);
    return Object.freeze(hashC);
  }
  function randomBytes(bytesLength = 32) {
    const cr = typeof globalThis === "object" ? globalThis.crypto : null;
    if (typeof cr?.getRandomValues !== "function")
      throw new Error("crypto.getRandomValues must be defined");
    return cr.getRandomValues(new Uint8Array(bytesLength));
  }
  var oidNist = (suffix) => ({
    oid: Uint8Array.from([6, 9, 96, 134, 72, 1, 101, 3, 4, 2, suffix])
  });

  // ../../_u64.js
  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
  var _32n = /* @__PURE__ */ BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var shrSH = (h, _l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (_h, l) => l;
  var rotr32L = (h, _l) => h;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;

  // ../../_blake.js
  var BSIGMA = /* @__PURE__ */ Uint8Array.from([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    // Blake1, unused in others
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9
  ]);
  function G1s(a, b, c, d, x) {
    a = a + b + x | 0;
    d = rotr(d ^ a, 16);
    c = c + d | 0;
    b = rotr(b ^ c, 12);
    return { a, b, c, d };
  }
  function G2s(a, b, c, d, x) {
    a = a + b + x | 0;
    d = rotr(d ^ a, 8);
    c = c + d | 0;
    b = rotr(b ^ c, 7);
    return { a, b, c, d };
  }

  // ../../_md.js
  function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }
  function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  var HashMD = class {
    blockLen;
    outputLen;
    padOffset;
    isLE;
    // For partial updates less than block size
    buffer;
    view;
    finished = false;
    length = 0;
    pos = 0;
    destroyed = false;
    constructor(blockLen, outputLen, padOffset, isLE2) {
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE2;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      aexists(this);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE2 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      clean(this.buffer.subarray(pos));
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE2);
      this.process(view, 0);
      const oview = createView(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen must be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE2);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to ||= new this.constructor();
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA224_IV = /* @__PURE__ */ Uint32Array.from([
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ]);
  var SHA384_IV = /* @__PURE__ */ Uint32Array.from([
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ]);
  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ]);

  // ../../blake2.js
  var B2B_IV = /* @__PURE__ */ Uint32Array.from([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  var BBUF = /* @__PURE__ */ new Uint32Array(32);
  function G1b(a, b, c, d, msg, x) {
    const Xl = msg[x], Xh = msg[x + 1];
    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
    let ll = add3L(Al, Bl, Xl);
    Ah = add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
    ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
    BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
    BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
    BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
    BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
  }
  function G2b(a, b, c, d, msg, x) {
    const Xl = msg[x], Xh = msg[x + 1];
    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1];
    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1];
    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1];
    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1];
    let ll = add3L(Al, Bl, Xl);
    Ah = add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
    ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
    BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;
    BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;
    BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;
    BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;
  }
  function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
    anumber(keyLen);
    if (outputLen < 0 || outputLen > keyLen)
      throw new Error("outputLen bigger than keyLen");
    const { key, salt, personalization } = opts;
    if (key !== void 0 && (key.length < 1 || key.length > keyLen))
      throw new Error('"key" expected to be undefined or of length=1..' + keyLen);
    if (salt !== void 0)
      abytes(salt, saltLen, "salt");
    if (personalization !== void 0)
      abytes(personalization, persLen, "personalization");
  }
  var _BLAKE2 = class {
    buffer;
    buffer32;
    finished = false;
    destroyed = false;
    length = 0;
    pos = 0;
    blockLen;
    outputLen;
    constructor(blockLen, outputLen) {
      anumber(blockLen);
      anumber(outputLen);
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.buffer = new Uint8Array(blockLen);
      this.buffer32 = u32(this.buffer);
    }
    update(data) {
      aexists(this);
      abytes(data);
      const { blockLen, buffer, buffer32 } = this;
      const len = data.length;
      const offset = data.byteOffset;
      const buf = data.buffer;
      for (let pos = 0; pos < len; ) {
        if (this.pos === blockLen) {
          swap32IfBE(buffer32);
          this.compress(buffer32, 0, false);
          swap32IfBE(buffer32);
          this.pos = 0;
        }
        const take = Math.min(blockLen - this.pos, len - pos);
        const dataOffset = offset + pos;
        if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
          const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
          swap32IfBE(data32);
          for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
            this.length += blockLen;
            this.compress(data32, pos32, false);
          }
          swap32IfBE(data32);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        this.length += take;
        pos += take;
      }
      return this;
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      const { pos, buffer32 } = this;
      this.finished = true;
      clean(this.buffer.subarray(pos));
      swap32IfBE(buffer32);
      this.compress(buffer32, 0, true);
      swap32IfBE(buffer32);
      const out32 = u32(out);
      this.get().forEach((v, i) => out32[i] = swap8IfBE(v));
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      const { buffer, length, finished, destroyed, outputLen, pos } = this;
      to ||= new this.constructor({ dkLen: outputLen });
      to.set(...this.get());
      to.buffer.set(buffer);
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      to.outputLen = outputLen;
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var _BLAKE2b = class extends _BLAKE2 {
    // Same as SHA-512, but LE
    v0l = B2B_IV[0] | 0;
    v0h = B2B_IV[1] | 0;
    v1l = B2B_IV[2] | 0;
    v1h = B2B_IV[3] | 0;
    v2l = B2B_IV[4] | 0;
    v2h = B2B_IV[5] | 0;
    v3l = B2B_IV[6] | 0;
    v3h = B2B_IV[7] | 0;
    v4l = B2B_IV[8] | 0;
    v4h = B2B_IV[9] | 0;
    v5l = B2B_IV[10] | 0;
    v5h = B2B_IV[11] | 0;
    v6l = B2B_IV[12] | 0;
    v6h = B2B_IV[13] | 0;
    v7l = B2B_IV[14] | 0;
    v7h = B2B_IV[15] | 0;
    constructor(opts = {}) {
      const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
      super(128, olen);
      checkBlake2Opts(olen, opts, 64, 16, 16);
      let { key, personalization, salt } = opts;
      let keyLength = 0;
      if (key !== void 0) {
        abytes(key, void 0, "key");
        keyLength = key.length;
      }
      this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
      if (salt !== void 0) {
        abytes(salt, void 0, "salt");
        const slt = u32(salt);
        this.v4l ^= swap8IfBE(slt[0]);
        this.v4h ^= swap8IfBE(slt[1]);
        this.v5l ^= swap8IfBE(slt[2]);
        this.v5h ^= swap8IfBE(slt[3]);
      }
      if (personalization !== void 0) {
        abytes(personalization, void 0, "personalization");
        const pers = u32(personalization);
        this.v6l ^= swap8IfBE(pers[0]);
        this.v6h ^= swap8IfBE(pers[1]);
        this.v7l ^= swap8IfBE(pers[2]);
        this.v7h ^= swap8IfBE(pers[3]);
      }
      if (key !== void 0) {
        const tmp = new Uint8Array(this.blockLen);
        tmp.set(key);
        this.update(tmp);
      }
    }
    // prettier-ignore
    get() {
      let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
      return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
      this.v0l = v0l | 0;
      this.v0h = v0h | 0;
      this.v1l = v1l | 0;
      this.v1h = v1h | 0;
      this.v2l = v2l | 0;
      this.v2h = v2h | 0;
      this.v3l = v3l | 0;
      this.v3h = v3h | 0;
      this.v4l = v4l | 0;
      this.v4h = v4h | 0;
      this.v5l = v5l | 0;
      this.v5h = v5h | 0;
      this.v6l = v6l | 0;
      this.v6h = v6h | 0;
      this.v7l = v7l | 0;
      this.v7h = v7h | 0;
    }
    compress(msg, offset, isLast) {
      this.get().forEach((v, i) => BBUF[i] = v);
      BBUF.set(B2B_IV, 16);
      let { h, l } = fromBig(BigInt(this.length));
      BBUF[24] = B2B_IV[8] ^ l;
      BBUF[25] = B2B_IV[9] ^ h;
      if (isLast) {
        BBUF[28] = ~BBUF[28];
        BBUF[29] = ~BBUF[29];
      }
      let j = 0;
      const s = BSIGMA;
      for (let i = 0; i < 12; i++) {
        G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
        G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);
        G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
        G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);
        G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
        G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);
        G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
        G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);
        G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
        G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);
        G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
        G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);
        G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
        G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);
        G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
        G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);
      }
      this.v0l ^= BBUF[0] ^ BBUF[16];
      this.v0h ^= BBUF[1] ^ BBUF[17];
      this.v1l ^= BBUF[2] ^ BBUF[18];
      this.v1h ^= BBUF[3] ^ BBUF[19];
      this.v2l ^= BBUF[4] ^ BBUF[20];
      this.v2h ^= BBUF[5] ^ BBUF[21];
      this.v3l ^= BBUF[6] ^ BBUF[22];
      this.v3h ^= BBUF[7] ^ BBUF[23];
      this.v4l ^= BBUF[8] ^ BBUF[24];
      this.v4h ^= BBUF[9] ^ BBUF[25];
      this.v5l ^= BBUF[10] ^ BBUF[26];
      this.v5h ^= BBUF[11] ^ BBUF[27];
      this.v6l ^= BBUF[12] ^ BBUF[28];
      this.v6h ^= BBUF[13] ^ BBUF[29];
      this.v7l ^= BBUF[14] ^ BBUF[30];
      this.v7h ^= BBUF[15] ^ BBUF[31];
      clean(BBUF);
    }
    destroy() {
      this.destroyed = true;
      clean(this.buffer32);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var blake2b = /* @__PURE__ */ createHasher((opts) => new _BLAKE2b(opts));
  function compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
    let j = 0;
    for (let i = 0; i < rounds; i++) {
      ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s[j++]]));
      ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s[j++]]));
      ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s[j++]]));
      ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s[j++]]));
      ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s[j++]]));
      ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s[j++]]));
      ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s[j++]]));
      ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s[j++]]));
      ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s[j++]]));
      ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s[j++]]));
      ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s[j++]]));
      ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s[j++]]));
      ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s[j++]]));
      ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s[j++]]));
      ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s[j++]]));
      ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s[j++]]));
    }
    return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
  }
  var B2S_IV = /* @__PURE__ */ SHA256_IV.slice();
  var _BLAKE2s = class extends _BLAKE2 {
    // Internal state, same as SHA-256
    v0 = B2S_IV[0] | 0;
    v1 = B2S_IV[1] | 0;
    v2 = B2S_IV[2] | 0;
    v3 = B2S_IV[3] | 0;
    v4 = B2S_IV[4] | 0;
    v5 = B2S_IV[5] | 0;
    v6 = B2S_IV[6] | 0;
    v7 = B2S_IV[7] | 0;
    constructor(opts = {}) {
      const olen = opts.dkLen === void 0 ? 32 : opts.dkLen;
      super(64, olen);
      checkBlake2Opts(olen, opts, 32, 8, 8);
      let { key, personalization, salt } = opts;
      let keyLength = 0;
      if (key !== void 0) {
        abytes(key, void 0, "key");
        keyLength = key.length;
      }
      this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
      if (salt !== void 0) {
        abytes(salt, void 0, "salt");
        const slt = u32(salt);
        this.v4 ^= swap8IfBE(slt[0]);
        this.v5 ^= swap8IfBE(slt[1]);
      }
      if (personalization !== void 0) {
        abytes(personalization, void 0, "personalization");
        const pers = u32(personalization);
        this.v6 ^= swap8IfBE(pers[0]);
        this.v7 ^= swap8IfBE(pers[1]);
      }
      if (key !== void 0) {
        const tmp = new Uint8Array(this.blockLen);
        tmp.set(key);
        this.update(tmp);
      }
    }
    get() {
      const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
      return [v0, v1, v2, v3, v4, v5, v6, v7];
    }
    // prettier-ignore
    set(v0, v1, v2, v3, v4, v5, v6, v7) {
      this.v0 = v0 | 0;
      this.v1 = v1 | 0;
      this.v2 = v2 | 0;
      this.v3 = v3 | 0;
      this.v4 = v4 | 0;
      this.v5 = v5 | 0;
      this.v6 = v6 | 0;
      this.v7 = v7 | 0;
    }
    compress(msg, offset, isLast) {
      const { h, l } = fromBig(BigInt(this.length));
      const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
      this.v0 ^= v0 ^ v8;
      this.v1 ^= v1 ^ v9;
      this.v2 ^= v2 ^ v10;
      this.v3 ^= v3 ^ v11;
      this.v4 ^= v4 ^ v12;
      this.v5 ^= v5 ^ v13;
      this.v6 ^= v6 ^ v14;
      this.v7 ^= v7 ^ v15;
    }
    destroy() {
      this.destroyed = true;
      clean(this.buffer32);
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var blake2s = /* @__PURE__ */ createHasher((opts) => new _BLAKE2s(opts));

  // ../../argon2.js
  var AT = { Argond2d: 0, Argon2i: 1, Argon2id: 2 };
  var ARGON2_SYNC_POINTS = 4;
  var abytesOrZero = (buf, errorTitle = "") => {
    if (buf === void 0)
      return Uint8Array.of();
    return kdfInputToBytes(buf, errorTitle);
  };
  function mul(a, b) {
    const aL = a & 65535;
    const aH = a >>> 16;
    const bL = b & 65535;
    const bH = b >>> 16;
    const ll = Math.imul(aL, bL);
    const hl = Math.imul(aH, bL);
    const lh = Math.imul(aL, bH);
    const hh = Math.imul(aH, bH);
    const carry = (ll >>> 16) + (hl & 65535) + lh;
    const high = hh + (hl >>> 16) + (carry >>> 16) | 0;
    const low = carry << 16 | ll & 65535;
    return { h: high, l: low };
  }
  function mul2(a, b) {
    const { h, l } = mul(a, b);
    return { h: (h << 1 | l >>> 31) & 4294967295, l: l << 1 & 4294967295 };
  }
  function blamka(Ah, Al, Bh, Bl) {
    const { h: Ch, l: Cl } = mul2(Al, Bl);
    const Rll = add3L(Al, Bl, Cl);
    return { h: add3H(Rll, Ah, Bh, Ch), l: Rll | 0 };
  }
  var A2_BUF = new Uint32Array(256);
  function G(a, b, c, d) {
    let Al = A2_BUF[2 * a], Ah = A2_BUF[2 * a + 1];
    let Bl = A2_BUF[2 * b], Bh = A2_BUF[2 * b + 1];
    let Cl = A2_BUF[2 * c], Ch = A2_BUF[2 * c + 1];
    let Dl = A2_BUF[2 * d], Dh = A2_BUF[2 * d + 1];
    ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
    ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 24), Bl: rotrSL(Bh, Bl, 24) });
    ({ h: Ah, l: Al } = blamka(Ah, Al, Bh, Bl));
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
    ({ h: Ch, l: Cl } = blamka(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: rotrBH(Bh, Bl, 63), Bl: rotrBL(Bh, Bl, 63) });
    A2_BUF[2 * a] = Al, A2_BUF[2 * a + 1] = Ah;
    A2_BUF[2 * b] = Bl, A2_BUF[2 * b + 1] = Bh;
    A2_BUF[2 * c] = Cl, A2_BUF[2 * c + 1] = Ch;
    A2_BUF[2 * d] = Dl, A2_BUF[2 * d + 1] = Dh;
  }
  function P(v00, v01, v02, v03, v04, v05, v06, v07, v08, v09, v10, v11, v12, v13, v14, v15) {
    G(v00, v04, v08, v12);
    G(v01, v05, v09, v13);
    G(v02, v06, v10, v14);
    G(v03, v07, v11, v15);
    G(v00, v05, v10, v15);
    G(v01, v06, v11, v12);
    G(v02, v07, v08, v13);
    G(v03, v04, v09, v14);
  }
  function block(x, xPos, yPos, outPos, needXor) {
    for (let i = 0; i < 256; i++)
      A2_BUF[i] = x[xPos + i] ^ x[yPos + i];
    for (let i = 0; i < 128; i += 16) {
      P(i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8, i + 9, i + 10, i + 11, i + 12, i + 13, i + 14, i + 15);
    }
    for (let i = 0; i < 16; i += 2) {
      P(i, i + 1, i + 16, i + 17, i + 32, i + 33, i + 48, i + 49, i + 64, i + 65, i + 80, i + 81, i + 96, i + 97, i + 112, i + 113);
    }
    if (needXor)
      for (let i = 0; i < 256; i++)
        x[outPos + i] ^= A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];
    else
      for (let i = 0; i < 256; i++)
        x[outPos + i] = A2_BUF[i] ^ x[xPos + i] ^ x[yPos + i];
    clean(A2_BUF);
  }
  function Hp(A, dkLen) {
    const A8 = u8(A);
    const T = new Uint32Array(1);
    const T8 = u8(T);
    T[0] = dkLen;
    if (dkLen <= 64)
      return blake2b.create({ dkLen }).update(T8).update(A8).digest();
    const out = new Uint8Array(dkLen);
    let V = blake2b.create({}).update(T8).update(A8).digest();
    let pos = 0;
    out.set(V.subarray(0, 32));
    pos += 32;
    for (; dkLen - pos > 64; pos += 32) {
      const Vh = blake2b.create({}).update(V);
      Vh.digestInto(V);
      Vh.destroy();
      out.set(V.subarray(0, 32), pos);
    }
    out.set(blake2b(V, { dkLen: dkLen - pos }), pos);
    clean(V, T);
    return u32(out);
  }
  function indexAlpha(r, s, laneLen, segmentLen, index, randL, sameLane = false) {
    let area;
    if (r === 0) {
      if (s === 0)
        area = index - 1;
      else if (sameLane)
        area = s * segmentLen + index - 1;
      else
        area = s * segmentLen + (index == 0 ? -1 : 0);
    } else if (sameLane)
      area = laneLen - segmentLen + index - 1;
    else
      area = laneLen - segmentLen + (index == 0 ? -1 : 0);
    const startPos = r !== 0 && s !== ARGON2_SYNC_POINTS - 1 ? (s + 1) * segmentLen : 0;
    const rel = area - 1 - mul(area, mul(randL, randL).h).h;
    return (startPos + rel) % laneLen;
  }
  var maxUint32 = Math.pow(2, 32);
  function isU32(num) {
    return Number.isSafeInteger(num) && num >= 0 && num < maxUint32;
  }
  function argon2Opts(opts) {
    const merged = {
      version: 19,
      dkLen: 32,
      maxmem: maxUint32 - 1,
      asyncTick: 10
    };
    for (let [k, v] of Object.entries(opts))
      if (v !== void 0)
        merged[k] = v;
    const { dkLen, p, m, t, version, onProgress, asyncTick } = merged;
    if (!isU32(dkLen) || dkLen < 4)
      throw new Error('"dkLen" must be 4..');
    if (!isU32(p) || p < 1 || p >= Math.pow(2, 24))
      throw new Error('"p" must be 1..2^24');
    if (!isU32(m))
      throw new Error('"m" must be 0..2^32');
    if (!isU32(t) || t < 1)
      throw new Error('"t" (iterations) must be 1..2^32');
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error('"progressCb" must be a function');
    anumber(asyncTick, "asyncTick");
    if (!isU32(m) || m < 8 * p)
      throw new Error('"m" (memory) must be at least 8*p bytes');
    if (version !== 16 && version !== 19)
      throw new Error('"version" must be 0x10 or 0x13, got ' + version);
    return merged;
  }
  function argon2Init(password, salt, type, opts) {
    password = kdfInputToBytes(password, "password");
    salt = kdfInputToBytes(salt, "salt");
    if (!isU32(password.length))
      throw new Error('"password" must be less of length 1..4Gb');
    if (!isU32(salt.length) || salt.length < 8)
      throw new Error('"salt" must be of length 8..4Gb');
    if (!Object.values(AT).includes(type))
      throw new Error('"type" was invalid');
    let { p, dkLen, m, t, version, key, personalization, maxmem, onProgress, asyncTick } = argon2Opts(opts);
    key = abytesOrZero(key, "key");
    personalization = abytesOrZero(personalization, "personalization");
    const h = blake2b.create();
    const BUF = new Uint32Array(1);
    const BUF8 = u8(BUF);
    for (let item of [p, dkLen, m, t, version, type]) {
      BUF[0] = item;
      h.update(BUF8);
    }
    for (let i of [password, salt, key, personalization]) {
      BUF[0] = i.length;
      h.update(BUF8).update(i);
    }
    const H0 = new Uint32Array(18);
    const H0_8 = u8(H0);
    h.digestInto(H0_8);
    const lanes = p;
    const mP = 4 * p * Math.floor(m / (ARGON2_SYNC_POINTS * p));
    const laneLen = Math.floor(mP / p);
    const segmentLen = Math.floor(laneLen / ARGON2_SYNC_POINTS);
    const memUsed = mP * 256;
    if (!isU32(maxmem) || memUsed > maxmem)
      throw new Error('"maxmem" expected <2**32, got: maxmem=' + maxmem + ", memused=" + memUsed);
    const B = new Uint32Array(memUsed);
    for (let l = 0; l < p; l++) {
      const i = 256 * laneLen * l;
      H0[17] = l;
      H0[16] = 0;
      B.set(Hp(H0, 1024), i);
      H0[16] = 1;
      B.set(Hp(H0, 1024), i + 256);
    }
    let perBlock = () => {
    };
    if (onProgress) {
      const totalBlock = t * ARGON2_SYNC_POINTS * p * segmentLen;
      const callbackPer = Math.max(Math.floor(totalBlock / 1e4), 1);
      let blockCnt = 0;
      perBlock = () => {
        blockCnt++;
        if (onProgress && (!(blockCnt % callbackPer) || blockCnt === totalBlock))
          onProgress(blockCnt / totalBlock);
      };
    }
    clean(BUF, H0);
    return { type, mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock, asyncTick };
  }
  function argon2Output(B, p, laneLen, dkLen) {
    const B_final = new Uint32Array(256);
    for (let l = 0; l < p; l++)
      for (let j = 0; j < 256; j++)
        B_final[j] ^= B[256 * (laneLen * l + laneLen - 1) + j];
    const res = u8(Hp(B_final, dkLen));
    clean(B_final);
    return res;
  }
  function processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor) {
    if (offset % laneLen)
      prev = offset - 1;
    let randL, randH;
    if (dataIndependent) {
      let i128 = index % 128;
      if (i128 === 0) {
        address[256 + 12]++;
        block(address, 256, 2 * 256, 0, false);
        block(address, 0, 2 * 256, 0, false);
      }
      randL = address[2 * i128];
      randH = address[2 * i128 + 1];
    } else {
      const T = 256 * prev;
      randL = B[T];
      randH = B[T + 1];
    }
    const refLane = r === 0 && s === 0 ? l : randH % lanes;
    const refPos = indexAlpha(r, s, laneLen, segmentLen, index, randL, refLane == l);
    const refBlock = laneLen * refLane + refPos;
    block(B, 256 * prev, 256 * refBlock, offset * 256, needXor);
  }
  function argon2(type, password, salt, opts) {
    const { mP, p, t, version, B, laneLen, lanes, segmentLen, dkLen, perBlock } = argon2Init(password, salt, type, opts);
    const address = new Uint32Array(3 * 256);
    address[256 + 6] = mP;
    address[256 + 8] = t;
    address[256 + 10] = type;
    for (let r = 0; r < t; r++) {
      const needXor = r !== 0 && version === 19;
      address[256 + 0] = r;
      for (let s = 0; s < ARGON2_SYNC_POINTS; s++) {
        address[256 + 4] = s;
        const dataIndependent = type == AT.Argon2i || type == AT.Argon2id && r === 0 && s < 2;
        for (let l = 0; l < p; l++) {
          address[256 + 2] = l;
          address[256 + 12] = 0;
          let startPos = 0;
          if (r === 0 && s === 0) {
            startPos = 2;
            if (dataIndependent) {
              address[256 + 12]++;
              block(address, 256, 2 * 256, 0, false);
              block(address, 0, 2 * 256, 0, false);
            }
          }
          let offset = l * laneLen + s * segmentLen + startPos;
          let prev = offset % laneLen ? offset - 1 : offset + laneLen - 1;
          for (let index = startPos; index < segmentLen; index++, offset++, prev++) {
            perBlock();
            processBlock(B, address, l, r, s, index, laneLen, segmentLen, lanes, offset, prev, dataIndependent, needXor);
          }
        }
      }
    }
    clean(address);
    return argon2Output(B, p, laneLen, dkLen);
  }
  var argon2id = (password, salt, opts) => argon2(AT.Argon2id, password, salt, opts);

  // ../../blake1.js
  var EMPTY_SALT = /* @__PURE__ */ new Uint32Array(8);
  var BLAKE1 = class {
    finished = false;
    length = 0;
    pos = 0;
    destroyed = false;
    // For partial updates less than block size
    buffer;
    view;
    salt;
    blockLen;
    outputLen;
    lengthFlag;
    counterLen;
    constants;
    constructor(blockLen, outputLen, lengthFlag, counterLen, saltLen, constants, opts = {}) {
      const { salt } = opts;
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.lengthFlag = lengthFlag;
      this.counterLen = counterLen;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
      if (salt !== void 0) {
        let slt = salt;
        abytes(slt, 4 * saltLen, "salt");
        const salt32 = this.salt = new Uint32Array(saltLen);
        const sv = createView(slt);
        this.constants = constants.slice();
        for (let i = 0, offset = 0; i < salt32.length; i++, offset += 4) {
          salt32[i] = sv.getUint32(offset, false);
          this.constants[i] ^= salt32[i];
        }
      } else {
        this.salt = EMPTY_SALT;
        this.constants = constants;
      }
    }
    update(data) {
      aexists(this);
      abytes(data);
      const { view, buffer, blockLen } = this;
      const len = data.length;
      let dataView;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          if (!dataView)
            dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen) {
            this.length += blockLen;
            this.compress(dataView, pos);
          }
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.length += blockLen;
          this.compress(view, 0, true);
          this.pos = 0;
        }
      }
      return this;
    }
    destroy() {
      this.destroyed = true;
      if (this.salt !== EMPTY_SALT) {
        clean(this.salt, this.constants);
      }
    }
    _cloneInto(to) {
      to ||= new this.constructor();
      to.set(...this.get());
      const { buffer, length, finished, destroyed, constants, salt, pos } = this;
      to.buffer.set(buffer);
      to.constants = constants.slice();
      to.destroyed = destroyed;
      to.finished = finished;
      to.length = length;
      to.pos = pos;
      to.salt = salt.slice();
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    digestInto(out) {
      aexists(this);
      aoutput(out, this);
      this.finished = true;
      const { buffer, blockLen, counterLen, lengthFlag, view } = this;
      clean(buffer.subarray(this.pos));
      const counter = BigInt((this.length + this.pos) * 8);
      const counterPos = blockLen - counterLen - 1;
      buffer[this.pos] |= 128;
      this.length += this.pos;
      if (this.pos > counterPos) {
        this.compress(view, 0);
        clean(buffer);
        this.pos = 0;
      }
      buffer[counterPos] |= lengthFlag;
      view.setBigUint64(blockLen - 8, counter, false);
      this.compress(view, 0, this.pos !== 0);
      clean(buffer);
      const v = createView(out);
      const state = this.get();
      for (let i = 0; i < this.outputLen / 4; ++i)
        v.setUint32(i * 4, state[i]);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  };
  var B64C = /* @__PURE__ */ Uint32Array.from([
    608135816,
    2242054355,
    320440878,
    57701188,
    2752067618,
    698298832,
    137296536,
    3964562569,
    1160258022,
    953160567,
    3193202383,
    887688300,
    3232508343,
    3380367581,
    1065670069,
    3041331479,
    2450970073,
    2306472731,
    3509652390,
    2564797868,
    805139163,
    3491422135,
    3101798381,
    1780907670,
    3128725573,
    4046225305,
    614570311,
    3012652279,
    134345442,
    2240740374,
    1667834072,
    1901547113
  ]);
  var B32C = B64C.slice(0, 16);
  var B256_IV = /* @__PURE__ */ SHA256_IV.slice();
  var B224_IV = /* @__PURE__ */ SHA224_IV.slice();
  var B384_IV = /* @__PURE__ */ SHA384_IV.slice();
  var B512_IV = /* @__PURE__ */ SHA512_IV.slice();
  function generateTBL256() {
    const TBL = [];
    for (let i = 0, j = 0; i < 14; i++, j += 16) {
      for (let offset = 1; offset < 16; offset += 2) {
        TBL.push(B32C[BSIGMA[j + offset]]);
        TBL.push(B32C[BSIGMA[j + offset - 1]]);
      }
    }
    return new Uint32Array(TBL);
  }
  var TBL256 = /* @__PURE__ */ generateTBL256();
  var BLAKE256_W = /* @__PURE__ */ new Uint32Array(16);
  var BLAKE1_32B = class extends BLAKE1 {
    v0;
    v1;
    v2;
    v3;
    v4;
    v5;
    v6;
    v7;
    constructor(outputLen, IV, lengthFlag, opts = {}) {
      super(64, outputLen, lengthFlag, 8, 4, B32C, opts);
      this.v0 = IV[0] | 0;
      this.v1 = IV[1] | 0;
      this.v2 = IV[2] | 0;
      this.v3 = IV[3] | 0;
      this.v4 = IV[4] | 0;
      this.v5 = IV[5] | 0;
      this.v6 = IV[6] | 0;
      this.v7 = IV[7] | 0;
    }
    get() {
      const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
      return [v0, v1, v2, v3, v4, v5, v6, v7];
    }
    // prettier-ignore
    set(v0, v1, v2, v3, v4, v5, v6, v7) {
      this.v0 = v0 | 0;
      this.v1 = v1 | 0;
      this.v2 = v2 | 0;
      this.v3 = v3 | 0;
      this.v4 = v4 | 0;
      this.v5 = v5 | 0;
      this.v6 = v6 | 0;
      this.v7 = v7 | 0;
    }
    destroy() {
      super.destroy();
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
    }
    compress(view, offset, withLength = true) {
      for (let i = 0; i < 16; i++, offset += 4)
        BLAKE256_W[i] = view.getUint32(offset, false);
      let v00 = this.v0 | 0;
      let v01 = this.v1 | 0;
      let v02 = this.v2 | 0;
      let v03 = this.v3 | 0;
      let v04 = this.v4 | 0;
      let v05 = this.v5 | 0;
      let v06 = this.v6 | 0;
      let v07 = this.v7 | 0;
      let v08 = this.constants[0] | 0;
      let v09 = this.constants[1] | 0;
      let v10 = this.constants[2] | 0;
      let v11 = this.constants[3] | 0;
      const { h, l } = fromBig(BigInt(withLength ? this.length * 8 : 0));
      let v12 = (this.constants[4] ^ l) >>> 0;
      let v13 = (this.constants[5] ^ l) >>> 0;
      let v14 = (this.constants[6] ^ h) >>> 0;
      let v15 = (this.constants[7] ^ h) >>> 0;
      for (let i = 0, k = 0, j = 0; i < 14; i++) {
        ({ a: v00, b: v04, c: v08, d: v12 } = G1s(v00, v04, v08, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v00, b: v04, c: v08, d: v12 } = G2s(v00, v04, v08, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v01, b: v05, c: v09, d: v13 } = G1s(v01, v05, v09, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v01, b: v05, c: v09, d: v13 } = G2s(v01, v05, v09, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v02, b: v06, c: v10, d: v14 } = G1s(v02, v06, v10, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v02, b: v06, c: v10, d: v14 } = G2s(v02, v06, v10, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v03, b: v07, c: v11, d: v15 } = G1s(v03, v07, v11, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v03, b: v07, c: v11, d: v15 } = G2s(v03, v07, v11, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v00, b: v05, c: v10, d: v15 } = G1s(v00, v05, v10, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v00, b: v05, c: v10, d: v15 } = G2s(v00, v05, v10, v15, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v01, b: v06, c: v11, d: v12 } = G1s(v01, v06, v11, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v01, b: v06, c: v11, d: v12 } = G2s(v01, v06, v11, v12, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v02, b: v07, c: v08, d: v13 } = G1s(v02, v07, v08, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v02, b: v07, c: v08, d: v13 } = G2s(v02, v07, v08, v13, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v03, b: v04, c: v09, d: v14 } = G1s(v03, v04, v09, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
        ({ a: v03, b: v04, c: v09, d: v14 } = G2s(v03, v04, v09, v14, BLAKE256_W[BSIGMA[k++]] ^ TBL256[j++]));
      }
      this.v0 = (this.v0 ^ v00 ^ v08 ^ this.salt[0]) >>> 0;
      this.v1 = (this.v1 ^ v01 ^ v09 ^ this.salt[1]) >>> 0;
      this.v2 = (this.v2 ^ v02 ^ v10 ^ this.salt[2]) >>> 0;
      this.v3 = (this.v3 ^ v03 ^ v11 ^ this.salt[3]) >>> 0;
      this.v4 = (this.v4 ^ v04 ^ v12 ^ this.salt[0]) >>> 0;
      this.v5 = (this.v5 ^ v05 ^ v13 ^ this.salt[1]) >>> 0;
      this.v6 = (this.v6 ^ v06 ^ v14 ^ this.salt[2]) >>> 0;
      this.v7 = (this.v7 ^ v07 ^ v15 ^ this.salt[3]) >>> 0;
      clean(BLAKE256_W);
    }
  };
  var BBUF2 = /* @__PURE__ */ new Uint32Array(32);
  var BLAKE512_W = /* @__PURE__ */ new Uint32Array(32);
  function generateTBL512() {
    const TBL = [];
    for (let r = 0, k = 0; r < 16; r++, k += 16) {
      for (let offset = 1; offset < 16; offset += 2) {
        TBL.push(B64C[BSIGMA[k + offset] * 2 + 0]);
        TBL.push(B64C[BSIGMA[k + offset] * 2 + 1]);
        TBL.push(B64C[BSIGMA[k + offset - 1] * 2 + 0]);
        TBL.push(B64C[BSIGMA[k + offset - 1] * 2 + 1]);
      }
    }
    return new Uint32Array(TBL);
  }
  var TBL512 = /* @__PURE__ */ generateTBL512();
  function G1b2(a, b, c, d, msg, k) {
    const Xpos = 2 * BSIGMA[k];
    const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2];
    let Al = BBUF2[2 * a + 1], Ah = BBUF2[2 * a];
    let Bl = BBUF2[2 * b + 1], Bh = BBUF2[2 * b];
    let Cl = BBUF2[2 * c + 1], Ch = BBUF2[2 * c];
    let Dl = BBUF2[2 * d + 1], Dh = BBUF2[2 * d];
    let ll = add3L(Al, Bl, Xl);
    Ah = add3H(ll, Ah, Bh, Xh) >>> 0;
    Al = (ll | 0) >>> 0;
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: rotr32H(Dh, Dl), Dl: rotr32L(Dh, Dl) });
    ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 25), Bl: rotrSL(Bh, Bl, 25) });
    BBUF2[2 * a + 1] = Al, BBUF2[2 * a] = Ah;
    BBUF2[2 * b + 1] = Bl, BBUF2[2 * b] = Bh;
    BBUF2[2 * c + 1] = Cl, BBUF2[2 * c] = Ch;
    BBUF2[2 * d + 1] = Dl, BBUF2[2 * d] = Dh;
  }
  function G2b2(a, b, c, d, msg, k) {
    const Xpos = 2 * BSIGMA[k];
    const Xl = msg[Xpos + 1] ^ TBL512[k * 2 + 1], Xh = msg[Xpos] ^ TBL512[k * 2];
    let Al = BBUF2[2 * a + 1], Ah = BBUF2[2 * a];
    let Bl = BBUF2[2 * b + 1], Bh = BBUF2[2 * b];
    let Cl = BBUF2[2 * c + 1], Ch = BBUF2[2 * c];
    let Dl = BBUF2[2 * d + 1], Dh = BBUF2[2 * d];
    let ll = add3L(Al, Bl, Xl);
    Ah = add3H(ll, Ah, Bh, Xh);
    Al = ll | 0;
    ({ Dh, Dl } = { Dh: Dh ^ Ah, Dl: Dl ^ Al });
    ({ Dh, Dl } = { Dh: rotrSH(Dh, Dl, 16), Dl: rotrSL(Dh, Dl, 16) });
    ({ h: Ch, l: Cl } = add(Ch, Cl, Dh, Dl));
    ({ Bh, Bl } = { Bh: Bh ^ Ch, Bl: Bl ^ Cl });
    ({ Bh, Bl } = { Bh: rotrSH(Bh, Bl, 11), Bl: rotrSL(Bh, Bl, 11) });
    BBUF2[2 * a + 1] = Al, BBUF2[2 * a] = Ah;
    BBUF2[2 * b + 1] = Bl, BBUF2[2 * b] = Bh;
    BBUF2[2 * c + 1] = Cl, BBUF2[2 * c] = Ch;
    BBUF2[2 * d + 1] = Dl, BBUF2[2 * d] = Dh;
  }
  var BLAKE1_64B = class extends BLAKE1 {
    v0l;
    v0h;
    v1l;
    v1h;
    v2l;
    v2h;
    v3l;
    v3h;
    v4l;
    v4h;
    v5l;
    v5h;
    v6l;
    v6h;
    v7l;
    v7h;
    constructor(outputLen, IV, lengthFlag, opts = {}) {
      super(128, outputLen, lengthFlag, 16, 8, B64C, opts);
      this.v0l = IV[0] | 0;
      this.v0h = IV[1] | 0;
      this.v1l = IV[2] | 0;
      this.v1h = IV[3] | 0;
      this.v2l = IV[4] | 0;
      this.v2h = IV[5] | 0;
      this.v3l = IV[6] | 0;
      this.v3h = IV[7] | 0;
      this.v4l = IV[8] | 0;
      this.v4h = IV[9] | 0;
      this.v5l = IV[10] | 0;
      this.v5h = IV[11] | 0;
      this.v6l = IV[12] | 0;
      this.v6h = IV[13] | 0;
      this.v7l = IV[14] | 0;
      this.v7h = IV[15] | 0;
    }
    // prettier-ignore
    get() {
      let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
      return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
    }
    // prettier-ignore
    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
      this.v0l = v0l | 0;
      this.v0h = v0h | 0;
      this.v1l = v1l | 0;
      this.v1h = v1h | 0;
      this.v2l = v2l | 0;
      this.v2h = v2h | 0;
      this.v3l = v3l | 0;
      this.v3h = v3h | 0;
      this.v4l = v4l | 0;
      this.v4h = v4h | 0;
      this.v5l = v5l | 0;
      this.v5h = v5h | 0;
      this.v6l = v6l | 0;
      this.v6h = v6h | 0;
      this.v7l = v7l | 0;
      this.v7h = v7h | 0;
    }
    destroy() {
      super.destroy();
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
    compress(view, offset, withLength = true) {
      for (let i = 0; i < 32; i++, offset += 4)
        BLAKE512_W[i] = view.getUint32(offset, false);
      this.get().forEach((v, i) => BBUF2[i] = v);
      BBUF2.set(this.constants.subarray(0, 16), 16);
      if (withLength) {
        const { h, l } = fromBig(BigInt(this.length * 8));
        BBUF2[24] = (BBUF2[24] ^ h) >>> 0;
        BBUF2[25] = (BBUF2[25] ^ l) >>> 0;
        BBUF2[26] = (BBUF2[26] ^ h) >>> 0;
        BBUF2[27] = (BBUF2[27] ^ l) >>> 0;
      }
      for (let i = 0, k = 0; i < 16; i++) {
        G1b2(0, 4, 8, 12, BLAKE512_W, k++);
        G2b2(0, 4, 8, 12, BLAKE512_W, k++);
        G1b2(1, 5, 9, 13, BLAKE512_W, k++);
        G2b2(1, 5, 9, 13, BLAKE512_W, k++);
        G1b2(2, 6, 10, 14, BLAKE512_W, k++);
        G2b2(2, 6, 10, 14, BLAKE512_W, k++);
        G1b2(3, 7, 11, 15, BLAKE512_W, k++);
        G2b2(3, 7, 11, 15, BLAKE512_W, k++);
        G1b2(0, 5, 10, 15, BLAKE512_W, k++);
        G2b2(0, 5, 10, 15, BLAKE512_W, k++);
        G1b2(1, 6, 11, 12, BLAKE512_W, k++);
        G2b2(1, 6, 11, 12, BLAKE512_W, k++);
        G1b2(2, 7, 8, 13, BLAKE512_W, k++);
        G2b2(2, 7, 8, 13, BLAKE512_W, k++);
        G1b2(3, 4, 9, 14, BLAKE512_W, k++);
        G2b2(3, 4, 9, 14, BLAKE512_W, k++);
      }
      this.v0l ^= BBUF2[0] ^ BBUF2[16] ^ this.salt[0];
      this.v0h ^= BBUF2[1] ^ BBUF2[17] ^ this.salt[1];
      this.v1l ^= BBUF2[2] ^ BBUF2[18] ^ this.salt[2];
      this.v1h ^= BBUF2[3] ^ BBUF2[19] ^ this.salt[3];
      this.v2l ^= BBUF2[4] ^ BBUF2[20] ^ this.salt[4];
      this.v2h ^= BBUF2[5] ^ BBUF2[21] ^ this.salt[5];
      this.v3l ^= BBUF2[6] ^ BBUF2[22] ^ this.salt[6];
      this.v3h ^= BBUF2[7] ^ BBUF2[23] ^ this.salt[7];
      this.v4l ^= BBUF2[8] ^ BBUF2[24] ^ this.salt[0];
      this.v4h ^= BBUF2[9] ^ BBUF2[25] ^ this.salt[1];
      this.v5l ^= BBUF2[10] ^ BBUF2[26] ^ this.salt[2];
      this.v5h ^= BBUF2[11] ^ BBUF2[27] ^ this.salt[3];
      this.v6l ^= BBUF2[12] ^ BBUF2[28] ^ this.salt[4];
      this.v6h ^= BBUF2[13] ^ BBUF2[29] ^ this.salt[5];
      this.v7l ^= BBUF2[14] ^ BBUF2[30] ^ this.salt[6];
      this.v7h ^= BBUF2[15] ^ BBUF2[31] ^ this.salt[7];
      clean(BBUF2, BLAKE512_W);
    }
  };
  var _BLAKE224 = class extends BLAKE1_32B {
    constructor(opts = {}) {
      super(28, B224_IV, 0, opts);
    }
  };
  var _BLAKE256 = class extends BLAKE1_32B {
    constructor(opts = {}) {
      super(32, B256_IV, 1, opts);
    }
  };
  var _BLAKE384 = class extends BLAKE1_64B {
    constructor(opts = {}) {
      super(48, B384_IV, 0, opts);
    }
  };
  var _BLAKE512 = class extends BLAKE1_64B {
    constructor(opts = {}) {
      super(64, B512_IV, 1, opts);
    }
  };
  var blake224 = /* @__PURE__ */ createHasher((opts) => new _BLAKE224(opts));
  var blake256 = /* @__PURE__ */ createHasher((opts) => new _BLAKE256(opts));
  var blake384 = /* @__PURE__ */ createHasher((opts) => new _BLAKE384(opts));
  var blake512 = /* @__PURE__ */ createHasher((opts) => new _BLAKE512(opts));

  // ../../blake3.js
  var B3_Flags = {
    CHUNK_START: 1,
    CHUNK_END: 2,
    PARENT: 4,
    ROOT: 8,
    KEYED_HASH: 16,
    DERIVE_KEY_CONTEXT: 32,
    DERIVE_KEY_MATERIAL: 64
  };
  var B3_IV = /* @__PURE__ */ SHA256_IV.slice();
  var B3_SIGMA = /* @__PURE__ */ (() => {
    const Id = Array.from({ length: 16 }, (_, i) => i);
    const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);
    const res = [];
    for (let i = 0, v = Id; i < 7; i++, v = permute(v))
      res.push(...v);
    return Uint8Array.from(res);
  })();
  var _BLAKE3 = class __BLAKE3 extends _BLAKE2 {
    chunkPos = 0;
    // Position of current block in chunk
    chunksDone = 0;
    // How many chunks we already have
    flags = 0 | 0;
    IV;
    state;
    stack = [];
    // Output
    posOut = 0;
    bufferOut32 = new Uint32Array(16);
    bufferOut;
    chunkOut = 0;
    // index of output chunk
    enableXOF = true;
    constructor(opts = {}, flags = 0) {
      super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
      const { key, context } = opts;
      const hasContext = context !== void 0;
      if (key !== void 0) {
        if (hasContext)
          throw new Error('Only "key" or "context" can be specified at same time');
        abytes(key, 32, "key");
        const k = key.slice();
        this.IV = u32(k);
        swap32IfBE(this.IV);
        this.flags = flags | B3_Flags.KEYED_HASH;
      } else if (hasContext) {
        abytes(context, void 0, "context");
        const ctx = context;
        const contextKey = new __BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
        this.IV = u32(contextKey);
        swap32IfBE(this.IV);
        this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
      } else {
        this.IV = B3_IV.slice();
        this.flags = flags;
      }
      this.state = this.IV.slice();
      this.bufferOut = u8(this.bufferOut32);
    }
    // Unused
    get() {
      return [];
    }
    set() {
    }
    b2Compress(counter, flags, buf, bufPos = 0) {
      const { state: s, pos } = this;
      const { h, l } = fromBig(BigInt(counter), true);
      const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(B3_SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l, pos, flags);
      s[0] = v0 ^ v8;
      s[1] = v1 ^ v9;
      s[2] = v2 ^ v10;
      s[3] = v3 ^ v11;
      s[4] = v4 ^ v12;
      s[5] = v5 ^ v13;
      s[6] = v6 ^ v14;
      s[7] = v7 ^ v15;
    }
    compress(buf, bufPos = 0, isLast = false) {
      let flags = this.flags;
      if (!this.chunkPos)
        flags |= B3_Flags.CHUNK_START;
      if (this.chunkPos === 15 || isLast)
        flags |= B3_Flags.CHUNK_END;
      if (!isLast)
        this.pos = this.blockLen;
      this.b2Compress(this.chunksDone, flags, buf, bufPos);
      this.chunkPos += 1;
      if (this.chunkPos === 16 || isLast) {
        let chunk = this.state;
        this.state = this.IV.slice();
        for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
          if (!(last = this.stack.pop()))
            break;
          this.buffer32.set(last, 0);
          this.buffer32.set(chunk, 8);
          this.pos = this.blockLen;
          this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
          chunk = this.state;
          this.state = this.IV.slice();
        }
        this.chunksDone++;
        this.chunkPos = 0;
        this.stack.push(chunk);
      }
      this.pos = 0;
    }
    _cloneInto(to) {
      to = super._cloneInto(to);
      const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
      to.state.set(state.slice());
      to.stack = stack.map((i) => Uint32Array.from(i));
      to.IV.set(IV);
      to.flags = flags;
      to.chunkPos = chunkPos;
      to.chunksDone = chunksDone;
      to.posOut = posOut;
      to.chunkOut = chunkOut;
      to.enableXOF = this.enableXOF;
      to.bufferOut32.set(this.bufferOut32);
      return to;
    }
    destroy() {
      this.destroyed = true;
      clean(this.state, this.buffer32, this.IV, this.bufferOut32);
      clean(...this.stack);
    }
    // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
    b2CompressOut() {
      const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;
      const { h, l } = fromBig(BigInt(this.chunkOut++));
      swap32IfBE(buffer32);
      const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(B3_SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l, h, pos, flags);
      out32[0] = v0 ^ v8;
      out32[1] = v1 ^ v9;
      out32[2] = v2 ^ v10;
      out32[3] = v3 ^ v11;
      out32[4] = v4 ^ v12;
      out32[5] = v5 ^ v13;
      out32[6] = v6 ^ v14;
      out32[7] = v7 ^ v15;
      out32[8] = s[0] ^ v8;
      out32[9] = s[1] ^ v9;
      out32[10] = s[2] ^ v10;
      out32[11] = s[3] ^ v11;
      out32[12] = s[4] ^ v12;
      out32[13] = s[5] ^ v13;
      out32[14] = s[6] ^ v14;
      out32[15] = s[7] ^ v15;
      swap32IfBE(buffer32);
      swap32IfBE(out32);
      this.posOut = 0;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      clean(this.buffer.subarray(this.pos));
      let flags = this.flags | B3_Flags.ROOT;
      if (this.stack.length) {
        flags |= B3_Flags.PARENT;
        swap32IfBE(this.buffer32);
        this.compress(this.buffer32, 0, true);
        swap32IfBE(this.buffer32);
        this.chunksDone = 0;
        this.pos = this.blockLen;
      } else {
        flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
      }
      this.flags = flags;
      this.b2CompressOut();
    }
    writeInto(out) {
      aexists(this, false);
      abytes(out);
      this.finish();
      const { blockLen, bufferOut } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.b2CompressOut();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible after digest call");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.enableXOF = false;
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
  };
  var blake3 = /* @__PURE__ */ createHasher((opts = {}) => new _BLAKE3(opts));

  // ../../hmac.js
  var _HMAC = class {
    oHash;
    iHash;
    blockLen;
    outputLen;
    finished = false;
    destroyed = false;
    constructor(hash, key) {
      ahash(hash);
      abytes(key, void 0, "key");
      this.iHash = hash.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad = new Uint8Array(blockLen);
      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this.iHash.update(pad);
      this.oHash = hash.create();
      for (let i = 0; i < pad.length; i++)
        pad[i] ^= 54 ^ 92;
      this.oHash.update(pad);
      clean(pad);
    }
    update(buf) {
      aexists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      aexists(this);
      abytes(out, this.outputLen, "output");
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to ||= Object.create(Object.getPrototypeOf(this), {});
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    clone() {
      return this._cloneInto();
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash, key, message) => new _HMAC(hash, key).update(message).digest();
  hmac.create = (hash, key) => new _HMAC(hash, key);

  // ../../hkdf.js
  function extract(hash, ikm, salt) {
    ahash(hash);
    if (salt === void 0)
      salt = new Uint8Array(hash.outputLen);
    return hmac(hash, salt, ikm);
  }
  var HKDF_COUNTER = /* @__PURE__ */ Uint8Array.of(0);
  var EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
  function expand(hash, prk, info, length = 32) {
    ahash(hash);
    anumber(length, "length");
    const olen = hash.outputLen;
    if (length > 255 * olen)
      throw new Error("Length must be <= 255*HashLen");
    const blocks = Math.ceil(length / olen);
    if (info === void 0)
      info = EMPTY_BUFFER;
    else
      abytes(info, void 0, "info");
    const okm = new Uint8Array(blocks * olen);
    const HMAC = hmac.create(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
      HKDF_COUNTER[0] = counter + 1;
      HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
      okm.set(T, olen * counter);
      HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    clean(T, HKDF_COUNTER);
    return okm.slice(0, length);
  }
  var hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);

  // ../../pbkdf2.js
  function pbkdf2Init(hash, _password, _salt, _opts) {
    ahash(hash);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    anumber(c, "c");
    anumber(dkLen, "dkLen");
    anumber(asyncTick, "asyncTick");
    if (c < 1)
      throw new Error("iterations (c) must be >= 1");
    const password = kdfInputToBytes(_password, "password");
    const salt = kdfInputToBytes(_salt, "salt");
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    clean(u);
    return DK;
  }
  function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }
  async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      await asyncLoop(c - 1, asyncTick, () => {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // ../../sha2.js
  var SHA256_K = /* @__PURE__ */ Uint32Array.from([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);
  var SHA2_32B = class extends HashMD {
    constructor(outputLen) {
      super(64, outputLen, 8, false);
    }
    get() {
      const { A, B, C, D, E, F, G: G2, H } = this;
      return [A, B, C, D, E, F, G2, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G2, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G2 | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G: G2, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G2) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G2;
        G2 = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G2 = G2 + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G2, H);
    }
    roundClean() {
      clean(SHA256_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var _SHA256 = class extends SHA2_32B {
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    A = SHA256_IV[0] | 0;
    B = SHA256_IV[1] | 0;
    C = SHA256_IV[2] | 0;
    D = SHA256_IV[3] | 0;
    E = SHA256_IV[4] | 0;
    F = SHA256_IV[5] | 0;
    G = SHA256_IV[6] | 0;
    H = SHA256_IV[7] | 0;
    constructor() {
      super(32);
    }
  };
  var _SHA224 = class extends SHA2_32B {
    A = SHA224_IV[0] | 0;
    B = SHA224_IV[1] | 0;
    C = SHA224_IV[2] | 0;
    D = SHA224_IV[3] | 0;
    E = SHA224_IV[4] | 0;
    F = SHA224_IV[5] | 0;
    G = SHA224_IV[6] | 0;
    H = SHA224_IV[7] | 0;
    constructor() {
      super(28);
    }
  };
  var K512 = /* @__PURE__ */ (() => split([
    "0x428a2f98d728ae22",
    "0x7137449123ef65cd",
    "0xb5c0fbcfec4d3b2f",
    "0xe9b5dba58189dbbc",
    "0x3956c25bf348b538",
    "0x59f111f1b605d019",
    "0x923f82a4af194f9b",
    "0xab1c5ed5da6d8118",
    "0xd807aa98a3030242",
    "0x12835b0145706fbe",
    "0x243185be4ee4b28c",
    "0x550c7dc3d5ffb4e2",
    "0x72be5d74f27b896f",
    "0x80deb1fe3b1696b1",
    "0x9bdc06a725c71235",
    "0xc19bf174cf692694",
    "0xe49b69c19ef14ad2",
    "0xefbe4786384f25e3",
    "0x0fc19dc68b8cd5b5",
    "0x240ca1cc77ac9c65",
    "0x2de92c6f592b0275",
    "0x4a7484aa6ea6e483",
    "0x5cb0a9dcbd41fbd4",
    "0x76f988da831153b5",
    "0x983e5152ee66dfab",
    "0xa831c66d2db43210",
    "0xb00327c898fb213f",
    "0xbf597fc7beef0ee4",
    "0xc6e00bf33da88fc2",
    "0xd5a79147930aa725",
    "0x06ca6351e003826f",
    "0x142929670a0e6e70",
    "0x27b70a8546d22ffc",
    "0x2e1b21385c26c926",
    "0x4d2c6dfc5ac42aed",
    "0x53380d139d95b3df",
    "0x650a73548baf63de",
    "0x766a0abb3c77b2a8",
    "0x81c2c92e47edaee6",
    "0x92722c851482353b",
    "0xa2bfe8a14cf10364",
    "0xa81a664bbc423001",
    "0xc24b8b70d0f89791",
    "0xc76c51a30654be30",
    "0xd192e819d6ef5218",
    "0xd69906245565a910",
    "0xf40e35855771202a",
    "0x106aa07032bbd1b8",
    "0x19a4c116b8d2d0c8",
    "0x1e376c085141ab53",
    "0x2748774cdf8eeb99",
    "0x34b0bcb5e19b48a8",
    "0x391c0cb3c5c95a63",
    "0x4ed8aa4ae3418acb",
    "0x5b9cca4f7763e373",
    "0x682e6ff3d6b2b8a3",
    "0x748f82ee5defb2fc",
    "0x78a5636f43172f60",
    "0x84c87814a1f0ab72",
    "0x8cc702081a6439ec",
    "0x90befffa23631e28",
    "0xa4506cebde82bde9",
    "0xbef9a3f7b2c67915",
    "0xc67178f2e372532b",
    "0xca273eceea26619c",
    "0xd186b8c721c0c207",
    "0xeada7dd6cde0eb1e",
    "0xf57d4f7fee6ed178",
    "0x06f067aa72176fba",
    "0x0a637dc5a2c898a6",
    "0x113f9804bef90dae",
    "0x1b710b35131c471b",
    "0x28db77f523047d84",
    "0x32caab7b40c72493",
    "0x3c9ebe0a15c9bebc",
    "0x431d67c49c100d4c",
    "0x4cc5d4becb3e42b6",
    "0x597f299cfc657e2a",
    "0x5fcb6fab3ad6faec",
    "0x6c44198c4a475817"
  ].map((n) => BigInt(n))))();
  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
  var SHA2_64B = class extends HashMD {
    constructor(outputLen) {
      super(128, outputLen, 16, false);
    }
    // prettier-ignore
    get() {
      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (let i = 16; i < 80; i++) {
        const W15h = SHA512_W_H[i - 15] | 0;
        const W15l = SHA512_W_L[i - 15] | 0;
        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);
        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);
        const W2h = SHA512_W_H[i - 2] | 0;
        const W2l = SHA512_W_L[i - 2] | 0;
        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);
        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);
        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
        SHA512_W_H[i] = SUMh | 0;
        SHA512_W_L[i] = SUMl | 0;
      }
      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
      for (let i = 0; i < 80; i++) {
        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);
        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);
        const CHIh = Eh & Fh ^ ~Eh & Gh;
        const CHIl = El & Fl ^ ~El & Gl;
        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
        const T1l = T1ll | 0;
        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);
        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);
        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        const All = add3L(T1l, sigma0l, MAJl);
        Ah = add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
      clean(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  };
  var _SHA512 = class extends SHA2_64B {
    Ah = SHA512_IV[0] | 0;
    Al = SHA512_IV[1] | 0;
    Bh = SHA512_IV[2] | 0;
    Bl = SHA512_IV[3] | 0;
    Ch = SHA512_IV[4] | 0;
    Cl = SHA512_IV[5] | 0;
    Dh = SHA512_IV[6] | 0;
    Dl = SHA512_IV[7] | 0;
    Eh = SHA512_IV[8] | 0;
    El = SHA512_IV[9] | 0;
    Fh = SHA512_IV[10] | 0;
    Fl = SHA512_IV[11] | 0;
    Gh = SHA512_IV[12] | 0;
    Gl = SHA512_IV[13] | 0;
    Hh = SHA512_IV[14] | 0;
    Hl = SHA512_IV[15] | 0;
    constructor() {
      super(64);
    }
  };
  var _SHA384 = class extends SHA2_64B {
    Ah = SHA384_IV[0] | 0;
    Al = SHA384_IV[1] | 0;
    Bh = SHA384_IV[2] | 0;
    Bl = SHA384_IV[3] | 0;
    Ch = SHA384_IV[4] | 0;
    Cl = SHA384_IV[5] | 0;
    Dh = SHA384_IV[6] | 0;
    Dl = SHA384_IV[7] | 0;
    Eh = SHA384_IV[8] | 0;
    El = SHA384_IV[9] | 0;
    Fh = SHA384_IV[10] | 0;
    Fl = SHA384_IV[11] | 0;
    Gh = SHA384_IV[12] | 0;
    Gl = SHA384_IV[13] | 0;
    Hh = SHA384_IV[14] | 0;
    Hl = SHA384_IV[15] | 0;
    constructor() {
      super(48);
    }
  };
  var T224_IV = /* @__PURE__ */ Uint32Array.from([
    2352822216,
    424955298,
    1944164710,
    2312950998,
    502970286,
    855612546,
    1738396948,
    1479516111,
    258812777,
    2077511080,
    2011393907,
    79989058,
    1067287976,
    1780299464,
    286451373,
    2446758561
  ]);
  var T256_IV = /* @__PURE__ */ Uint32Array.from([
    573645204,
    4230739756,
    2673172387,
    3360449730,
    596883563,
    1867755857,
    2520282905,
    1497426621,
    2519219938,
    2827943907,
    3193839141,
    1401305490,
    721525244,
    746961066,
    246885852,
    2177182882
  ]);
  var _SHA512_224 = class extends SHA2_64B {
    Ah = T224_IV[0] | 0;
    Al = T224_IV[1] | 0;
    Bh = T224_IV[2] | 0;
    Bl = T224_IV[3] | 0;
    Ch = T224_IV[4] | 0;
    Cl = T224_IV[5] | 0;
    Dh = T224_IV[6] | 0;
    Dl = T224_IV[7] | 0;
    Eh = T224_IV[8] | 0;
    El = T224_IV[9] | 0;
    Fh = T224_IV[10] | 0;
    Fl = T224_IV[11] | 0;
    Gh = T224_IV[12] | 0;
    Gl = T224_IV[13] | 0;
    Hh = T224_IV[14] | 0;
    Hl = T224_IV[15] | 0;
    constructor() {
      super(28);
    }
  };
  var _SHA512_256 = class extends SHA2_64B {
    Ah = T256_IV[0] | 0;
    Al = T256_IV[1] | 0;
    Bh = T256_IV[2] | 0;
    Bl = T256_IV[3] | 0;
    Ch = T256_IV[4] | 0;
    Cl = T256_IV[5] | 0;
    Dh = T256_IV[6] | 0;
    Dl = T256_IV[7] | 0;
    Eh = T256_IV[8] | 0;
    El = T256_IV[9] | 0;
    Fh = T256_IV[10] | 0;
    Fl = T256_IV[11] | 0;
    Gh = T256_IV[12] | 0;
    Gl = T256_IV[13] | 0;
    Hh = T256_IV[14] | 0;
    Hl = T256_IV[15] | 0;
    constructor() {
      super(32);
    }
  };
  var sha256 = /* @__PURE__ */ createHasher(
    () => new _SHA256(),
    /* @__PURE__ */ oidNist(1)
  );
  var sha224 = /* @__PURE__ */ createHasher(
    () => new _SHA224(),
    /* @__PURE__ */ oidNist(4)
  );
  var sha512 = /* @__PURE__ */ createHasher(
    () => new _SHA512(),
    /* @__PURE__ */ oidNist(3)
  );
  var sha384 = /* @__PURE__ */ createHasher(
    () => new _SHA384(),
    /* @__PURE__ */ oidNist(2)
  );
  var sha512_256 = /* @__PURE__ */ createHasher(
    () => new _SHA512_256(),
    /* @__PURE__ */ oidNist(6)
  );
  var sha512_224 = /* @__PURE__ */ createHasher(
    () => new _SHA512_224(),
    /* @__PURE__ */ oidNist(5)
  );

  // ../../scrypt.js
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl(x00 + x12 | 0, 7);
      x08 ^= rotl(x04 + x00 | 0, 9);
      x12 ^= rotl(x08 + x04 | 0, 13);
      x00 ^= rotl(x12 + x08 | 0, 18);
      x09 ^= rotl(x05 + x01 | 0, 7);
      x13 ^= rotl(x09 + x05 | 0, 9);
      x01 ^= rotl(x13 + x09 | 0, 13);
      x05 ^= rotl(x01 + x13 | 0, 18);
      x14 ^= rotl(x10 + x06 | 0, 7);
      x02 ^= rotl(x14 + x10 | 0, 9);
      x06 ^= rotl(x02 + x14 | 0, 13);
      x10 ^= rotl(x06 + x02 | 0, 18);
      x03 ^= rotl(x15 + x11 | 0, 7);
      x07 ^= rotl(x03 + x15 | 0, 9);
      x11 ^= rotl(x07 + x03 | 0, 13);
      x15 ^= rotl(x11 + x07 | 0, 18);
      x01 ^= rotl(x00 + x03 | 0, 7);
      x02 ^= rotl(x01 + x00 | 0, 9);
      x03 ^= rotl(x02 + x01 | 0, 13);
      x00 ^= rotl(x03 + x02 | 0, 18);
      x06 ^= rotl(x05 + x04 | 0, 7);
      x07 ^= rotl(x06 + x05 | 0, 9);
      x04 ^= rotl(x07 + x06 | 0, 13);
      x05 ^= rotl(x04 + x07 | 0, 18);
      x11 ^= rotl(x10 + x09 | 0, 7);
      x08 ^= rotl(x11 + x10 | 0, 9);
      x09 ^= rotl(x08 + x11 | 0, 13);
      x10 ^= rotl(x09 + x08 | 0, 18);
      x12 ^= rotl(x15 + x14 | 0, 7);
      x13 ^= rotl(x12 + x15 | 0, 9);
      x14 ^= rotl(x13 + x12 | 0, 13);
      x15 ^= rotl(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    anumber(N, "N");
    anumber(r, "r");
    anumber(p, "p");
    anumber(dkLen, "dkLen");
    anumber(asyncTick, "asyncTick");
    anumber(maxmem, "maxmem");
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb must be a function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    const pow32 = Math.pow(2, 32);
    if (N <= 1 || (N & N - 1) !== 0 || N > pow32)
      throw new Error('"N" expected a power of 2, and 2^1 <= N <= 2^32');
    if (p < 1 || p > (pow32 - 1) * 32 / blockSize)
      throw new Error('"p" expected integer 1..((2^32 - 1) * 32) / (128 * r)');
    if (dkLen < 1 || dkLen > (pow32 - 1) * 32)
      throw new Error('"dkLen" expected integer 1..(2^32 - 1) * 32');
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem)
      throw new Error('"maxmem" limit was hit, expected 128*r*(N+p) > "maxmem"=' + maxmem);
    const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u32(B);
    const V = u32(new Uint8Array(blockSize * N));
    const tmp = u32(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
    clean(B, V, tmp);
    return res;
  }
  function scrypt(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    swap32IfBE(B32);
    for (let pi = 0; pi < p; pi++) {
      const Pi = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi + i];
      for (let i = 0, pos = 0; i < N - 1; i++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
      blockMixCb();
      for (let i = 0; i < N; i++) {
        const j = B32[Pi + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi, r);
        blockMixCb();
      }
    }
    swap32IfBE(B32);
    return scryptOutput(password, dkLen, B, V, tmp);
  }
  async function scryptAsync(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
    swap32IfBE(B32);
    for (let pi = 0; pi < p; pi++) {
      const Pi = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi + i];
      let pos = 0;
      await asyncLoop(N - 1, asyncTick, () => {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      });
      BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
      blockMixCb();
      await asyncLoop(N, asyncTick, () => {
        const j = B32[Pi + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi, r);
        blockMixCb();
      });
    }
    swap32IfBE(B32);
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // ../../eskdf.js
  var SCRYPT_FACTOR = 2 ** 19;
  var PBKDF2_FACTOR = 2 ** 17;
  function scrypt2(password, salt) {
    return scrypt(password, salt, { N: SCRYPT_FACTOR, r: 8, p: 1, dkLen: 32 });
  }
  function pbkdf22(password, salt) {
    return pbkdf2(sha256, password, salt, { c: PBKDF2_FACTOR, dkLen: 32 });
  }
  function xor32(a, b) {
    abytes(a, 32);
    abytes(b, 32);
    const arr = new Uint8Array(32);
    for (let i = 0; i < 32; i++) {
      arr[i] = a[i] ^ b[i];
    }
    return arr;
  }
  function strHasLength(str, min, max) {
    return typeof str === "string" && str.length >= min && str.length <= max;
  }
  function deriveMainSeed(username, password) {
    if (!strHasLength(username, 8, 255))
      throw new Error("invalid username");
    if (!strHasLength(password, 8, 255))
      throw new Error("invalid password");
    const codes = { _1: 1, _2: 2 };
    const sep = { s: String.fromCharCode(codes._1), p: String.fromCharCode(codes._2) };
    const scr = scrypt2(password + sep.s, username + sep.s);
    const pbk = pbkdf22(password + sep.p, username + sep.p);
    const res = xor32(scr, pbk);
    clean(scr, pbk);
    return res;
  }
  function getSaltInfo(protocol, accountId = 0) {
    if (!(strHasLength(protocol, 3, 15) && /^[a-z0-9]{3,15}$/.test(protocol))) {
      throw new Error("invalid protocol");
    }
    const allowsStr = /^password\d{0,3}|ssh|tor|file$/.test(protocol);
    let salt;
    if (typeof accountId === "string") {
      if (!allowsStr)
        throw new Error("accountId must be a number");
      if (!strHasLength(accountId, 1, 255))
        throw new Error("accountId must be string of length 1..255");
      salt = kdfInputToBytes(accountId);
    } else if (Number.isSafeInteger(accountId)) {
      if (accountId < 0 || accountId > Math.pow(2, 32) - 1)
        throw new Error("invalid accountId");
      salt = new Uint8Array(4);
      createView(salt).setUint32(0, accountId, false);
    } else {
      throw new Error("accountId must be a number" + (allowsStr ? " or string" : ""));
    }
    const info = kdfInputToBytes(protocol);
    return { salt, info };
  }
  function countBytes(num) {
    if (typeof num !== "bigint" || num <= BigInt(128))
      throw new Error("invalid number");
    return Math.ceil(num.toString(2).length / 8);
  }
  function getKeyLength(options) {
    if (!options || typeof options !== "object")
      return 32;
    const hasLen = "keyLength" in options;
    const hasMod = "modulus" in options;
    if (hasLen && hasMod)
      throw new Error("cannot combine keyLength and modulus options");
    if (!hasLen && !hasMod)
      throw new Error("must have either keyLength or modulus option");
    const l = hasMod ? countBytes(options.modulus) + 8 : options.keyLength;
    if (!(typeof l === "number" && l >= 16 && l <= 8192))
      throw new Error("invalid keyLength");
    return l;
  }
  function modReduceKey(key, modulus) {
    const _1 = BigInt(1);
    const num = BigInt("0x" + bytesToHex(key));
    const res = num % (modulus - _1) + _1;
    if (res < _1)
      throw new Error("expected positive number");
    const len = key.length - 8;
    const hex = res.toString(16).padStart(len * 2, "0");
    const bytes = hexToBytes(hex);
    if (bytes.length !== len)
      throw new Error("invalid length of result key");
    return bytes;
  }
  async function eskdf(username, password) {
    let seed = deriveMainSeed(username, password);
    function deriveCK(protocol, accountId = 0, options) {
      abytes(seed, 32);
      const { salt, info } = getSaltInfo(protocol, accountId);
      const keyLength = getKeyLength(options);
      const key = hkdf(sha256, seed, salt, info, keyLength);
      return options && "modulus" in options ? modReduceKey(key, options.modulus) : key;
    }
    function expire() {
      if (seed)
        seed.fill(1);
      seed = void 0;
    }
    const fingerprint = Array.from(deriveCK("fingerprint", 0)).slice(0, 6).map((char) => char.toString(16).padStart(2, "0").toUpperCase()).join(":");
    return Object.freeze({ deriveChildKey: deriveCK, expire, fingerprint });
  }

  // ../../legacy.js
  var SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ]);
  var SHA1_W = /* @__PURE__ */ new Uint32Array(80);
  var _SHA1 = class extends HashMD {
    A = SHA1_IV[0] | 0;
    B = SHA1_IV[1] | 0;
    C = SHA1_IV[2] | 0;
    D = SHA1_IV[3] | 0;
    E = SHA1_IV[4] | 0;
    constructor() {
      super(64, 20, 8, false);
    }
    get() {
      const { A, B, C, D, E } = this;
      return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA1_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 80; i++)
        SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
      let { A, B, C, D, E } = this;
      for (let i = 0; i < 80; i++) {
        let F, K2;
        if (i < 20) {
          F = Chi(B, C, D);
          K2 = 1518500249;
        } else if (i < 40) {
          F = B ^ C ^ D;
          K2 = 1859775393;
        } else if (i < 60) {
          F = Maj(B, C, D);
          K2 = 2400959708;
        } else {
          F = B ^ C ^ D;
          K2 = 3395469782;
        }
        const T = rotl(A, 5) + F + E + K2 + SHA1_W[i] | 0;
        E = D;
        D = C;
        C = rotl(B, 30);
        B = A;
        A = T;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      this.set(A, B, C, D, E);
    }
    roundClean() {
      clean(SHA1_W);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var sha1 = /* @__PURE__ */ createHasher(() => new _SHA1());
  var p32 = /* @__PURE__ */ Math.pow(2, 32);
  var K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
  var MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
  var MD5_W = /* @__PURE__ */ new Uint32Array(16);
  var _MD5 = class extends HashMD {
    A = MD5_IV[0] | 0;
    B = MD5_IV[1] | 0;
    C = MD5_IV[2] | 0;
    D = MD5_IV[3] | 0;
    constructor() {
      super(64, 16, 8, true);
    }
    get() {
      const { A, B, C, D } = this;
      return [A, B, C, D];
    }
    set(A, B, C, D) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        MD5_W[i] = view.getUint32(offset, true);
      let { A, B, C, D } = this;
      for (let i = 0; i < 64; i++) {
        let F, g, s;
        if (i < 16) {
          F = Chi(B, C, D);
          g = i;
          s = [7, 12, 17, 22];
        } else if (i < 32) {
          F = Chi(D, B, C);
          g = (5 * i + 1) % 16;
          s = [5, 9, 14, 20];
        } else if (i < 48) {
          F = B ^ C ^ D;
          g = (3 * i + 5) % 16;
          s = [4, 11, 16, 23];
        } else {
          F = C ^ (B | ~D);
          g = 7 * i % 16;
          s = [6, 10, 15, 21];
        }
        F = F + A + K[i] + MD5_W[g];
        A = D;
        D = C;
        C = B;
        B = B + rotl(F, s[i % 4]);
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      this.set(A, B, C, D);
    }
    roundClean() {
      clean(MD5_W);
    }
    destroy() {
      this.set(0, 0, 0, 0);
      clean(this.buffer);
    }
  };
  var md5 = /* @__PURE__ */ createHasher(() => new _MD5());
  var Rho160 = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
  ]);
  var Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
  var Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
  var idxLR = /* @__PURE__ */ (() => {
    const L = [Id160];
    const R = [Pi160];
    const res = [L, R];
    for (let i = 0; i < 4; i++)
      for (let j of res)
        j.push(j[i].map((k) => Rho160[k]));
    return res;
  })();
  var idxL = /* @__PURE__ */ (() => idxLR[0])();
  var idxR = /* @__PURE__ */ (() => idxLR[1])();
  var shifts160 = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => Uint8Array.from(i));
  var shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
  var shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
  var Kl160 = /* @__PURE__ */ Uint32Array.from([
    0,
    1518500249,
    1859775393,
    2400959708,
    2840853838
  ]);
  var Kr160 = /* @__PURE__ */ Uint32Array.from([
    1352829926,
    1548603684,
    1836072691,
    2053994217,
    0
  ]);
  function ripemd_f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    if (group === 1)
      return x & y | ~x & z;
    if (group === 2)
      return (x | ~y) ^ z;
    if (group === 3)
      return x & z | y & ~z;
    return x ^ (y | ~z);
  }
  var BUF_160 = /* @__PURE__ */ new Uint32Array(16);
  var _RIPEMD160 = class extends HashMD {
    h0 = 1732584193 | 0;
    h1 = 4023233417 | 0;
    h2 = 2562383102 | 0;
    h3 = 271733878 | 0;
    h4 = 3285377520 | 0;
    constructor() {
      super(64, 20, 8, true);
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        BUF_160[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl160[group], hbr = Kr160[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL160[group], sr = shiftsR160[group];
        for (let i = 0; i < 16; i++) {
          const tl = rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr = rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      clean(BUF_160);
    }
    destroy() {
      this.destroyed = true;
      clean(this.buffer);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = /* @__PURE__ */ createHasher(() => new _RIPEMD160());

  // ../../sha3.js
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _7n = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  var SHA3_PI = [];
  var SHA3_ROTL = [];
  var _SHA3_IOTA = [];
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var IOTAS = split(_SHA3_IOTA, true);
  var SHA3_IOTA_H = IOTAS[0];
  var SHA3_IOTA_L = IOTAS[1];
  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    clean(B);
  }
  var Keccak = class _Keccak {
    state;
    pos = 0;
    posOut = 0;
    finished = false;
    state32;
    destroyed = false;
    blockLen;
    suffix;
    outputLen;
    enableXOF = false;
    rounds;
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      anumber(outputLen, "outputLen");
      if (!(0 < blockLen && blockLen < 200))
        throw new Error("only keccak-f1600 function is supported");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    clone() {
      return this._cloneInto();
    }
    keccak() {
      swap32IfBE(this.state32);
      keccakP(this.state32, this.rounds);
      swap32IfBE(this.state32);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      aexists(this);
      abytes(data);
      const { blockLen, state } = this;
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      aexists(this, false);
      abytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes) {
      anumber(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
      aoutput(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      clean(this.state);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to ||= new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds);
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var genKeccak = (suffix, blockLen, outputLen, info = {}) => createHasher(() => new Keccak(blockLen, suffix, outputLen), info);
  var sha3_224 = /* @__PURE__ */ genKeccak(
    6,
    144,
    28,
    /* @__PURE__ */ oidNist(7)
  );
  var sha3_256 = /* @__PURE__ */ genKeccak(
    6,
    136,
    32,
    /* @__PURE__ */ oidNist(8)
  );
  var sha3_384 = /* @__PURE__ */ genKeccak(
    6,
    104,
    48,
    /* @__PURE__ */ oidNist(9)
  );
  var sha3_512 = /* @__PURE__ */ genKeccak(
    6,
    72,
    64,
    /* @__PURE__ */ oidNist(10)
  );
  var keccak_224 = /* @__PURE__ */ genKeccak(1, 144, 28);
  var keccak_256 = /* @__PURE__ */ genKeccak(1, 136, 32);
  var keccak_384 = /* @__PURE__ */ genKeccak(1, 104, 48);
  var keccak_512 = /* @__PURE__ */ genKeccak(1, 72, 64);
  var genShake = (suffix, blockLen, outputLen, info = {}) => createHasher((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true), info);
  var shake128 = /* @__PURE__ */ genShake(31, 168, 16, /* @__PURE__ */ oidNist(11));
  var shake256 = /* @__PURE__ */ genShake(31, 136, 32, /* @__PURE__ */ oidNist(12));

  // ../../sha3-addons.js
  var _8n = /* @__PURE__ */ BigInt(8);
  var _ffn = /* @__PURE__ */ BigInt(255);
  function leftEncode(n) {
    n = BigInt(n);
    const res = [Number(n & _ffn)];
    n >>= _8n;
    for (; n > 0; n >>= _8n)
      res.unshift(Number(n & _ffn));
    res.unshift(res.length);
    return new Uint8Array(res);
  }
  function rightEncode(n) {
    n = BigInt(n);
    const res = [Number(n & _ffn)];
    n >>= _8n;
    for (; n > 0; n >>= _8n)
      res.unshift(Number(n & _ffn));
    res.push(res.length);
    return new Uint8Array(res);
  }
  function chooseLen(opts, outputLen) {
    return opts.dkLen === void 0 ? outputLen : opts.dkLen;
  }
  var abytesOrZero2 = (buf, title = "") => {
    if (buf === void 0)
      return EMPTY_BUFFER2;
    abytes(buf, void 0, title);
    return buf;
  };
  var getPadding = (len, block2) => new Uint8Array((block2 - len % block2) % block2);
  function cshakePers(hash, opts = {}) {
    if (!opts || opts.personalization === void 0 && opts.NISTfn === void 0)
      return hash;
    const blockLenBytes = leftEncode(hash.blockLen);
    const fn = opts.NISTfn === void 0 ? EMPTY_BUFFER2 : kdfInputToBytes(opts.NISTfn);
    const fnLen = leftEncode(_8n * BigInt(fn.length));
    const pers = abytesOrZero2(opts.personalization, "personalization");
    const persLen = leftEncode(_8n * BigInt(pers.length));
    if (!fn.length && !pers.length)
      return hash;
    hash.suffix = 4;
    hash.update(blockLenBytes).update(fnLen).update(fn).update(persLen).update(pers);
    let totalLen = blockLenBytes.length + fnLen.length + fn.length + persLen.length + pers.length;
    hash.update(getPadding(totalLen, hash.blockLen));
    return hash;
  }
  var gencShake = (suffix, blockLen, outputLen) => createHasher((opts = {}) => cshakePers(new Keccak(blockLen, suffix, chooseLen(opts, outputLen), true), opts));
  var cshake128 = /* @__PURE__ */ gencShake(31, 168, 16);
  var cshake256 = /* @__PURE__ */ gencShake(31, 136, 32);
  var _KMAC = class extends Keccak {
    constructor(blockLen, outputLen, enableXOF, key, opts = {}) {
      super(blockLen, 31, outputLen, enableXOF);
      cshakePers(this, { NISTfn: "KMAC", personalization: opts.personalization });
      abytes(key, void 0, "key");
      const blockLenBytes = leftEncode(this.blockLen);
      const keyLen = leftEncode(_8n * BigInt(key.length));
      this.update(blockLenBytes).update(keyLen).update(key);
      const totalLen = blockLenBytes.length + keyLen.length + key.length;
      this.update(getPadding(totalLen, this.blockLen));
    }
    finish() {
      if (!this.finished)
        this.update(rightEncode(this.enableXOF ? 0 : _8n * BigInt(this.outputLen)));
      super.finish();
    }
    _cloneInto(to) {
      if (!to) {
        to = Object.create(Object.getPrototypeOf(this), {});
        to.state = this.state.slice();
        to.blockLen = this.blockLen;
        to.state32 = u32(to.state);
      }
      return super._cloneInto(to);
    }
    clone() {
      return this._cloneInto();
    }
  };
  function genKmac(blockLen, outputLen, xof = false) {
    const kmac = (key, message, opts) => kmac.create(key, opts).update(message).digest();
    kmac.create = (key, opts = {}) => new _KMAC(blockLen, chooseLen(opts, outputLen), xof, key, opts);
    return kmac;
  }
  var kmac128 = /* @__PURE__ */ genKmac(168, 16);
  var kmac256 = /* @__PURE__ */ genKmac(136, 32);
  var genTurbo = (blockLen, outputLen) => createHasher((opts = {}) => {
    const D = opts.D === void 0 ? 31 : opts.D;
    if (!Number.isSafeInteger(D) || D < 1 || D > 127)
      throw new Error('"D" (domain separation byte) must be 0x01..0x7f, got: ' + D);
    return new Keccak(blockLen, D, opts.dkLen === void 0 ? outputLen : opts.dkLen, true, 12);
  });
  var turboshake128 = /* @__PURE__ */ genTurbo(168, 32);
  var turboshake256 = /* @__PURE__ */ genTurbo(136, 64);
  function rightEncodeK12(n) {
    n = BigInt(n);
    const res = [];
    for (; n > 0; n >>= _8n)
      res.unshift(Number(n & _ffn));
    res.push(res.length);
    return Uint8Array.from(res);
  }
  var EMPTY_BUFFER2 = /* @__PURE__ */ Uint8Array.of();
  var _KangarooTwelve = class __KangarooTwelve extends Keccak {
    chunkLen = 8192;
    leafHash;
    leafLen;
    personalization;
    chunkPos = 0;
    // Position of current block in chunk
    chunksDone = 0;
    // How many chunks we already have
    constructor(blockLen, leafLen, outputLen, rounds, opts) {
      super(blockLen, 7, outputLen, true, rounds);
      this.leafLen = leafLen;
      this.personalization = abytesOrZero2(opts.personalization, "personalization");
    }
    update(data) {
      abytes(data);
      const { chunkLen, blockLen, leafLen, rounds } = this;
      for (let pos = 0, len = data.length; pos < len; ) {
        if (this.chunkPos == chunkLen) {
          if (this.leafHash)
            super.update(this.leafHash.digest());
          else {
            this.suffix = 6;
            super.update(Uint8Array.from([3, 0, 0, 0, 0, 0, 0, 0]));
          }
          this.leafHash = new Keccak(blockLen, 11, leafLen, false, rounds);
          this.chunksDone++;
          this.chunkPos = 0;
        }
        const take = Math.min(chunkLen - this.chunkPos, len - pos);
        const chunk = data.subarray(pos, pos + take);
        if (this.leafHash)
          this.leafHash.update(chunk);
        else
          super.update(chunk);
        this.chunkPos += take;
        pos += take;
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      const { personalization } = this;
      this.update(personalization).update(rightEncodeK12(personalization.length));
      if (this.leafHash) {
        super.update(this.leafHash.digest());
        super.update(rightEncodeK12(this.chunksDone));
        super.update(Uint8Array.from([255, 255]));
      }
      super.finish.call(this);
    }
    destroy() {
      super.destroy.call(this);
      if (this.leafHash)
        this.leafHash.destroy();
      this.personalization = EMPTY_BUFFER2;
    }
    _cloneInto(to) {
      const { blockLen, leafLen, leafHash, outputLen, rounds } = this;
      to ||= new __KangarooTwelve(blockLen, leafLen, outputLen, rounds, {});
      super._cloneInto(to);
      if (leafHash)
        to.leafHash = leafHash._cloneInto(to.leafHash);
      to.personalization.set(this.personalization);
      to.leafLen = this.leafLen;
      to.chunkPos = this.chunkPos;
      to.chunksDone = this.chunksDone;
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var kt128 = /* @__PURE__ */ createHasher((opts = {}) => new _KangarooTwelve(168, 32, chooseLen(opts, 32), 12, opts));
  var kt256 = /* @__PURE__ */ createHasher((opts = {}) => new _KangarooTwelve(136, 64, chooseLen(opts, 64), 12, opts));
  var _KeccakPRG = class __KeccakPRG extends Keccak {
    rate;
    constructor(capacity) {
      anumber(capacity);
      const rate = 1600 - capacity;
      const rho = rate - 2;
      if (capacity < 0 || capacity > 1600 - 10 || rho % 8)
        throw new Error("invalid capacity");
      super(rho / 8, 0, 0, true);
      this.rate = rate;
      this.posOut = Math.floor((rate + 7) / 8);
    }
    keccak() {
      this.state[this.pos] ^= 1;
      this.state[this.blockLen] ^= 2;
      super.keccak();
      this.pos = 0;
      this.posOut = 0;
    }
    update(data) {
      super.update(data);
      this.posOut = this.blockLen;
      return this;
    }
    finish() {
    }
    digestInto(_out) {
      throw new Error("digest is not allowed, use .fetch instead");
    }
    addEntropy(seed) {
      this.update(seed);
    }
    randomBytes(length) {
      return this.xof(length);
    }
    clean() {
      if (this.rate < 1600 / 2 + 1)
        throw new Error("rate is too low to use .forget()");
      this.keccak();
      for (let i = 0; i < this.blockLen; i++)
        this.state[i] = 0;
      this.pos = this.blockLen;
      this.keccak();
      this.posOut = this.blockLen;
    }
    _cloneInto(to) {
      const { rate } = this;
      to ||= new __KeccakPRG(1600 - rate);
      super._cloneInto(to);
      to.rate = rate;
      return to;
    }
    clone() {
      return this._cloneInto();
    }
  };
  var keccakprg = (capacity = 254) => new _KeccakPRG(capacity);

  // ../../webcrypto.js
  var webcrypto_exports = {};
  __export(webcrypto_exports, {
    hkdf: () => hkdf2,
    hmac: () => hmac2,
    pbkdf2: () => pbkdf23,
    sha256: () => sha2562,
    sha384: () => sha3842,
    sha512: () => sha5122
  });
  function _subtle() {
    const cr = typeof globalThis === "object" ? globalThis.crypto : null;
    const sb = cr?.subtle;
    if (typeof sb === "object" && sb != null)
      return sb;
    throw new Error("crypto.subtle must be defined");
  }
  function createWebHash(name, blockLen, outputLen) {
    const hashC = async (msg) => {
      abytes(msg);
      const crypto = _subtle();
      return new Uint8Array(await crypto.digest(name, msg));
    };
    hashC.webCryptoName = name;
    hashC.outputLen = outputLen;
    hashC.blockLen = blockLen;
    hashC.create = () => {
      throw new Error("not implemented");
    };
    return hashC;
  }
  function ahashWeb(hash) {
    ahash(hash);
    if (typeof hash.webCryptoName !== "string")
      throw new Error("non-web hash");
  }
  var sha2562 = /* @__PURE__ */ createWebHash("SHA-256", 64, 32);
  var sha3842 = /* @__PURE__ */ createWebHash("SHA-384", 128, 48);
  var sha5122 = /* @__PURE__ */ createWebHash("SHA-512", 128, 64);
  var hmac2 = /* @__PURE__ */ (() => {
    const hmac_ = async (hash, key, message) => {
      const crypto = _subtle();
      abytes(key, void 0, "key");
      abytes(message, void 0, "message");
      ahashWeb(hash);
      const wkey = await crypto.importKey("raw", key, { name: "HMAC", hash: hash.webCryptoName }, false, ["sign"]);
      return new Uint8Array(await crypto.sign("HMAC", wkey, message));
    };
    hmac_.create = (_hash, _key) => {
      throw new Error("not implemented");
    };
    return hmac_;
  })();
  async function hkdf2(hash, ikm, salt, info, length) {
    const crypto = _subtle();
    ahashWeb(hash);
    abytes(ikm, void 0, "ikm");
    anumber(length, "length");
    if (salt !== void 0)
      abytes(salt, void 0, "salt");
    if (info !== void 0)
      abytes(info, void 0, "info");
    const wkey = await crypto.importKey("raw", ikm, "HKDF", false, ["deriveBits"]);
    const opts = {
      name: "HKDF",
      hash: hash.webCryptoName,
      salt: salt === void 0 ? new Uint8Array(0) : salt,
      info: info === void 0 ? new Uint8Array(0) : info
    };
    return new Uint8Array(await crypto.deriveBits(opts, wkey, 8 * length));
  }
  async function pbkdf23(hash, password, salt, opts) {
    const crypto = _subtle();
    ahashWeb(hash);
    const _opts = checkOpts({ dkLen: 32 }, opts);
    const { c, dkLen } = _opts;
    anumber(c, "c");
    anumber(dkLen, "dkLen");
    const _password = kdfInputToBytes(password, "password");
    const _salt = kdfInputToBytes(salt, "salt");
    const key = await crypto.importKey("raw", _password, "PBKDF2", false, [
      "deriveBits"
    ]);
    const deriveOpts = { name: "PBKDF2", salt: _salt, iterations: c, hash: hash.webCryptoName };
    return new Uint8Array(await crypto.deriveBits(deriveOpts, key, 8 * dkLen));
  }

  // input.js
  var utils = { bytesToHex, hexToBytes, concatBytes, utf8ToBytes, randomBytes };
  return __toCommonJS(input_exports);
})();
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\noble-hashes.js
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\sss-bridge.js
# SIZE: 1676 bytes
# HASH: 3297604bb5d41ec64cb5741eb525c2d00aefb2261d473ab69b7106dcd3bef3bd
# MODIFIED: 2025-08-27T02:19:12.885488
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

#!/usr/bin/env node
// sss-bridge.js  JSON-over-stdin CLI around the audited library

const fs = require("fs");
const path = require("path");

// Load audited package from vendor folder, unchanged
const pkgPath = path.join(__dirname, "vendor", "shamir-secret-sharing-0.0.3");
const { split, combine } = require(pkgPath); // CommonJS default export (index.js)

const readStdin = () => fs.readFileSync(0, "utf8");
const ok = (obj) => process.stdout.write(JSON.stringify({ ok: true, ...obj }) + "\n");
const fail = (err) =>
  process.stdout.write(JSON.stringify({ ok: false, error: String(err && err.message ? err.message : err) }) + "\n");

(async () => {
  try {
    const req = JSON.parse(readStdin());

    if (req.cmd === "split") {
      if (typeof req.secret_b64 !== "string") throw new Error("secret_b64 missing");
      if (typeof req.shares !== "number" || typeof req.threshold !== "number") throw new Error("shares/threshold missing");
      const secret = new Uint8Array(Buffer.from(req.secret_b64, "base64"));
      const shares = await split(secret, req.shares, req.threshold);
      const shares_b64 = shares.map((u8) => Buffer.from(u8).toString("base64"));
      ok({ shares_b64 });
      return;
    }

    if (req.cmd === "combine") {
      if (!Array.isArray(req.shares_b64)) throw new Error("shares_b64 missing");
      const shares = req.shares_b64.map((b64) => new Uint8Array(Buffer.from(b64, "base64")));
      const secret = await combine(shares);
      ok({ secret_b64: Buffer.from(secret).toString("base64") });
      return;
    }

    throw new Error("unknown cmd");
  } catch (e) {
    fail(e);
  }
})();



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\bridge\sss-bridge.js
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\examples\example_usage.py
# SIZE: 1882 bytes
# HASH: e8b179e2bc7e354d73e384a05743db7ac1fc1a5dd9f957c1f7ccf0b24292d770
# MODIFIED: 2025-08-29T04:23:40.782690
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

# examples/example_usage.py
from modules.noble_bridge import NobleBridge
import secrets

def main():
    print("Starting test")
    js_dir = 'bridge'  # path where bridge.js and noble-*.js live
    key = secrets.token_bytes(32)
    nonce_gcm = secrets.token_bytes(12)
    nonce_chacha = secrets.token_bytes(12)
    nonce_xchacha = secrets.token_bytes(24)
    aad = b'header'
    msg = b'hello world'
    salt = secrets.token_bytes(16)

    with NobleBridge(js_dir=js_dir) as nb:
        print("Bridge started, running operations")

        # AES-GCM
        ct = nb.aes_gcm_encrypt(key, nonce_gcm, msg, aad)
        pt = nb.aes_gcm_decrypt(key, nonce_gcm, ct, aad)
        assert pt == msg
        print("AES-GCM OK")

        # ChaCha20-Poly1305
        ct2 = nb.chacha20poly1305_encrypt(key, nonce_chacha, msg, aad)
        pt2 = nb.chacha20poly1305_decrypt(key, nonce_chacha, ct2, aad)
        assert pt2 == msg
        print("ChaCha20-Poly1305 OK")

        # XChaCha20-Poly1305
        ct3 = nb.xchacha20poly1305_encrypt(key, nonce_xchacha, msg, aad)
        pt3 = nb.xchacha20poly1305_decrypt(key, nonce_xchacha, ct3, aad)
        assert pt3 == msg
        print("XChaCha20-Poly1305 OK")

        # Hashes / MACs / KDFs
        _ = nb.sha3_256(b'data')
        _ = nb.hmac_sha256(key, b'data')
        _ = nb.hkdf_sha256(key, salt, b'ctx', 42)
        print("Hashes/HMAC/HKDF OK")

        # Argon2id
        _ = nb.argon2id(b'password', salt, t=2, m=65536, p=1, dkLen=32, version=19)
        print("Argon2id OK")

        # Constant-time compare
        mac = nb.hmac_sha256(key, b'data')
        assert nb.ct_equal(mac, mac)
        assert not nb.ct_equal(mac, b'\x00' * len(mac))
        print("Constant-time compare OK")

    print("All operations OK, script finished.")

if __name__ == '__main__':
    main()



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\examples\example_usage.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\CipherForge.py
# SIZE: 10133 bytes
# HASH: 8271b8a028ce021f9e4a7e4d2c77047fb775b37063a9d91bd5f3b72ad6cadac7
# MODIFIED: 2025-08-27T02:19:20.991739
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "CipherForge.py"
################################################################################

"""
FILENAME:
"CipherForge.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason, 
by any AI system, user, or process. If you see this comment, do not remove or change it 
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning, 
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner 
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Main flow with mandatory Argon2id usage for all encryption,
ensuring ephemeral keys/ciphertext are fully logged so
the secret can be rebuilt from logs alone.

All references to any 'decoy' secret have been removed. Only a single real secret
is stored across shares for correct (real) answers; incorrect answers contain dummy shares.
"""

import os
import base64
from typing import Dict, Optional, Tuple, Union

import argon2.low_level
import argon2.exceptions

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305

# Logging
from modules.debug_utils import log_debug, log_crypto_event


def derive_key_argon2id(password: str,
                        salt: bytes,
                        key_length: int = 32,
                        time_cost: int = 3,
                        memory_cost: int = 65536,
                        parallelism: int = 4,
                        ephemeral: bool = False) -> bytes:
    """
    FIXED KDF: use Argon2id RAW output (bytes) with exact hash_len=key_length.
    No slicing of PHC strings; no misuse of hash_secret(...).
    """
    ephemeral_info = {
        "salt_b64": base64.b64encode(salt).decode(),
        "ephemeral_password": password if ephemeral else "<not ephemeral>"
    }
    log_debug(
        f"Starting Argon2id KDF (RAW). pass='{password}', salt(b64)='{ephemeral_info['salt_b64']}'",
        level="INFO",
        component="CRYPTO"
    )

    # Correct API: hash_secret_raw returns RAW bytes of length hash_len
    derived_bytes = argon2.low_level.hash_secret_raw(
        secret=password.encode("utf-8"),
        salt=salt,
        time_cost=time_cost,
        memory_cost=memory_cost,
        parallelism=parallelism,
        hash_len=key_length,
        type=argon2.low_level.Type.ID
    )

    log_crypto_event(
        operation="KDF Derive",
        algorithm="Argon2id",
        ephemeral=ephemeral,
        ephemeral_key=derived_bytes,
        argon_params={
            "time_cost": time_cost,
            "memory_cost": memory_cost,
            "parallelism": parallelism,
            "key_length": key_length
        },
        key_derived_bytes=derived_bytes,
        details={
            "message": "Argon2id RAW complete. Derived key is in logs.",
            "ephemeral_info": ephemeral_info
        }
    )
    return derived_bytes


def encrypt_aes256gcm(plaintext: Union[str, bytes, bytearray],
                      key: bytes,
                      aad: Optional[bytes] = None,
                      ephemeral_pass: Optional[str] = None,
                      ephemeral_salt: Optional[bytes] = None) -> Dict[str, str]:
    """
    AES-256-GCM with optional AAD binding.
    Plaintext can be str, bytes, or bytearray.
    """
    if isinstance(plaintext, str):
        plaintext = plaintext.encode("utf-8")
    elif isinstance(plaintext, bytearray):
        plaintext = bytes(plaintext)

    nonce = os.urandom(12)
    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce))
    encryptor = cipher.encryptor()
    if aad:
        encryptor.authenticate_additional_data(aad)
    ciphertext = encryptor.update(plaintext) + encryptor.finalize()
    tag = encryptor.tag

    out = {
        "alg": "AES-256-GCM",
        "ciphertext": base64.b64encode(ciphertext).decode(),
        "nonce": base64.b64encode(nonce).decode(),
        "tag": base64.b64encode(tag).decode()
    }

    details = {
        "Nonce(base64)": out["nonce"],
        "Ciphertext(base64)": out["ciphertext"],
        "Tag(base64)": out["tag"],
        "AAD_len": (len(aad) if aad else 0)
    }
    if ephemeral_pass is not None:
        details["ephemeral_password"] = ephemeral_pass
    if ephemeral_salt is not None:
        details["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt).decode()

    log_crypto_event(
        operation="Encrypt",
        algorithm="AES-256",
        mode="GCM",
        ephemeral_key=key,
        details=details,
        ephemeral=True
    )
    return out


def decrypt_aes256gcm(enc_dict: Dict[str, str], key: bytes, aad: Optional[bytes] = None) -> bytes:
    import base64
    ciphertext = base64.b64decode(enc_dict["ciphertext"])
    nonce = base64.b64decode(enc_dict["nonce"])
    tag = base64.b64decode(enc_dict["tag"])

    log_crypto_event(
        operation="Decrypt",
        algorithm="AES-256",
        mode="GCM",
        ephemeral_key=key,
        details={
            "Nonce(base64)": enc_dict["nonce"],
            "Ciphertext(base64)": enc_dict["ciphertext"],
            "Tag(base64)": enc_dict["tag"],
            "AAD_len": (len(aad) if aad else 0)
        },
        ephemeral=True
    )

    cipher = Cipher(algorithms.AES(key), modes.GCM(nonce, tag))
    decryptor = cipher.decryptor()
    if aad:
        decryptor.authenticate_additional_data(aad)
    plaintext = decryptor.update(ciphertext) + decryptor.finalize()
    return plaintext


def encrypt_chacha20poly1305(plaintext: Union[str, bytes, bytearray],
                             key: bytes,
                             aad: Optional[bytes] = None,
                             ephemeral_pass: Optional[str] = None,
                             ephemeral_salt: Optional[bytes] = None) -> Dict[str, str]:
    """
    ChaCha20-Poly1305 with optional AAD binding.
    Returns ciphertext (includes tag) and nonce. No synthetic 'tag' field.
    """
    if isinstance(plaintext, str):
        plaintext = plaintext.encode("utf-8")
    elif isinstance(plaintext, bytearray):
        plaintext = bytes(plaintext)

    nonce = os.urandom(12)
    cipher = ChaCha20Poly1305(key)
    ciphertext = cipher.encrypt(nonce, plaintext, aad if aad else b"")

    out = {
        "alg": "ChaCha20-Poly1305",
        "ciphertext": base64.b64encode(ciphertext).decode(),
        "nonce": base64.b64encode(nonce).decode()
    }
    details = {
        "Nonce(base64)": out["nonce"],
        "Ciphertext(base64)": out["ciphertext"],
        "AAD_len": (len(aad) if aad else 0)
    }
    if ephemeral_pass is not None:
        details["ephemeral_password"] = ephemeral_pass
    if ephemeral_salt is not None:
        details["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt).decode()

    log_crypto_event(
        operation="Encrypt",
        algorithm="ChaCha20-Poly1305",
        mode="Poly1305",
        ephemeral_key=key,
        details=details,
        ephemeral=True
    )
    return out


def decrypt_chacha20poly1305(enc_dict: Dict[str, str], key: bytes, aad: Optional[bytes] = None) -> bytes:
    import base64
    nonce = base64.b64decode(enc_dict["nonce"])
    ciphertext = base64.b64decode(enc_dict["ciphertext"])

    log_crypto_event(
        operation="Decrypt",
        algorithm="ChaCha20-Poly1305",
        mode="Poly1305",
        ephemeral_key=key,
        details={
            "Nonce(base64)": enc_dict["nonce"],
            "Ciphertext(base64)": enc_dict["ciphertext"],
            "AAD_len": (len(aad) if aad else 0)
        },
        ephemeral=True
    )

    cipher = ChaCha20Poly1305(key)
    plaintext = cipher.decrypt(nonce, ciphertext, aad if aad else b"")
    return plaintext


def derive_or_recover_key(password: str,
                          salt: Optional[bytes] = None,
                          ephemeral: bool = False,
                          time_cost: int = 3,
                          memory_cost: int = 65536,
                          parallelism: int = 4) -> Tuple[bytes, bytes]:
    """
    Wrapper: generate salt if missing; derive 32-byte key using Argon2id RAW.
    """
    if salt is None:
        salt = os.urandom(16)

    if ephemeral:
        log_debug(f"Using ephemeral password='{password}' (raw).", level="INFO", component="CRYPTO")
    else:
        log_debug(f"Using user-provided password='{password}' (raw).", level="INFO", component="CRYPTO")

    key = derive_key_argon2id(
        password=password,
        salt=salt,
        ephemeral=ephemeral,
        time_cost=time_cost,
        memory_cost=memory_cost,
        parallelism=parallelism
    )
    return key, salt

################################################################################
# END OF FILE: "CipherForge.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\CipherForge.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\CipherForge.cpython-313.pyc
# SIZE: 9949 bytes
# HASH: 40d8c40fe825e38f9418de8c2f2f60565b6e2695e54cbb6d3fdcc77b4e0005b4
# MODIFIED: 2025-08-29T04:23:39.246187
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\CipherForge.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\SSS.cpython-312.pyc
# SIZE: 8312 bytes
# HASH: f596bae8828ded44208474cb5a1407ed0768451157c8c8d47d0e1ab367fe1058
# MODIFIED: 2025-08-27T02:19:20.993248
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\SSS.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_backend.cpython-312.pyc
# SIZE: 1265 bytes
# HASH: a925ced15a90c0ecaf688dbf3254ba7ca5dd3a4cf1ad2dc87b316b778d5d529e
# MODIFIED: 2025-08-27T02:19:20.994254
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_backend.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_backend.cpython-313.pyc
# SIZE: 1271 bytes
# HASH: 0b5c7ce13bfa48c5aba756171939393368d08434e7e4549f216d784a47d95724
# MODIFIED: 2025-08-27T02:19:20.994254
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_backend.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_impl.cpython-312.pyc
# SIZE: 18312 bytes
# HASH: 1b8187bd5fc48d7265335b27ffd844347983d77a21b8cf17fe921bd8aebe611e
# MODIFIED: 2025-08-27T02:19:20.994254
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_impl.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_impl.cpython-313.pyc
# SIZE: 3052 bytes
# HASH: f45ce81c8d9b768780878a6dfcbef9311b432132b5e3795ee22d23f5f3ee5d9b
# MODIFIED: 2025-08-27T02:19:20.995605
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aead_impl.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aes_gcm_impl.cpython-312.pyc
# SIZE: 12732 bytes
# HASH: ded15da86ebca8722c16e9ffa773d5b2f6ae39e4109fafb595d66cf910a6d18a
# MODIFIED: 2025-08-27T02:19:20.995605
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aes_gcm_impl.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aes_impl.cpython-312.pyc
# SIZE: 12277 bytes
# HASH: 124c556b9c18345a1706799255a0f76d694f7c16127b43a49e31df8de464da2b
# MODIFIED: 2025-08-27T02:19:20.996612
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\aes_impl.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_impl.cpython-312.pyc
# SIZE: 5556 bytes
# HASH: 65715700f0c44747c703df789b305ff05fc2f560ccb666d0ebe92114c9e36629
# MODIFIED: 2025-08-27T02:19:20.996612
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_impl.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_impl.cpython-313.pyc
# SIZE: 5760 bytes
# HASH: f62cd3efbe355a4e6f66892f23b92c88abe19bd5349b1246c63c26fd7566b013
# MODIFIED: 2025-08-27T02:19:20.997738
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_impl.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_utils.cpython-312.pyc
# SIZE: 1758 bytes
# HASH: ec17991b6847f0b9b1ca801e9b85e4d5883f7d283ac5bd9cbff4f522bfe6f3a4
# MODIFIED: 2025-08-27T02:19:20.997738
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_utils.cpython-313.pyc
# SIZE: 1775 bytes
# HASH: 907a7eb688f0d910680c6dc84a70de9b44dc4406e43928848ea77625df2e18fe
# MODIFIED: 2025-08-27T02:19:20.997738
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\argon2_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\chacha_impl.cpython-312.pyc
# SIZE: 6415 bytes
# HASH: f5ce15f8c5ec8fe2364259a71b5532891ba9a429acc290f799be56d00222aac5
# MODIFIED: 2025-08-27T02:19:20.998743
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\chacha_impl.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\crypto_bridge.cpython-313.pyc
# SIZE: 18377 bytes
# HASH: c572c055391280ecadea466b1a28de87e422b5df6874536ba5be46068bea0a4f
# MODIFIED: 2025-08-28T23:23:27.792323
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\crypto_bridge.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\crypto_utils.cpython-312.pyc
# SIZE: 2891 bytes
# HASH: 7275101349f88c47ee3858b1d04da1c260d19d1082933f07695715ebc3725518
# MODIFIED: 2025-08-27T02:19:20.998743
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\crypto_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\debug_utils.cpython-312.pyc
# SIZE: 9224 bytes
# HASH: cbc5c45363cfb1f6ca27f90d633ab6fee330ceba34acde468e195bdf5c934b28
# MODIFIED: 2025-08-27T02:19:20.999743
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\debug_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\input_utils.cpython-312.pyc
# SIZE: 1434 bytes
# HASH: c7081f355ffb0f9e75f80441ad7ca20ff1b517dad46151a0a46333637d5d0172
# MODIFIED: 2025-08-27T02:19:20.999743
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\input_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\local_aead.cpython-312.pyc
# SIZE: 7404 bytes
# HASH: 89b9ebd596fa0e3c62d83d07211462ce4e250b91d209d41d8a28af09dc957e45
# MODIFIED: 2025-08-27T02:19:21.000742
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\local_aead.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\local_argon2.cpython-312.pyc
# SIZE: 7218 bytes
# HASH: 430e8f661d995c52eeecdabc6ee338a156eda58826e6eab61ae7115e13cc8919
# MODIFIED: 2025-08-27T02:19:21.000742
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\local_argon2.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\local_crypto.cpython-312.pyc
# SIZE: 1198 bytes
# HASH: 6462699611481b2872cb8f46da912d87a6c0a7756cdc04f1d32e7f2bf1fd13b3
# MODIFIED: 2025-08-27T02:19:21.001742
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\local_crypto.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\security_utils.cpython-312.pyc
# SIZE: 1837 bytes
# HASH: 34ed60480c98cd9ac278abd819df6f8acb73c365d03cbf2a449daf4e08394cbd
# MODIFIED: 2025-08-27T02:19:21.001742
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\security_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\split_utils.cpython-312.pyc
# SIZE: 1192 bytes
# HASH: d2097a4554e2ec5e22acbe025a4682248b6ebf301cbd286a60be27cc1b43d204
# MODIFIED: 2025-08-27T02:19:21.001742
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\split_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\ui_utils.cpython-312.pyc
# SIZE: 9567 bytes
# HASH: 585dd2b42a0d1dcf1e8c0046e3c7222c21124fafdcd73409fc77c227c248dc58
# MODIFIED: 2025-08-27T02:19:21.003246
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\__pycache__\ui_utils.cpython-312.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\example_questions25.json
# SIZE: 5841 bytes
# HASH: 473b8f0c072a023454e53dbb4322795e06fd0b509b45f59df1ef9d18af869875
# MODIFIED: 2025-08-27T02:19:21.003246
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[
  {
    "id": 1,
    "alternatives": [
      "Reading",
      "Painting",
      "Gardening",
      "Writing",
      "Cooking",
      "Playing Video Games",
      "Photography"
    ],
    "text": "What are your favorite hobbies?"
  },
  {
    "id": 2,
    "alternatives": [
      "Mathematics",
      "History",
      "Science",
      "Literature",
      "Physical Education",
      "Art",
      "Music"
    ],
    "text": "What is your favorite subject in school?"
  },
  {
    "id": 3,
    "alternatives": [
      "Spicy",
      "Sweet",
      "Savory",
      "Bitter",
      "Sour",
      "Umami",
      "Crunchy"
    ],
    "text": "What type of food do you like?"
  },
  {
    "id": 4,
    "alternatives": [
      "Car",
      "Bicycle",
      "Train",
      "Airplane",
      "Boat",
      "Motorcycle",
      "Walking"
    ],
    "text": "What is your favorite mode of transportation?"
  },
  {
    "id": 5,
    "alternatives": [
      "Spanish",
      "French",
      "Japanese",
      "German",
      "Mandarin",
      "Italian",
      "Arabic"
    ],
    "text": "Which language(s) would you like to learn?"
  },
  {
    "id": 6,
    "alternatives": [
      "Beaches",
      "Mountains",
      "Forests",
      "Cities",
      "Historical Sites",
      "Deserts",
      "Lakes"
    ],
    "text": "What kind of places do you enjoy visiting?"
  },
  {
    "id": 7,
    "alternatives": [
      "Tea",
      "Coffee",
      "Juice",
      "Smoothies",
      "Soda",
      "Water",
      "Energy Drinks"
    ],
    "text": "What kind of beverages do you prefer?"
  },
  {
    "id": 8,
    "alternatives": [
      "Red",
      "Blue",
      "Green",
      "Yellow",
      "Purple",
      "Black",
      "White"
    ],
    "text": "Which color(s) do you like the most?"
  },
  {
    "id": 9,
    "alternatives": [
      "Action",
      "Comedy",
      "Horror",
      "Drama",
      "Science Fiction",
      "Fantasy",
      "Documentary"
    ],
    "text": "What kind of movies do you enjoy?"
  },
  {
    "id": 10,
    "alternatives": [
      "Board Games",
      "Card Games",
      "Video Games",
      "Puzzles",
      "Sports",
      "Trivia",
      "Role-Playing Games"
    ],
    "text": "What type of games do you like to play?"
  },
  {
    "id": 11,
    "alternatives": [
      "Guitar",
      "Piano",
      "Violin",
      "Drums",
      "Flute",
      "Saxophone",
      "Trumpet"
    ],
    "text": "What kind of music instruments do you enjoy playing or listening to?"
  },
  {
    "id": 12,
    "alternatives": [
      "Rose",
      "Tulip",
      "Sunflower",
      "Daisy",
      "Orchid",
      "Lily",
      "Jasmine"
    ],
    "text": "What are your favorite types of flowers?"
  },
  {
    "id": 13,
    "alternatives": [
      "Casual",
      "Formal",
      "Sportswear",
      "Traditional",
      "Outdoor Gear",
      "Party Wear",
      "Vintage"
    ],
    "text": "What kind of clothes do you prefer wearing?"
  },
  {
    "id": 14,
    "alternatives": [
      "Dog",
      "Cat",
      "Bird",
      "Fish",
      "Rabbit",
      "Reptile",
      "Hamster"
    ],
    "text": "What kind of pets would you like to have?"
  },
  {
    "id": 15,
    "alternatives": [
      "Ice Cream",
      "Cake",
      "Cookies",
      "Brownies",
      "Cheesecake",
      "Pudding",
      "Pie"
    ],
    "text": "What is your favorite type of dessert?"
  },
  {
    "id": 16,
    "alternatives": [
      "Engineering",
      "Medicine",
      "Teaching",
      "Design",
      "Business",
      "Science",
      "Arts"
    ],
    "text": "What type of jobs or careers are you interested in?"
  },
  {
    "id": 17,
    "alternatives": [
      "Coffee",
      "Tea",
      "Juice",
      "Smoothies",
      "Soda",
      "Water",
      "Wine"
    ],
    "text": "What are your favorite kinds of drinks?"
  },
  {
    "id": 18,
    "alternatives": [
      "Mountains",
      "Beaches",
      "Forests",
      "Deserts",
      "Lakes",
      "Grasslands",
      "Waterfalls"
    ],
    "text": "What kind of landscapes do you find most beautiful?"
  },
  {
    "id": 19,
    "alternatives": [
      "Apple",
      "Banana",
      "Mango",
      "Strawberry",
      "Grapes",
      "Pineapple",
      "Orange"
    ],
    "text": "What are your favorite fruits to eat?"
  },
  {
    "id": 20,
    "alternatives": [
      "Malls",
      "Local Markets",
      "Boutiques",
      "Online Stores",
      "Supermarkets",
      "Specialty Shops",
      "Thrift Stores"
    ],
    "text": "What kind of places do you like to shop at?"
  },
  {
    "id": 21,
    "alternatives": [
      "Dolphins",
      "Wolves",
      "Elephants",
      "Hawks",
      "Penguins"
    ],
    "text": "What kind of animals do you find fascinating?"
  },
  {
    "id": 22,
    "alternatives": [
      "Coffee",
      "Juice",
      "Tea",
      "Soda"
    ],
    "text": "What is your favorite type of beverage?"
  },
  {
    "id": 23,
    "alternatives": [
      "Mountains",
      "Forests",
      "Beaches",
      "Waterfalls",
      "Lakes",
      "Deserts",
      "Ice Caves"
    ],
    "text": "Which outdoor place(s) would you love to explore?"
  },
  {
    "id": 24,
    "alternatives": [
      "Italian",
      "Japanese",
      "Indian"
    ],
    "text": "What is your favorite type of cuisine?"
  },
  {
    "id": 25,
    "alternatives": [
      "Running",
      "Yoga",
      "Weightlifting",
      "Cycling",
      "Swimming",
      "Hiking"
    ],
    "text": "Which kind of exercise do you enjoy doing?"
  }
]



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\example_questions25.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-17-30.json
# SIZE: 600 bytes
# HASH: b02b209e80395dc4ee2e4caab6376e33ff3dac2d520fa405d47f6209862399d4
# MODIFIED: 2025-08-27T02:19:21.005252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-22T04:17:30.872321",
  "run_id": "238ccc0a-1b7d-4efa-89ae-cc209f0329b0",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-08-22T04:17:30.873737",
  "run_id": "238ccc0a-1b7d-4efa-89ae-cc209f0329b0",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Missing required files",
  "details": {
    "missing": [
      "modules/SSS.py"
    ]
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-17-30.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-17-30.txt
# SIZE: 208 bytes
# HASH: 2c2ceb12612a44333c53183bd90541c559e0993dd3d58d43214ea4877c2ff9aa
# MODIFIED: 2025-08-27T02:19:21.005252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-22T04:17:30.872321] [INFO] [SYSTEM] Start new run (run_id=238ccc0a-1b7d-4efa-89ae-cc209f0329b0)
[2025-08-22T04:17:30.873737] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Missing required files



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-17-30.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-24-33.json
# SIZE: 238 bytes
# HASH: 443b78e2d341f0c2ff502e7cf17a11470a8a4d4a21db0087ab117aaa0e78f72f
# MODIFIED: 2025-08-27T02:19:21.006252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-22T04:24:33.752738",
  "run_id": "f697e96c-80e4-4d44-a143-dbdfcd1c8be5",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-24-33.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-24-33.txt
# SIZE: 106 bytes
# HASH: 81af8a01b51c19b4e70b8384a062e1892031e9f14c7cfe3db3495150ebbf85a1
# MODIFIED: 2025-08-27T02:19:21.006252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-22T04:24:33.752738] [INFO] [SYSTEM] Start new run (run_id=f697e96c-80e4-4d44-a143-dbdfcd1c8be5)



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-24-33.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-29-02.json
# SIZE: 238 bytes
# HASH: 64b29a90da840d334aaeb21bd29435f28b187e7640434a1e9099fd5d30c168da
# MODIFIED: 2025-08-27T02:19:21.007251
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-22T04:29:02.885267",
  "run_id": "b4ce6d47-191a-498d-bd56-b5a02755bb25",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-29-02.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-29-02.txt
# SIZE: 106 bytes
# HASH: 2396ccdb73958b90c09b14ef1afa0c4cd37cf84c85f5b0eeedbe20b9041f51bf
# MODIFIED: 2025-08-27T02:19:21.007251
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-22T04:29:02.885267] [INFO] [SYSTEM] Start new run (run_id=b4ce6d47-191a-498d-bd56-b5a02755bb25)



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-29-02.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-30-54.json
# SIZE: 161783 bytes
# HASH: 1c5959ae74914fa32988cca54f05b83d3988a303b4e86a0b11f37497aa5c7776
# MODIFIED: 2025-08-27T02:19:21.008251
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-22T04:30:54.712319",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-08-22T04:36:42.580644",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Counts computed for kit build.",
  "details": {
    "total_correct": 10,
    "total_alternatives": 29,
    "total_incorrect": 19
  }
}
{
  "timestamp": "2025-08-22T04:36:48.830148",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using PAD size: 128",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.399805",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Argon2id parameters confirmed for kit.",
  "details": {
    "time_cost": 3,
    "memory_cost": 65536,
    "parallelism": 4
  }
}
{
  "timestamp": "2025-08-22T04:37:01.401558",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Splitting real secret: correct_count=10, threshold=6, pad=128",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.404250",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() via node-bridge",
  "details": {
    "secret_len": 16,
    "shares": 10,
    "threshold": 6,
    "pad": 128
  }
}
{
  "timestamp": "2025-08-22T04:37:01.473626",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() complete.",
  "details": {
    "share_len": 129,
    "xcoords": [
      193,
      62,
      25,
      236,
      12,
      151,
      231,
      198,
      47,
      45
    ],
    "sample_share_hashes": [
      "24e8d081a4710d072f3f786b55b0bed7c875f210a9176d7675f79d16055bad4c",
      "01bcda15f1736c0911dbeb2988ae15e44836c6df104651b6b492711892d5cad5",
      "e5d03d09b33574ad4845c39fe1cf25c9e6a2501c089fd8e19064ba0b5f37a1c5"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:37:01.474437",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() via node-bridge",
  "details": {
    "secret_len": 16,
    "shares": 10,
    "threshold": 6,
    "pad": 128
  }
}
{
  "timestamp": "2025-08-22T04:37:01.537361",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() complete.",
  "details": {
    "share_len": 129,
    "xcoords": [
      215,
      14,
      155,
      55,
      117,
      219,
      94,
      167,
      66,
      98
    ],
    "sample_share_hashes": [
      "4a618328067a7df43f1aa9ff7a494dad4e28b3ac0495fdffe79ec87c2f74f619",
      "38a01becef475c4797b30116a69d017d82d6fc50a1ad32417272b72a1b39c424",
      "a8e98d9b4f8363a0fd892ddf26c3d7d7808ee1ae1e1c84ee71bfa53b537a7ef0"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:37:01.538091",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() via node-bridge",
  "details": {
    "secret_len": 16,
    "shares": 10,
    "threshold": 6,
    "pad": 128
  }
}
{
  "timestamp": "2025-08-22T04:37:01.600308",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() complete.",
  "details": {
    "share_len": 129,
    "xcoords": [
      52,
      34,
      199,
      115,
      75,
      127,
      70,
      93,
      8,
      108
    ],
    "sample_share_hashes": [
      "42a9f4a0c946ffdb906805647b586340eba56d5f924381a824333498bee02c27",
      "7aa06771d0b57783c0387e5337bfc00990371bf75e7fa6cbeb881c6e8866d618",
      "25817f8da14a8aca450b4e504c2e481408102bd9199db3751b81bf872d692ffb"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:37:01.601060",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "SSS split summary (beta clear logging).",
  "details": {
    "share_len": 129,
    "pad": 128,
    "threshold": 6,
    "real_count": 10,
    "dummy_count": 19,
    "real_xcoords": [
      193,
      62,
      25,
      236,
      12,
      151,
      231,
      198,
      47,
      45
    ],
    "dummy_xcoords": [
      215,
      14,
      155,
      55,
      117,
      219,
      94,
      167,
      66,
      98,
      52,
      34,
      199,
      115,
      75,
      127,
      70,
      93,
      8
    ],
    "real_share_sha3_256": [
      "24e8d081a4710d072f3f786b55b0bed7c875f210a9176d7675f79d16055bad4c",
      "01bcda15f1736c0911dbeb2988ae15e44836c6df104651b6b492711892d5cad5",
      "e5d03d09b33574ad4845c39fe1cf25c9e6a2501c089fd8e19064ba0b5f37a1c5",
      "4cf1b5b76445390a5a77f26158ab4fbf2d0e28178a58c5f5356ed38f37d2f0aa",
      "791739e4250c3a5dee47ed2c7e3a153d4d861a9eeb825f44f54f9c5faae54a75",
      "3946323d93a4b77af6936b3aa02d49003b9e360967e104ccfb2128b0f1130dd4",
      "c61f095778e7c892b9a370d6409f231508b3358c684b57f6847b40c08377549d",
      "e3f2d53afa02e173ddf0f01e369f7b5afacbb59cf7a85d06e78ad766158541a5",
      "430a09b6e025944d563bfbc3aeed5f1dc568b6be285940cc86a8335b242f9286",
      "a457f3f203f4e987166497b72afd4f11e4aad1a17be3c2f4967ee496393a9b2b"
    ],
    "dummy_share_sha3_256": [
      "4a618328067a7df43f1aa9ff7a494dad4e28b3ac0495fdffe79ec87c2f74f619",
      "38a01becef475c4797b30116a69d017d82d6fc50a1ad32417272b72a1b39c424",
      "a8e98d9b4f8363a0fd892ddf26c3d7d7808ee1ae1e1c84ee71bfa53b537a7ef0",
      "144e6be4f6077b1ac06cc72f543477e48a7f391913ee3a39873b63fb80923d69",
      "9995861a0ddcfa1ce41fe84dc878598745a9e87c60b6c01af7d29239699a4be8",
      "5c0acdcab2e8b989d925b76de01d8e9e98e149459ec695fc14f4d2c37d420997",
      "9c001d768db4062bd2426877607e6449cc791cc213951cd3ae4e93cd55ae74fc",
      "bbcc2d4a16e8ac021f42403419883e9ce86281a0e5643c9ab0708b4c2c4c9b62",
      "dd93f5ec304ba741732927664c06d37b5b3f44237d48395a022d509cb035860c",
      "801635ff0ab6b7c4ea67e15d4c484895fb0b0774ddf0727f748546c884fd4a1c",
      "42a9f4a0c946ffdb906805647b586340eba56d5f924381a824333498bee02c27",
      "7aa06771d0b57783c0387e5337bfc00990371bf75e7fa6cbeb881c6e8866d618",
      "25817f8da14a8aca450b4e504c2e481408102bd9199db3751b81bf872d692ffb",
      "8d142b63d51a64c31f0be2ee51d8062b7af6c86734a9a130f7a59292923cee95",
      "dc6d1456bdf3a060e44b85c96f6065756b482b70b57ead7793ff3d6029da1b92",
      "ed0da14875a859ec16b155329b273fce15c9b0403b966702d284a67200a0ea3c",
      "e7550bd423e145cc463fd95f55abbd6b22d068c2078fefeec515f4cbb6e69789",
      "5c1133d09a7448481d7a62e411777301c1a0134264ef99008be6263b49922e0f",
      "410b1de9fd8f3eca0b4c9a66e2b60c1d345e8572dab773f3bebddaa924cc6644"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:37:01.602905",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Ida' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.603422",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Ida', salt(b64)='at+ha3HMKCBc5AFD5JkxUA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.656109",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "at+ha3HMKCBc5AFD5JkxUA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "x4IqIH9qKfbU1bCu1u8PDqrHBqtE2gvV1vW0LoR0PJQ=",
      "derived_key_b64": "x4IqIH9qKfbU1bCu1u8PDqrHBqtE2gvV1vW0LoR0PJQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.658656",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "HND8aXU9BCuOBWdb",
    "Ciphertext(base64)": "b+U6ZpDcPrv0XLBS5AYLGMDN3WLs+mVwAtqiiOCrq/atTm+S3aOAwcA5QWsPWf7f/mKLSIRUuJX3W/m3/pSFDA3IcID79EXdu4KnpCFtjsaE0qjg1KFPEkZMpQDxPhGzx09KFOel+Svk8jhPDABtPAc9roPXQhFeMmy1kws9BtBu",
    "Tag(base64)": "uz0zt4/Mr0UjY1J4CCb/Vw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "x4IqIH9qKfbU1bCu1u8PDqrHBqtE2gvV1vW0LoR0PJQ="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.659235",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "24e8d081a4710d072f3f786b55b0bed7c875f210a9176d7675f79d16055bad4c",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "HND8aXU9BCuOBWdb",
    "tag_b64": "uz0zt4/Mr0UjY1J4CCb/Vw==",
    "salt_b64": "at+ha3HMKCBc5AFD5JkxUA==",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_hash": "4ebdb27ad79cc9343a33d3dcaab205a95203f667f20c5eccdcd0c01abbec7db3",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:01.659740",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Ida",
    "alt_hash": "4ebdb27ad79cc9343a33d3dcaab205a95203f667f20c5eccdcd0c01abbec7db3",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.660239",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Jocke' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.660732",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Jocke', salt(b64)='uGO6g4c43LguixZsHbOuHw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.712234",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "uGO6g4c43LguixZsHbOuHw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "YWWagx/T6r2TKrMDEvynau3D5drfiAnc5laCVUmZewE=",
      "derived_key_b64": "YWWagx/T6r2TKrMDEvynau3D5drfiAnc5laCVUmZewE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.713533",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "DAnFDpy7WH1VrIVX",
    "Ciphertext(base64)": "GG/G2IxTPjD4Cd9vGPbt7s4eLkRW8gPQ3ZSnbO0h459yQxJazWBFBXqqqK1k0TG6QZOw0bnUvKVUrsMB4+QUppRARr9Miu9cQ5WsznKlKJQWKpK5JN73agXgsScqcnkFuZZ7hAULdnSdcCnlsyZ/JMeBfbElg9bZ0XSUtTYYZ+kdpqqPfN3aX2Iy0yOF0WcPtg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "YWWagx/T6r2TKrMDEvynau3D5drfiAnc5laCVUmZewE="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.714055",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "4a618328067a7df43f1aa9ff7a494dad4e28b3ac0495fdffe79ec87c2f74f619",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "DAnFDpy7WH1VrIVX",
    "tag_b64": null,
    "salt_b64": "uGO6g4c43LguixZsHbOuHw==",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_hash": "94d32debe85b7fa1238a99931a7ee70d77b304123ea7a0c26c3b852c7778b08c",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:01.714532",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Jocke",
    "alt_hash": "94d32debe85b7fa1238a99931a7ee70d77b304123ea7a0c26c3b852c7778b08c",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.715052",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Nina' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.715512",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Nina', salt(b64)='AAm/1zbjRhzTtRuNj3/GFA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.766579",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "AAm/1zbjRhzTtRuNj3/GFA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "1BWbo6YvM3XskoHJ4MAWPzYyG+krRNv/AZH+sD7OAQg=",
      "derived_key_b64": "1BWbo6YvM3XskoHJ4MAWPzYyG+krRNv/AZH+sD7OAQg=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.767766",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "I3F1N3pzzf7Ecib3",
    "Ciphertext(base64)": "5dZxEo8JSP6hHqKFIyJRL4vT06WxJkCQ7Fp/qBI49CxT8ZPdNC93iQ08XnUUIeryRm+kZBkY8o8V7ULJhrablNtgnpYd/yMC+31Bo87dgybWBlOI4t2Vhord46iXJoJ4q34E9t2+xwY/TYJU1OU/K7i/LnhNMcvnA9L2mCq6W5r+8D6tzZx3P1fDv+pNYuX68g==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "1BWbo6YvM3XskoHJ4MAWPzYyG+krRNv/AZH+sD7OAQg="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.768355",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "38a01becef475c4797b30116a69d017d82d6fc50a1ad32417272b72a1b39c424",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "I3F1N3pzzf7Ecib3",
    "tag_b64": null,
    "salt_b64": "AAm/1zbjRhzTtRuNj3/GFA==",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_hash": "a438b04f1ba339d76d92601ac13f80fc0e532270a8dc96f5f17b2a7a7a429055",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:01.768849",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Nina",
    "alt_hash": "a438b04f1ba339d76d92601ac13f80fc0e532270a8dc96f5f17b2a7a7a429055",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.769346",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Pelle' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.769857",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Pelle', salt(b64)='l+5pMp3ySR96+3XKmvQ6og=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.821515",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "l+5pMp3ySR96+3XKmvQ6og==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "6BDu/IqpleTdhVX3gQ54e6RmCuNncwfa5Qo4IiR3Flg=",
      "derived_key_b64": "6BDu/IqpleTdhVX3gQ54e6RmCuNncwfa5Qo4IiR3Flg=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.822857",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "dqktEtuG6fwnD1Eo",
    "Ciphertext(base64)": "u3KK3J5a0n8hw9ax0xKa+P5zBS9bAF3b8i/Gw3plSzq1cvRhuCtVzb4dvrXCYyKOVdz0vmPu5dZJ2OCe9Nm+pm/8wfNP7W6kEYeAfzUHVgM7vpNHaaMMIPhZxIiSzM+WgtRSBY0iTEHOtzH/Rtc6Uxd4uNU6+pXCigvWKMdv/N/jiVl4m+N4nJ84LwNtuSGOBA==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "6BDu/IqpleTdhVX3gQ54e6RmCuNncwfa5Qo4IiR3Flg="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.823402",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "a8e98d9b4f8363a0fd892ddf26c3d7d7808ee1ae1e1c84ee71bfa53b537a7ef0",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "dqktEtuG6fwnD1Eo",
    "tag_b64": null,
    "salt_b64": "l+5pMp3ySR96+3XKmvQ6og==",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_hash": "d44afb49baecf58e2bfd4a28face89c5bc162e5d3089ad5b317bae6395e6621f",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:01.823912",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Pelle",
    "alt_hash": "d44afb49baecf58e2bfd4a28face89c5bc162e5d3089ad5b317bae6395e6621f",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.824439",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Sara' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.824914",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Sara', salt(b64)='e1byzifS8aY4XBisb9yBBQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.876696",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "e1byzifS8aY4XBisb9yBBQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "MbC933hkXuyX1T0AANUI+jaf0Y4XwBfIkCWaXwsOFFM=",
      "derived_key_b64": "MbC933hkXuyX1T0AANUI+jaf0Y4XwBfIkCWaXwsOFFM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.878007",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "xlDrL8+rq1+AETK/",
    "Ciphertext(base64)": "vUnfVS2Gm8TTRaVltaczV+/1N8Ua0zcBjval/N21sjsWi1ucOZndo6Q4ac51e9d88RDP4qGA+PifBScgpaFl73hig9igG4LMypl+mtfDriFL/DMqqlp3QHcw6ATvQSsMfMkfCcEOn75jyvsCkDu8jZypMgH2j0SbgjwDob38ZRha",
    "Tag(base64)": "8CnvkPTM6pKSwxq7SydiJg==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "MbC933hkXuyX1T0AANUI+jaf0Y4XwBfIkCWaXwsOFFM="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.878547",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "144e6be4f6077b1ac06cc72f543477e48a7f391913ee3a39873b63fb80923d69",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "xlDrL8+rq1+AETK/",
    "tag_b64": "8CnvkPTM6pKSwxq7SydiJg==",
    "salt_b64": "e1byzifS8aY4XBisb9yBBQ==",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_hash": "720d6a275b624a1d13fef08110131c1ce87a2e6958ab2ce0648500dc5d99a5df",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:01.879055",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Sara",
    "alt_hash": "720d6a275b624a1d13fef08110131c1ce87a2e6958ab2ce0648500dc5d99a5df",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.879554",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Tilde' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.880041",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Tilde', salt(b64)='2881ceX56sVhOWdpEX9Uyw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.932065",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "2881ceX56sVhOWdpEX9Uyw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "1HrK/9SWbdCtvHCeq3tGA+/dBhBPofQV+8OZHFhHCUM=",
      "derived_key_b64": "1HrK/9SWbdCtvHCeq3tGA+/dBhBPofQV+8OZHFhHCUM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.933638",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "a0imCq20jOX00Yur",
    "Ciphertext(base64)": "lFtCVcpDoFBpguxf0pAoJlqgrvraNj0exIhg12B3GgGFk4Qt+Vqi0JSb2GBksDfN9tQWiOINB9khlGFC/A2B4sMDknvmMQc/nKJgagpK6oX8+I9ksZ1fygjJg9Gfk5yvC3Rqufe8KKjT5CACakJA2l1vDJhd3H3JFB8q4TnTUEe+",
    "Tag(base64)": "7zOmFUZojkORVeK1mCFAFg==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "1HrK/9SWbdCtvHCeq3tGA+/dBhBPofQV+8OZHFhHCUM="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.934182",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "01bcda15f1736c0911dbeb2988ae15e44836c6df104651b6b492711892d5cad5",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "a0imCq20jOX00Yur",
    "tag_b64": "7zOmFUZojkORVeK1mCFAFg==",
    "salt_b64": "2881ceX56sVhOWdpEX9Uyw==",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_hash": "9c73d3cd125fffceaada186b00a9f4bf51e61924be1380fad78b9351a2fbf745",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:01.934660",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Tilde",
    "alt_hash": "9c73d3cd125fffceaada186b00a9f4bf51e61924be1380fad78b9351a2fbf745",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.935174",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='22' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.935632",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='22', salt(b64)='9pQnm9ZoZmGm9nn1bCPEgA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.987939",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "9pQnm9ZoZmGm9nn1bCPEgA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "PAVTSNk08Atr6s9qH/jzxRBBpTxx8uno/5+Jf3uxx6U=",
      "derived_key_b64": "PAVTSNk08Atr6s9qH/jzxRBBpTxx8uno/5+Jf3uxx6U=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.989125",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "GkuspW38XWwggnFe",
    "Ciphertext(base64)": "IIGp3A5p109FPH3b7V73Zq7Ibt06xq/+WVr5At71W8i60xW2scYzZP4gzsJzZgeWgPwt6SIosOWTCXucaMvnKNtnCL7Qq7mPclHLqrZjaagMuGtVB7OfIGMahw+gozF5yoBgo3x/HgwdjRyiYKxfpm/7w94hxIK/P1htQ/J3LZKHroYynYL3wuOJtmYLinV3zg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "PAVTSNk08Atr6s9qH/jzxRBBpTxx8uno/5+Jf3uxx6U="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:01.989658",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "9995861a0ddcfa1ce41fe84dc878598745a9e87c60b6c01af7d29239699a4be8",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "GkuspW38XWwggnFe",
    "tag_b64": null,
    "salt_b64": "9pQnm9ZoZmGm9nn1bCPEgA==",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_hash": "7b0155cb3acfe3a85ad60bcc83fecfc4e1d8e02077c5381f38f005b653ac4d18",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:01.990174",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_text": "22",
    "alt_hash": "7b0155cb3acfe3a85ad60bcc83fecfc4e1d8e02077c5381f38f005b653ac4d18",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:01.990721",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='25' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:01.991198",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='25', salt(b64)='3ZUQjJtqelYeqUASxExmWQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.044037",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "3ZUQjJtqelYeqUASxExmWQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "r4p/yZ6Ic4E3YdYLPBQVHfaw7EmKOvJBfaOD+16eHPk=",
      "derived_key_b64": "r4p/yZ6Ic4E3YdYLPBQVHfaw7EmKOvJBfaOD+16eHPk=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.045685",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "BPYHVh3EOPbur87I",
    "Ciphertext(base64)": "Ry1P2RlSvTFr6mSewQSoCBuzKwU1/UDw8wQbWJrWjICfYC0wyf4r7DuV5sLo0rQV8LGC0hHvw6PSyGgMoj4x05yYJ1aHemTtOm8xgyB1yEPJGWN18eAbgmgFBIrTgL39y2jh2TeCJRy3ALIxHatNr2JCn5lH+1x2gp3JzxlPlP54e3dZL/gwt25BzyCWoUFnHw==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "r4p/yZ6Ic4E3YdYLPBQVHfaw7EmKOvJBfaOD+16eHPk="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.046189",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "5c0acdcab2e8b989d925b76de01d8e9e98e149459ec695fc14f4d2c37d420997",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "BPYHVh3EOPbur87I",
    "tag_b64": null,
    "salt_b64": "3ZUQjJtqelYeqUASxExmWQ==",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_hash": "b352267a57dd104509e95f303563f93b81efd9192de32096a7cbdab6e09c03a4",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.046680",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_text": "25",
    "alt_hash": "b352267a57dd104509e95f303563f93b81efd9192de32096a7cbdab6e09c03a4",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.047171",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='21' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.047645",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='21', salt(b64)='uHqW/C0wI83sf6L0Xxv8Dg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.098558",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "uHqW/C0wI83sf6L0Xxv8Dg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "xKMgTVHJcYQBvUOn+LSluDsjPmP4ERamjcy8CgFl8WE=",
      "derived_key_b64": "xKMgTVHJcYQBvUOn+LSluDsjPmP4ERamjcy8CgFl8WE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.099696",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "yBAEw8/OkGeuj4En",
    "Ciphertext(base64)": "b1lMeWhR8LL9Zvxc9R0zgurjbPlE5q9zsvbjpWIGxluAqiabNPBD26JKr2Wy5MdoH7BQdiX7fPWI9dDqDN398D1qHreq2L9dMsM/FKJ9mCteLlq7XuGdahS44FrCagTTAfHQUkkruNdQtGRgdQ5z+jUUHdWvnDdLoFDzemlb6bRimVUNMJ+vjnSyc+Atmxvf7w==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "xKMgTVHJcYQBvUOn+LSluDsjPmP4ERamjcy8CgFl8WE="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.100307",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "e5d03d09b33574ad4845c39fe1cf25c9e6a2501c089fd8e19064ba0b5f37a1c5",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "yBAEw8/OkGeuj4En",
    "tag_b64": null,
    "salt_b64": "uHqW/C0wI83sf6L0Xxv8Dg==",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_hash": "7faeca1b13d1a7f909f21989ff203fa36abb4be730336186f9c49c6e56a890c0",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.100809",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_text": "21",
    "alt_hash": "7faeca1b13d1a7f909f21989ff203fa36abb4be730336186f9c49c6e56a890c0",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.101390",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='24' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.101868",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='24', salt(b64)='BJSCKXtZ+vBuAuyW2jv5Qg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.155714",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "BJSCKXtZ+vBuAuyW2jv5Qg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "vGmmDgyKCB8wMzAmJFtJJgai207CqDEDcGiHm32quJo=",
      "derived_key_b64": "vGmmDgyKCB8wMzAmJFtJJgai207CqDEDcGiHm32quJo=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.156932",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "OE7G3Uvc4YaeRzFu",
    "Ciphertext(base64)": "H1BiXylfwz0VnhwVKhkzeMiFbZoJMHpEc1acSyLeQSQZTFBLkCKbX6FL82uGJX4T/k0pc9SN+jbgEpU0JYVxZRiV/hmp7j9qieNiw6yGW3uh+b8g4VwJYV87eZuOOcSJC493EyRTp/SLq6ek4A+65SX0nCuyI0qLROtKOiTcE2UbnT+rpekBUiKTkTLrraH3OQ==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "vGmmDgyKCB8wMzAmJFtJJgai207CqDEDcGiHm32quJo="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.157567",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "9c001d768db4062bd2426877607e6449cc791cc213951cd3ae4e93cd55ae74fc",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "OE7G3Uvc4YaeRzFu",
    "tag_b64": null,
    "salt_b64": "BJSCKXtZ+vBuAuyW2jv5Qg==",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_hash": "12dfed132dd9b67a7b1111cfe4bfdc027784031f238ed3e64afd015cfff57bfd",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.158120",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_text": "24",
    "alt_hash": "12dfed132dd9b67a7b1111cfe4bfdc027784031f238ed3e64afd015cfff57bfd",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.158636",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='55' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.159104",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='55', salt(b64)='J5Le1+IRkYcXRC28dbPwRw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.211270",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "J5Le1+IRkYcXRC28dbPwRw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "FQCy4PqMLNh6gTWJzdpEnT4lw3ZYZHGX55knRzlym4A=",
      "derived_key_b64": "FQCy4PqMLNh6gTWJzdpEnT4lw3ZYZHGX55knRzlym4A=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.212668",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "aEnWDbGeekBoPpr4",
    "Ciphertext(base64)": "+alEqkOvxPRhDVSO4wdMzA1zBRl5HAkvf3n7AICxkE90CHJq/auP2aHv1VjOQ+IDyos1FxFRrkYAJ5CSowGkNuhUY3KK16R1WWySkYdb1+rz6/myaZr/7nUQeIOuSLW0x+f4Gi76S6J9JPG8mKxiGHW1FcflYGNVxamScGJOG/9v0bguCHp/2uKgh+RUgOF9Gg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "FQCy4PqMLNh6gTWJzdpEnT4lw3ZYZHGX55knRzlym4A="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.213282",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "bbcc2d4a16e8ac021f42403419883e9ce86281a0e5643c9ab0708b4c2c4c9b62",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "aEnWDbGeekBoPpr4",
    "tag_b64": null,
    "salt_b64": "J5Le1+IRkYcXRC28dbPwRw==",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_hash": "d28d958ef8a89d184cb9ab1660b3cf5b861f61d05b372f9934f320dcadca208a",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.213775",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_text": "55",
    "alt_hash": "d28d958ef8a89d184cb9ab1660b3cf5b861f61d05b372f9934f320dcadca208a",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.214292",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Beer' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.214777",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Beer', salt(b64)='Un56K1c2dYIDEWF2Ud58Mg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.266142",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "Un56K1c2dYIDEWF2Ud58Mg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "Xlwa4mxkrbGgs6kWcQrCYX1JT8E0EyCgKcylJNZsa5o=",
      "derived_key_b64": "Xlwa4mxkrbGgs6kWcQrCYX1JT8E0EyCgKcylJNZsa5o=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.267330",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "u+ie/RuoAbZm9ZgG",
    "Ciphertext(base64)": "Kk4l4aDRSD5K3oP37vHb0l2i1tVFgH6+/gsmny7BKCaJ+Rxv0x31zKGP2RrbvHkFkp3Lw++IVHhlfQ3S+pWgYDeFmNYzNeAoRPzRXhmHrO1hOmnmE0HGjo2BMBFxey+4wjV8svA9HN4lcbvQgBzs2eahKvwf7ydlgnNo/rgkkpGfR9BYzf5LWfPxhJ7bHPRNsA==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "Xlwa4mxkrbGgs6kWcQrCYX1JT8E0EyCgKcylJNZsa5o="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.267878",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "dd93f5ec304ba741732927664c06d37b5b3f44237d48395a022d509cb035860c",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "u+ie/RuoAbZm9ZgG",
    "tag_b64": null,
    "salt_b64": "Un56K1c2dYIDEWF2Ud58Mg==",
    "q_hash": "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457",
    "alt_hash": "c8860d8bbd081c4be6f6de3a651520257bfef1f5148fc3cf2176580337dfc38b",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.268441",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 3,
    "q_text": "Favourite food?",
    "q_hash": "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457",
    "alt_text": "Beer",
    "alt_hash": "c8860d8bbd081c4be6f6de3a651520257bfef1f5148fc3cf2176580337dfc38b",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.268996",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Whiskey' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.269474",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Whiskey', salt(b64)='tImc2eaS0btzQDYo9nLawQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.322200",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "tImc2eaS0btzQDYo9nLawQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "I4728xL4H2gLlnD5ms6WHvdKfFfrAZVN+u4ILQx1guo=",
      "derived_key_b64": "I4728xL4H2gLlnD5ms6WHvdKfFfrAZVN+u4ILQx1guo=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.323582",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "+fZngjCvUSvrSAg7",
    "Ciphertext(base64)": "dxlkBcx5nSF+Phvy+Md6hJIkYecFF+EZl66mnAUywPr0+d/e+eOSRpzCXgOkIALl4Fqq7sor064kIO5Sr8obHkHP7PQ8528+vClDhrZ5hrOMr67C8A/o2sZoPMRNEzpGmsnQJCLsaSV/hx2b66wMLSjWcv+EzNA1bjliF3t4Mt4B",
    "Tag(base64)": "OqXJFPoCQgTNpBxJXsl0Rw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "I4728xL4H2gLlnD5ms6WHvdKfFfrAZVN+u4ILQx1guo="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.324112",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "4cf1b5b76445390a5a77f26158ab4fbf2d0e28178a58c5f5356ed38f37d2f0aa",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "+fZngjCvUSvrSAg7",
    "tag_b64": "OqXJFPoCQgTNpBxJXsl0Rw==",
    "salt_b64": "tImc2eaS0btzQDYo9nLawQ==",
    "q_hash": "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457",
    "alt_hash": "845c7761756764853108d328038e0ef46a55399d0fc37f2fdb97fb583cb6a5e2",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.324677",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 3,
    "q_text": "Favourite food?",
    "q_hash": "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457",
    "alt_text": "Whiskey",
    "alt_hash": "845c7761756764853108d328038e0ef46a55399d0fc37f2fdb97fb583cb6a5e2",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.325247",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Blue' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.325727",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Blue', salt(b64)='r1nDOSINQ4hJmdU9wwOyHg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.376901",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "r1nDOSINQ4hJmdU9wwOyHg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "W9J07mR9hoLvlTWLDx6ZxvqHam9jgVn27P1EsaIT3aw=",
      "derived_key_b64": "W9J07mR9hoLvlTWLDx6ZxvqHam9jgVn27P1EsaIT3aw=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.378089",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "Hzu45I4kQiLQlySp",
    "Ciphertext(base64)": "FsaRxA+qsSZbwyYudGMt6qGOotr/053Xr/SgfMp0g+LoyqwshKxw5OjH1E2x0GB3F0OQ20WbUJPChpucmmYpMIsNi2qFUNWQzt+s0XPd51rBFaady98oaitFFOeE1lEXBVzue3MVCKA9onVfacIhRaJLZ4oZRPUrEXUn5Xw7QdWa",
    "Tag(base64)": "PtNNgkOHAbT8ZgN66M++VA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "W9J07mR9hoLvlTWLDx6ZxvqHam9jgVn27P1EsaIT3aw="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.378612",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "791739e4250c3a5dee47ed2c7e3a153d4d861a9eeb825f44f54f9c5faae54a75",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "Hzu45I4kQiLQlySp",
    "tag_b64": "PtNNgkOHAbT8ZgN66M++VA==",
    "salt_b64": "r1nDOSINQ4hJmdU9wwOyHg==",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_hash": "5c0281ed94de14b7dec231af9dfee812215110be11507e7220eb1ad753f2bfa2",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.379148",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 4,
    "q_text": "Favorite color?",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_text": "Blue",
    "alt_hash": "5c0281ed94de14b7dec231af9dfee812215110be11507e7220eb1ad753f2bfa2",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.379647",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Red' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.380110",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Red', salt(b64)='ynD93RiPZbx1sU1E87Kbhw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.433752",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "ynD93RiPZbx1sU1E87Kbhw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "xKHd+UmwjRW0G3W1KA5n7Gu3bVaHSMIdvEWVSmEMI7A=",
      "derived_key_b64": "xKHd+UmwjRW0G3W1KA5n7Gu3bVaHSMIdvEWVSmEMI7A=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.435087",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "eGfqdEKVCGto+Hi8",
    "Ciphertext(base64)": "Br6/SxQSVCzou2TzvpZdEIuSHYXF8eHRG7TiVQ7L18kXqy/QQT6Yg2EBJmkz1sYRxLqVcYh2AqwT2MxmVow7syZForUd+qtLOxK+tkVIZPb6PDJ6SKiTcj5dBFjBsxysA0SW0z8wbjSQRBKXXBgI9yKsXqGeKN4aRxq7nr5wRrVU",
    "Tag(base64)": "kRliPEv5goBywo8pyLtcBQ==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "xKHd+UmwjRW0G3W1KA5n7Gu3bVaHSMIdvEWVSmEMI7A="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.435598",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "801635ff0ab6b7c4ea67e15d4c484895fb0b0774ddf0727f748546c884fd4a1c",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "eGfqdEKVCGto+Hi8",
    "tag_b64": "kRliPEv5goBywo8pyLtcBQ==",
    "salt_b64": "ynD93RiPZbx1sU1E87Kbhw==",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_hash": "4c7ccc01415ad9e7341766087a5ef62fcc711acb2b0a711ddec7ef0d243f9ca0",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.436110",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 4,
    "q_text": "Favorite color?",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_text": "Red",
    "alt_hash": "4c7ccc01415ad9e7341766087a5ef62fcc711acb2b0a711ddec7ef0d243f9ca0",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.436607",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Green' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.437069",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Green', salt(b64)='BHCygJ4/RpqXRTKtxytytg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.491053",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "BHCygJ4/RpqXRTKtxytytg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "upfY04Arls+KHH1fZsvdTrkN5koYIdu9t/zB3F1kw2I=",
      "derived_key_b64": "upfY04Arls+KHH1fZsvdTrkN5koYIdu9t/zB3F1kw2I=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.492700",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "QRl0Wzl+52olY31j",
    "Ciphertext(base64)": "lqF5W40YEjwcJwtk8kBys4grq3tULa7FHAd7aLcnHpG4srqJ7mGGaJ9mIYNLYQpAncEYmgCNwdh1fe7Ddxwr9BFlWWYsdvK78cjOZWrLdkI52pIpoC79WZky91B9wehsd0ZmVKgBckVY3lmH1SQbcXSv81inTgCM9XFlCooVvArn",
    "Tag(base64)": "PiUU1X2Wg7niY6mXVua/fg==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "upfY04Arls+KHH1fZsvdTrkN5koYIdu9t/zB3F1kw2I="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.493270",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "42a9f4a0c946ffdb906805647b586340eba56d5f924381a824333498bee02c27",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "QRl0Wzl+52olY31j",
    "tag_b64": "PiUU1X2Wg7niY6mXVua/fg==",
    "salt_b64": "BHCygJ4/RpqXRTKtxytytg==",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_hash": "e13e6fb4233bfdc24750add243dc58bdf2622b6a452c24c1dc59f29621e0b0b9",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.493760",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 4,
    "q_text": "Favorite color?",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_text": "Green",
    "alt_hash": "e13e6fb4233bfdc24750add243dc58bdf2622b6a452c24c1dc59f29621e0b0b9",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.494332",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Coffee' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.494794",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Coffee', salt(b64)='IB4QSSs+nCEhac8p9MkrtQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.549799",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "IB4QSSs+nCEhac8p9MkrtQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "JNbXZJTQrGNbxSRxoVLlhF6oaOdPLz5/ZpzwaiGMeDc=",
      "derived_key_b64": "JNbXZJTQrGNbxSRxoVLlhF6oaOdPLz5/ZpzwaiGMeDc=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.551170",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "QVLHdqIazwU9I4C4",
    "Ciphertext(base64)": "jc0fPrQDJ2nl4PQ/waaBd60/Zf7wwTohuiX65KsTgIkzXe5MVFPD+/1PleNF4L+wkZQ7sa+7pW3I8u8hF21h0fPVLLlONjLoc6dn2RgO3Ws1C8RmLLem9zrNc5kT5U7VbCF89uIqU6tE4y8d51yB7bNuHBXUepzOlMA67batySFn",
    "Tag(base64)": "uSl8UYCyq0rjBjJDHd7LCQ==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "JNbXZJTQrGNbxSRxoVLlhF6oaOdPLz5/ZpzwaiGMeDc="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.551677",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "7aa06771d0b57783c0387e5337bfc00990371bf75e7fa6cbeb881c6e8866d618",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "QVLHdqIazwU9I4C4",
    "tag_b64": "uSl8UYCyq0rjBjJDHd7LCQ==",
    "salt_b64": "IB4QSSs+nCEhac8p9MkrtQ==",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_hash": "b362e24a8e89bc59ce20b7133dfc778d875bd831bd7b466b25e4860bca7fab21",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.552151",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 5,
    "q_text": "Coffee or tea?",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_text": "Coffee",
    "alt_hash": "b362e24a8e89bc59ce20b7133dfc778d875bd831bd7b466b25e4860bca7fab21",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.552702",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Tea' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.553174",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Tea', salt(b64)='oHN5LFd9/MSeVMPy9d5THg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.606440",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "oHN5LFd9/MSeVMPy9d5THg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "PZoDmBvvxz33n0a5bdBwgc4vY76cO8rArQfypm2WWB0=",
      "derived_key_b64": "PZoDmBvvxz33n0a5bdBwgc4vY76cO8rArQfypm2WWB0=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.607907",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "YPSggWVq6+IBs37+",
    "Ciphertext(base64)": "KdSgM1PWIt2/F8yy9tVcLO3HiiTEAAQUfNADSiVsM1fDJ9vNZp/ofT6stNGnk40BSSHaoVrbYiksfFUq0oqKAIGN+JKpejDl8K4YKeqH7tU+N2dJk1Imji5ZqbJu5Xw1qkXucfTQPD0D3k5JNo7XvuadlK3S6plk+mB0ldHZ/mYBFE7MTP6Dq5zixBYLHug3yg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "PZoDmBvvxz33n0a5bdBwgc4vY76cO8rArQfypm2WWB0="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.608459",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "25817f8da14a8aca450b4e504c2e481408102bd9199db3751b81bf872d692ffb",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "YPSggWVq6+IBs37+",
    "tag_b64": null,
    "salt_b64": "oHN5LFd9/MSeVMPy9d5THg==",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_hash": "70c94232744c44131a0c39a4f658e25a05587de8defe19885318688cdbe277b6",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.608962",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 5,
    "q_text": "Coffee or tea?",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_text": "Tea",
    "alt_hash": "70c94232744c44131a0c39a4f658e25a05587de8defe19885318688cdbe277b6",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.609498",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Neither' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.610021",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Neither', salt(b64)='fSXdF4LScPqOLDucFRulUg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.661488",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "fSXdF4LScPqOLDucFRulUg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "VO5Z8oOW48iQdKUfeycrx9OoodKHQrjG8Kyqxuinmkg=",
      "derived_key_b64": "VO5Z8oOW48iQdKUfeycrx9OoodKHQrjG8Kyqxuinmkg=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.662600",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "/QvC9tfRZqFUnZNm",
    "Ciphertext(base64)": "Pg6QhfjVD0a9o2h1cEAdpYReH39wzN5j+K4nY9asDOQRtbFxIMdnyFfyLb/xUqhfjMFLXTglItTTm9K1qUYKakD3pvneamL59Oyu8sjwnzPhxqY29PSU6pZOpUSJo2rIK1nx4Petv4oN5s7PoBvLJNg7bDhe4Cl1afE8kxH83bReGpe3Cm96PRjt88xeEun5Vw==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "VO5Z8oOW48iQdKUfeycrx9OoodKHQrjG8Kyqxuinmkg="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.663127",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "3946323d93a4b77af6936b3aa02d49003b9e360967e104ccfb2128b0f1130dd4",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "/QvC9tfRZqFUnZNm",
    "tag_b64": null,
    "salt_b64": "fSXdF4LScPqOLDucFRulUg==",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_hash": "4171acf02cac7ec5cf6a44e1182db37d85717f59bba578e7d8672cba248e9737",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.663606",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 5,
    "q_text": "Coffee or tea?",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_text": "Neither",
    "alt_hash": "4171acf02cac7ec5cf6a44e1182db37d85717f59bba578e7d8672cba248e9737",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.664120",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Summer' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.664639",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Summer', salt(b64)='fTBQ4mqznr+y+4SfYmX4jw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.717060",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "fTBQ4mqznr+y+4SfYmX4jw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "dh/uoTTqwnjG/BbyarKLjL1XR/E/Tzzz1IzoglB5Ll4=",
      "derived_key_b64": "dh/uoTTqwnjG/BbyarKLjL1XR/E/Tzzz1IzoglB5Ll4=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.718404",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "EBM4QvzeJZ1RIXwG",
    "Ciphertext(base64)": "+HtSLpptLj49KGZ4lWQOIuQi3OLxhFSEdRdzfRIwMGFqWwoIJDK3UkmbqZ+O3VjKLEm4PTm1NKMF8JfdJ2qKZ8PkaJ6/xDeTIh7M8dR7SRRbopU8WviQ1P2c/BmyWeThdyqd39eSaHKnbSFCAZZrKMLKgTZLuIQPnCcEswTtSqaB",
    "Tag(base64)": "J18dKrFcWOP02EtGmmfiRQ==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "dh/uoTTqwnjG/BbyarKLjL1XR/E/Tzzz1IzoglB5Ll4="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.718922",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "c61f095778e7c892b9a370d6409f231508b3358c684b57f6847b40c08377549d",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "EBM4QvzeJZ1RIXwG",
    "tag_b64": "J18dKrFcWOP02EtGmmfiRQ==",
    "salt_b64": "fTBQ4mqznr+y+4SfYmX4jw==",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_hash": "9907c6030df82cbd62fde09aa786273c6994dce03fc374e666fc08fa7996dbad",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.719395",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 6,
    "q_text": "Favorite season?",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_text": "Summer",
    "alt_hash": "9907c6030df82cbd62fde09aa786273c6994dce03fc374e666fc08fa7996dbad",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.719905",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Winter' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.720365",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Winter', salt(b64)='M9zHgyzKD9RLEOCFpmdGGA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.771946",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "M9zHgyzKD9RLEOCFpmdGGA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "4nS2RpnucGSGmha6kW2Qo8NBolo20eTH4ijiJcEyxPw=",
      "derived_key_b64": "4nS2RpnucGSGmha6kW2Qo8NBolo20eTH4ijiJcEyxPw=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.773064",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "h7ciSmugJAy05d5H",
    "Ciphertext(base64)": "3h8iPAP10EWJOpaBx9XgsKbLSr1f8va0QS920opwUMyit+d7K9UGU51CRUgPwMdtPnDtPQ6bSBkdBcgZ++o2+oW6rIgLOUUNd3nBpAMqTOa3ErEYFXiQd+nAimzhDX1fDlJe7gBpkANgQ8JBm5iU7cloAS9z62V0RTd52AnDhKB0z5DSGWA24vaW/ElMv0qxvg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "4nS2RpnucGSGmha6kW2Qo8NBolo20eTH4ijiJcEyxPw="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.773642",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "8d142b63d51a64c31f0be2ee51d8062b7af6c86734a9a130f7a59292923cee95",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "h7ciSmugJAy05d5H",
    "tag_b64": null,
    "salt_b64": "M9zHgyzKD9RLEOCFpmdGGA==",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_hash": "41f96a69c5a61e221c8854388b44cb18276831a63f2e5dc0f5978e91f36c70c0",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.774192",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 6,
    "q_text": "Favorite season?",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_text": "Winter",
    "alt_hash": "41f96a69c5a61e221c8854388b44cb18276831a63f2e5dc0f5978e91f36c70c0",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.774722",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Autumn' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.775209",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Autumn', salt(b64)='F3Lu4BYYZDifI/QT0iKs7A=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.826934",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "F3Lu4BYYZDifI/QT0iKs7A==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "ZbRvDnrixuX0PfdAIFDHmgMJWcum3wEtcOLJ7juKT2I=",
      "derived_key_b64": "ZbRvDnrixuX0PfdAIFDHmgMJWcum3wEtcOLJ7juKT2I=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.831508",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "EBAgJAahy0p75C75",
    "Ciphertext(base64)": "zY7Q4umBROxTxLIEwiGrPGj8RhabRpKGX7vBoEaLamE4CaBXzveh3N5ua7dfM5CPusDgv5Q9lzuL1aCMdEgSnfcvJVpRs+QIKwuVoXCPH0MIUt9koihXv3HXS/2yVycwmd+Wlj2c95UEo8n/3VZ+bz9HX2mRcxYscfgUsQQy+3QT",
    "Tag(base64)": "j9ZfrB0AO5SoPNQnlqIxhA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "ZbRvDnrixuX0PfdAIFDHmgMJWcum3wEtcOLJ7juKT2I="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.832022",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "dc6d1456bdf3a060e44b85c96f6065756b482b70b57ead7793ff3d6029da1b92",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "EBAgJAahy0p75C75",
    "tag_b64": "j9ZfrB0AO5SoPNQnlqIxhA==",
    "salt_b64": "F3Lu4BYYZDifI/QT0iKs7A==",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_hash": "9448466c7b558bd2c208ea29243cb833a74177138732908b44a824b4f013dd89",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.832509",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 6,
    "q_text": "Favorite season?",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_text": "Autumn",
    "alt_hash": "9448466c7b558bd2c208ea29243cb833a74177138732908b44a824b4f013dd89",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.833052",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Morning' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.833507",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Morning', salt(b64)='ZWyLWH7pMo6lBjw/IDe6bw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.883860",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "ZWyLWH7pMo6lBjw/IDe6bw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "zC67NKV+eryIvhrlz8EdT3TbJivN06UM6BwNdUKXApA=",
      "derived_key_b64": "zC67NKV+eryIvhrlz8EdT3TbJivN06UM6BwNdUKXApA=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.885030",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "ZdTpGNKbp/OeJFib",
    "Ciphertext(base64)": "Kf0tYfmzm80aq2kyj3fWlNEYk85PqA5kyegd5zbdsQffEnVBQd5E70CXCC19SkmJfvRkHN2FSuS1MOqcn976PCe4tKwG2roogTWRI6uV5VRmThd/uHt/a3X3XguAnGSwN+qEqktlukIEIh28C6J0urmV7ioFprikUTpZo16Ux728",
    "Tag(base64)": "U2dsTRAI3ZN7Qxe4WHZr3w==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "zC67NKV+eryIvhrlz8EdT3TbJivN06UM6BwNdUKXApA="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.885559",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "ed0da14875a859ec16b155329b273fce15c9b0403b966702d284a67200a0ea3c",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "ZdTpGNKbp/OeJFib",
    "tag_b64": "U2dsTRAI3ZN7Qxe4WHZr3w==",
    "salt_b64": "ZWyLWH7pMo6lBjw/IDe6bw==",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_hash": "8c6377c033507b593312dc5b7b51c3621b2425e90300332653fb6f01caec28a9",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:02.886137",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 7,
    "q_text": "Morning or night?",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_text": "Morning",
    "alt_hash": "8c6377c033507b593312dc5b7b51c3621b2425e90300332653fb6f01caec28a9",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.886648",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Night' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.887155",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Night', salt(b64)='6OcgSYx7r/EgrAo61HAjdA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.939986",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "6OcgSYx7r/EgrAo61HAjdA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "QDDaeawEpRPVERPM5m5SvxGzkhRO2NlI+1Zqp5UHL74=",
      "derived_key_b64": "QDDaeawEpRPVERPM5m5SvxGzkhRO2NlI+1Zqp5UHL74=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.941380",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "r27pAj5BnQO8WXl0",
    "Ciphertext(base64)": "XfOnnTX+YTC5pHpynqgI4V9fq8l8GRUuAYgbL6dPx1s/LrSFlJ+ZptRjTnGMjZcyRtTZVj4Yt0UH6QYZRIM7vnqOxQFO+skrvkpdkeKjYvtzH5M/1ZkQ4WOTsuatnlHbWvuUxZrat7eOZCAiYEqRGOvHxDt43jpOeBtiQPXndbUpF3HLEjq3hULh7ZY9bPecRg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "QDDaeawEpRPVERPM5m5SvxGzkhRO2NlI+1Zqp5UHL74="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.941910",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "e3f2d53afa02e173ddf0f01e369f7b5afacbb59cf7a85d06e78ad766158541a5",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "r27pAj5BnQO8WXl0",
    "tag_b64": null,
    "salt_b64": "6OcgSYx7r/EgrAo61HAjdA==",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_hash": "b2db95d12007266c42f6675a5ea2fad3bf3fe4db1622b93fcd7f7b875547fe8b",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.942390",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 7,
    "q_text": "Morning or night?",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_text": "Night",
    "alt_hash": "b2db95d12007266c42f6675a5ea2fad3bf3fe4db1622b93fcd7f7b875547fe8b",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.942868",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Both' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.943344",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Both', salt(b64)='8PR1mt/l8plExn1IJc6YJA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.994453",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "8PR1mt/l8plExn1IJc6YJA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "xCS+5of+YoZriylof9D77Bcu2OGKJUQ8AtZ9O8jt/ks=",
      "derived_key_b64": "xCS+5of+YoZriylof9D77Bcu2OGKJUQ8AtZ9O8jt/ks=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.995683",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "idnk6UGtJjFTTf+g",
    "Ciphertext(base64)": "CQHN/emIwq8C1zqeHWLVCM2CfR65C81oELzQEKsGnSi7KQkBz52f2KjW5dsoXYufCn48hrHIArdHy53I02BNOAvX0qFIJLVEJx1ABNJoVOmEsPmHtiO4kEparQyRLzxevKyGyJqkfiNRWsTJuJz4SZ7VeASmeQ0+xeCVDfPovwoX+x1JdNvCf3SsGplJfQbh+g==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "xCS+5of+YoZriylof9D77Bcu2OGKJUQ8AtZ9O8jt/ks="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:02.996213",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "430a09b6e025944d563bfbc3aeed5f1dc568b6be285940cc86a8335b242f9286",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "idnk6UGtJjFTTf+g",
    "tag_b64": null,
    "salt_b64": "8PR1mt/l8plExn1IJc6YJA==",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_hash": "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:02.996701",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 7,
    "q_text": "Morning or night?",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_text": "Both",
    "alt_hash": "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:02.997215",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Dogs' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:02.997687",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Dogs', salt(b64)='fvQD3H7R3V5FnfeQRcv7IQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.049330",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "fvQD3H7R3V5FnfeQRcv7IQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "6ehtYHUguxJMhtq0fL6UmBmuc6X/UMPOcrGFx3Lgg6g=",
      "derived_key_b64": "6ehtYHUguxJMhtq0fL6UmBmuc6X/UMPOcrGFx3Lgg6g=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.050783",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "SoAf0nPLg7thZ4n3",
    "Ciphertext(base64)": "DzG7Mg0nZw0+8pi1bvaU1Zq1rC8k8uKiEn/AOYdrBb2usFDIarXNBH/KgpceGkuaOkNY5D7TiwF91RmxTm+dIywFAu51u1vZrts6fev+J6xd/ouuMDAm27ve4QnDOehAxqJ/if9mzRb6T8OJsq1MN08gltIwBf0ulvaQUOHocQeSUXIvLcFcpb2uUSg0l4Xd4A==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "6ehtYHUguxJMhtq0fL6UmBmuc6X/UMPOcrGFx3Lgg6g="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.051320",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "e7550bd423e145cc463fd95f55abbd6b22d068c2078fefeec515f4cbb6e69789",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "SoAf0nPLg7thZ4n3",
    "tag_b64": null,
    "salt_b64": "fvQD3H7R3V5FnfeQRcv7IQ==",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_hash": "73ac37c5a3843f6165682d81e071892b6f33427ef9e03747e24b4e12b471aa00",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:03.051797",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 8,
    "q_text": "Dogs or cats?",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_text": "Dogs",
    "alt_hash": "73ac37c5a3843f6165682d81e071892b6f33427ef9e03747e24b4e12b471aa00",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:03.052305",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Cats' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.052772",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Cats', salt(b64)='SUxguW/kQ+y5PNglizwkmQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.111828",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "SUxguW/kQ+y5PNglizwkmQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "bN33k9B9pgjz7+CutFWmLymn+ZorLoCbb/c/56oeMNk=",
      "derived_key_b64": "bN33k9B9pgjz7+CutFWmLymn+ZorLoCbb/c/56oeMNk=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.112813",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "lt9E82wxl7joZ9S4",
    "Ciphertext(base64)": "ndZYMzuyurKFQHPucqlmoG8hn19/I+ESebr+7HNF9brnI49g80UNHeymXpmuaoBrZ6+PnnepvZyW1Vsk0Fg4xPmXVfaKLzF/Qgrrai6LHw2AFw5HJSKx7rNnxLGbnVanK4ldp2qtfRh6GRXWTdRv451RFyaQyoivCUQei+t7cFnj+fz3rXlXHl6bf24uL2C6gQ==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "bN33k9B9pgjz7+CutFWmLymn+ZorLoCbb/c/56oeMNk="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.113462",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "5c1133d09a7448481d7a62e411777301c1a0134264ef99008be6263b49922e0f",
    "plaintext_share_len": 129,
    "algorithm": "chacha20poly1305",
    "nonce_b64": "lt9E82wxl7joZ9S4",
    "tag_b64": null,
    "salt_b64": "SUxguW/kQ+y5PNglizwkmQ==",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_hash": "5ada231bbe3d28b8fdde21166a18bb4d95107ef02aa2d74e6a898a023e19c6ae",
    "aad_len": 148
  }
}
{
  "timestamp": "2025-08-22T04:37:03.114000",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 8,
    "q_text": "Dogs or cats?",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_text": "Cats",
    "alt_hash": "5ada231bbe3d28b8fdde21166a18bb4d95107ef02aa2d74e6a898a023e19c6ae",
    "algorithm": "chacha20poly1305"
  }
}
{
  "timestamp": "2025-08-22T04:37:03.114547",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Both' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.115018",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Both', salt(b64)='xhzSwLurOwQi6dgsulRDsw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.173353",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "xhzSwLurOwQi6dgsulRDsw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "dFbK7oRC07Qbq+YkXOLC90oSHM4hHTykx0g1b3jZlAQ=",
      "derived_key_b64": "dFbK7oRC07Qbq+YkXOLC90oSHM4hHTykx0g1b3jZlAQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.174776",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "fVAj6rq9TPAnAmax",
    "Ciphertext(base64)": "TT8nMAA4zmcRuU2NTj4V1MtiL9PjKZ72JxyC96wq4QI/glPmwLeWT23EjICJdz5RQfQHLJLoICsYOFhahhDRAE9XFLl/ehdVVU3Wz9qAWRTcio9+aCT053XHoI1Sik3zaEcyMqwWap6Mc6pRyVoZ7DD+nkg1ZiFAw611bv7NR+JC",
    "Tag(base64)": "m8OxrQ2iEnYPh+topaAGYQ==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "dFbK7oRC07Qbq+YkXOLC90oSHM4hHTykx0g1b3jZlAQ="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.175384",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "410b1de9fd8f3eca0b4c9a66e2b60c1d345e8572dab773f3bebddaa924cc6644",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "fVAj6rq9TPAnAmax",
    "tag_b64": "m8OxrQ2iEnYPh+topaAGYQ==",
    "salt_b64": "xhzSwLurOwQi6dgsulRDsw==",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_hash": "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:03.175894",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 8,
    "q_text": "Dogs or cats?",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_text": "Both",
    "alt_hash": "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:03.176417",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Other' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.176933",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Other', salt(b64)='WrPI9/KRXzZrCIYe3cRm1g=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:03.233973",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "WrPI9/KRXzZrCIYe3cRm1g==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "vv30m9WJv6kI2B5zTJ+KqsZmoTTp1eQ1YTe6HsFcCcI=",
      "derived_key_b64": "vv30m9WJv6kI2B5zTJ+KqsZmoTTp1eQ1YTe6HsFcCcI=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.235178",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "lF4HqynGA1q7nfBm",
    "Ciphertext(base64)": "VkvRXLsDWhhJxIaiHZfFI2YGRtRfiHIVBphDzGUWD0Eg1fUYbypD5Xq9FlX4DJB0iSX0OJDi9GF5N+Gsg8wQ/Yv5s+nB/Z0NrA+L6ZH3WCLAnUYp/b+q2PVWbGtazFtVJaZ3+wwmSIyXjT305nPv+NjiUyCbq5LXLweJHKvV5an5",
    "Tag(base64)": "6bPd5o+GrBaDpYcCyhPvsA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "vv30m9WJv6kI2B5zTJ+KqsZmoTTp1eQ1YTe6HsFcCcI="
    }
  }
}
{
  "timestamp": "2025-08-22T04:37:03.235819",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Per-answer share encrypted (passwordless).",
  "details": {
    "plaintext_share_sha3_256_hex": "a457f3f203f4e987166497b72afd4f11e4aad1a17be3c2f4967ee496393a9b2b",
    "plaintext_share_len": 129,
    "algorithm": "aes256gcm",
    "nonce_b64": "lF4HqynGA1q7nfBm",
    "tag_b64": "6bPd5o+GrBaDpYcCyhPvsA==",
    "salt_b64": "WrPI9/KRXzZrCIYe3cRm1g==",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_hash": "c037cf8fa41435dfcfa6409de73c533633d57c92d8b508f912634a944305d05f",
    "aad_len": 141
  }
}
{
  "timestamp": "2025-08-22T04:37:03.236361",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Mapped Q/A to encrypted share (beta logging).",
  "details": {
    "q_id": 8,
    "q_text": "Dogs or cats?",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_text": "Other",
    "alt_hash": "c037cf8fa41435dfcfa6409de73c533633d57c92d8b508f912634a944305d05f",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-22T04:37:03.238970",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery kit saved (passwordless; with final auth tag).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:36.537669",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Loaded recovery kit (beta debug).",
  "details": {
    "kit_file": "C:\\Users\\deskt\\Desktop\\Project_SECQ_CLI\\SECQ_CLI\\SECQ_CLI\\src\\user configured security questions\\user_config.json",
    "threshold": 6,
    "pad_size": 128,
    "argon2": {
      "time_cost": 3,
      "memory_cost": 65536,
      "parallelism": 4
    },
    "q_count": 8
  }
}
{
  "timestamp": "2025-08-22T04:37:52.772244",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q1 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:52.773677",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "picked": [
      "Ida",
      "Tilde"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:37:58.232723",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q2 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:37:58.234052",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "picked": [
      "21"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:00.715864",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q3 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:00.717222",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 3,
    "q_text": "Favourite food?",
    "picked": [
      "Whiskey"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:02.944559",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q4 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:02.945877",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 4,
    "q_text": "Favorite color?",
    "picked": [
      "Blue"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:06.230313",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q5 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:06.231631",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 5,
    "q_text": "Coffee or tea?",
    "picked": [
      "Neither"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:09.717233",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q6 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:09.718568",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 6,
    "q_text": "Favorite season?",
    "picked": [
      "Summer"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:13.615215",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q7 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:13.616535",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 7,
    "q_text": "Morning or night?",
    "picked": [
      "Night",
      "Both"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:18.877019",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q8 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:18.878352",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery UI picks for question.",
  "details": {
    "q_id": 8,
    "q_text": "Dogs or cats?",
    "picked": [
      "Other"
    ]
  }
}
{
  "timestamp": "2025-08-22T04:38:18.878941",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Ida' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:18.879406",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Ida', salt(b64)='at+ha3HMKCBc5AFD5JkxUA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:18.931088",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "at+ha3HMKCBc5AFD5JkxUA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "x4IqIH9qKfbU1bCu1u8PDqrHBqtE2gvV1vW0LoR0PJQ=",
      "derived_key_b64": "x4IqIH9qKfbU1bCu1u8PDqrHBqtE2gvV1vW0LoR0PJQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:18.932127",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "HND8aXU9BCuOBWdb",
    "Ciphertext(base64)": "b+U6ZpDcPrv0XLBS5AYLGMDN3WLs+mVwAtqiiOCrq/atTm+S3aOAwcA5QWsPWf7f/mKLSIRUuJX3W/m3/pSFDA3IcID79EXdu4KnpCFtjsaE0qjg1KFPEkZMpQDxPhGzx09KFOel+Svk8jhPDABtPAc9roPXQhFeMmy1kws9BtBu",
    "Tag(base64)": "uz0zt4/Mr0UjY1J4CCb/Vw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "x4IqIH9qKfbU1bCu1u8PDqrHBqtE2gvV1vW0LoR0PJQ="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:18.932854",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Ida",
    "alt_hash": "4ebdb27ad79cc9343a33d3dcaab205a95203f667f20c5eccdcd0c01abbec7db3",
    "algorithm": "aes256gcm",
    "share_sha3_256_hex": "24e8d081a4710d072f3f786b55b0bed7c875f210a9176d7675f79d16055bad4c",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:18.933471",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Tilde' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:18.933956",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Tilde', salt(b64)='2881ceX56sVhOWdpEX9Uyw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:18.986248",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "2881ceX56sVhOWdpEX9Uyw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "1HrK/9SWbdCtvHCeq3tGA+/dBhBPofQV+8OZHFhHCUM=",
      "derived_key_b64": "1HrK/9SWbdCtvHCeq3tGA+/dBhBPofQV+8OZHFhHCUM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:18.987676",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "a0imCq20jOX00Yur",
    "Ciphertext(base64)": "lFtCVcpDoFBpguxf0pAoJlqgrvraNj0exIhg12B3GgGFk4Qt+Vqi0JSb2GBksDfN9tQWiOINB9khlGFC/A2B4sMDknvmMQc/nKJgagpK6oX8+I9ksZ1fygjJg9Gfk5yvC3Rqufe8KKjT5CACakJA2l1vDJhd3H3JFB8q4TnTUEe+",
    "Tag(base64)": "7zOmFUZojkORVeK1mCFAFg==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "1HrK/9SWbdCtvHCeq3tGA+/dBhBPofQV+8OZHFhHCUM="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:18.988261",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 1,
    "q_text": "What is your name?",
    "q_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b",
    "alt_text": "Tilde",
    "alt_hash": "9c73d3cd125fffceaada186b00a9f4bf51e61924be1380fad78b9351a2fbf745",
    "algorithm": "aes256gcm",
    "share_sha3_256_hex": "01bcda15f1736c0911dbeb2988ae15e44836c6df104651b6b492711892d5cad5",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:18.988774",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='21' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:18.989278",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='21', salt(b64)='uHqW/C0wI83sf6L0Xxv8Dg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.042207",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "uHqW/C0wI83sf6L0Xxv8Dg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "xKMgTVHJcYQBvUOn+LSluDsjPmP4ERamjcy8CgFl8WE=",
      "derived_key_b64": "xKMgTVHJcYQBvUOn+LSluDsjPmP4ERamjcy8CgFl8WE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.043358",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "yBAEw8/OkGeuj4En",
    "Ciphertext(base64)": "b1lMeWhR8LL9Zvxc9R0zgurjbPlE5q9zsvbjpWIGxluAqiabNPBD26JKr2Wy5MdoH7BQdiX7fPWI9dDqDN398D1qHreq2L9dMsM/FKJ9mCteLlq7XuGdahS44FrCagTTAfHQUkkruNdQtGRgdQ5z+jUUHdWvnDdLoFDzemlb6bRimVUNMJ+vjnSyc+Atmxvf7w==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "xKMgTVHJcYQBvUOn+LSluDsjPmP4ERamjcy8CgFl8WE="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.043949",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 2,
    "q_text": "How old are you?",
    "q_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961",
    "alt_text": "21",
    "alt_hash": "7faeca1b13d1a7f909f21989ff203fa36abb4be730336186f9c49c6e56a890c0",
    "algorithm": "chacha20poly1305",
    "share_sha3_256_hex": "e5d03d09b33574ad4845c39fe1cf25c9e6a2501c089fd8e19064ba0b5f37a1c5",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.044505",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Whiskey' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.044977",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Whiskey', salt(b64)='tImc2eaS0btzQDYo9nLawQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.096650",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "tImc2eaS0btzQDYo9nLawQ==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "I4728xL4H2gLlnD5ms6WHvdKfFfrAZVN+u4ILQx1guo=",
      "derived_key_b64": "I4728xL4H2gLlnD5ms6WHvdKfFfrAZVN+u4ILQx1guo=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.097900",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "+fZngjCvUSvrSAg7",
    "Ciphertext(base64)": "dxlkBcx5nSF+Phvy+Md6hJIkYecFF+EZl66mnAUywPr0+d/e+eOSRpzCXgOkIALl4Fqq7sor064kIO5Sr8obHkHP7PQ8528+vClDhrZ5hrOMr67C8A/o2sZoPMRNEzpGmsnQJCLsaSV/hx2b66wMLSjWcv+EzNA1bjliF3t4Mt4B",
    "Tag(base64)": "OqXJFPoCQgTNpBxJXsl0Rw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "I4728xL4H2gLlnD5ms6WHvdKfFfrAZVN+u4ILQx1guo="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.098525",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 3,
    "q_text": "Favourite food?",
    "q_hash": "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457",
    "alt_text": "Whiskey",
    "alt_hash": "845c7761756764853108d328038e0ef46a55399d0fc37f2fdb97fb583cb6a5e2",
    "algorithm": "aes256gcm",
    "share_sha3_256_hex": "4cf1b5b76445390a5a77f26158ab4fbf2d0e28178a58c5f5356ed38f37d2f0aa",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.099032",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Blue' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.099507",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Blue', salt(b64)='r1nDOSINQ4hJmdU9wwOyHg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.152900",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "r1nDOSINQ4hJmdU9wwOyHg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "W9J07mR9hoLvlTWLDx6ZxvqHam9jgVn27P1EsaIT3aw=",
      "derived_key_b64": "W9J07mR9hoLvlTWLDx6ZxvqHam9jgVn27P1EsaIT3aw=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.154012",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "Hzu45I4kQiLQlySp",
    "Ciphertext(base64)": "FsaRxA+qsSZbwyYudGMt6qGOotr/053Xr/SgfMp0g+LoyqwshKxw5OjH1E2x0GB3F0OQ20WbUJPChpucmmYpMIsNi2qFUNWQzt+s0XPd51rBFaady98oaitFFOeE1lEXBVzue3MVCKA9onVfacIhRaJLZ4oZRPUrEXUn5Xw7QdWa",
    "Tag(base64)": "PtNNgkOHAbT8ZgN66M++VA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "W9J07mR9hoLvlTWLDx6ZxvqHam9jgVn27P1EsaIT3aw="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.154617",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 4,
    "q_text": "Favorite color?",
    "q_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2",
    "alt_text": "Blue",
    "alt_hash": "5c0281ed94de14b7dec231af9dfee812215110be11507e7220eb1ad753f2bfa2",
    "algorithm": "aes256gcm",
    "share_sha3_256_hex": "791739e4250c3a5dee47ed2c7e3a153d4d861a9eeb825f44f54f9c5faae54a75",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.155120",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Neither' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.155687",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Neither', salt(b64)='fSXdF4LScPqOLDucFRulUg=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.209371",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "fSXdF4LScPqOLDucFRulUg==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "VO5Z8oOW48iQdKUfeycrx9OoodKHQrjG8Kyqxuinmkg=",
      "derived_key_b64": "VO5Z8oOW48iQdKUfeycrx9OoodKHQrjG8Kyqxuinmkg=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.210689",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "/QvC9tfRZqFUnZNm",
    "Ciphertext(base64)": "Pg6QhfjVD0a9o2h1cEAdpYReH39wzN5j+K4nY9asDOQRtbFxIMdnyFfyLb/xUqhfjMFLXTglItTTm9K1qUYKakD3pvneamL59Oyu8sjwnzPhxqY29PSU6pZOpUSJo2rIK1nx4Petv4oN5s7PoBvLJNg7bDhe4Cl1afE8kxH83bReGpe3Cm96PRjt88xeEun5Vw==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "VO5Z8oOW48iQdKUfeycrx9OoodKHQrjG8Kyqxuinmkg="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.211237",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 5,
    "q_text": "Coffee or tea?",
    "q_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6",
    "alt_text": "Neither",
    "alt_hash": "4171acf02cac7ec5cf6a44e1182db37d85717f59bba578e7d8672cba248e9737",
    "algorithm": "chacha20poly1305",
    "share_sha3_256_hex": "3946323d93a4b77af6936b3aa02d49003b9e360967e104ccfb2128b0f1130dd4",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.211773",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Summer' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.212257",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Summer', salt(b64)='fTBQ4mqznr+y+4SfYmX4jw=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.263878",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "fTBQ4mqznr+y+4SfYmX4jw==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "dh/uoTTqwnjG/BbyarKLjL1XR/E/Tzzz1IzoglB5Ll4=",
      "derived_key_b64": "dh/uoTTqwnjG/BbyarKLjL1XR/E/Tzzz1IzoglB5Ll4=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.264969",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "EBM4QvzeJZ1RIXwG",
    "Ciphertext(base64)": "+HtSLpptLj49KGZ4lWQOIuQi3OLxhFSEdRdzfRIwMGFqWwoIJDK3UkmbqZ+O3VjKLEm4PTm1NKMF8JfdJ2qKZ8PkaJ6/xDeTIh7M8dR7SRRbopU8WviQ1P2c/BmyWeThdyqd39eSaHKnbSFCAZZrKMLKgTZLuIQPnCcEswTtSqaB",
    "Tag(base64)": "J18dKrFcWOP02EtGmmfiRQ==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "dh/uoTTqwnjG/BbyarKLjL1XR/E/Tzzz1IzoglB5Ll4="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.265618",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 6,
    "q_text": "Favorite season?",
    "q_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e",
    "alt_text": "Summer",
    "alt_hash": "9907c6030df82cbd62fde09aa786273c6994dce03fc374e666fc08fa7996dbad",
    "algorithm": "aes256gcm",
    "share_sha3_256_hex": "c61f095778e7c892b9a370d6409f231508b3358c684b57f6847b40c08377549d",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.266137",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Night' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.266634",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Night', salt(b64)='6OcgSYx7r/EgrAo61HAjdA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.318940",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "6OcgSYx7r/EgrAo61HAjdA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "QDDaeawEpRPVERPM5m5SvxGzkhRO2NlI+1Zqp5UHL74=",
      "derived_key_b64": "QDDaeawEpRPVERPM5m5SvxGzkhRO2NlI+1Zqp5UHL74=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.320490",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "r27pAj5BnQO8WXl0",
    "Ciphertext(base64)": "XfOnnTX+YTC5pHpynqgI4V9fq8l8GRUuAYgbL6dPx1s/LrSFlJ+ZptRjTnGMjZcyRtTZVj4Yt0UH6QYZRIM7vnqOxQFO+skrvkpdkeKjYvtzH5M/1ZkQ4WOTsuatnlHbWvuUxZrat7eOZCAiYEqRGOvHxDt43jpOeBtiQPXndbUpF3HLEjq3hULh7ZY9bPecRg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "QDDaeawEpRPVERPM5m5SvxGzkhRO2NlI+1Zqp5UHL74="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.321115",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 7,
    "q_text": "Morning or night?",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_text": "Night",
    "alt_hash": "b2db95d12007266c42f6675a5ea2fad3bf3fe4db1622b93fcd7f7b875547fe8b",
    "algorithm": "chacha20poly1305",
    "share_sha3_256_hex": "e3f2d53afa02e173ddf0f01e369f7b5afacbb59cf7a85d06e78ad766158541a5",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.321654",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Both' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.322151",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Both', salt(b64)='8PR1mt/l8plExn1IJc6YJA=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.374200",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "8PR1mt/l8plExn1IJc6YJA==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "xCS+5of+YoZriylof9D77Bcu2OGKJUQ8AtZ9O8jt/ks=",
      "derived_key_b64": "xCS+5of+YoZriylof9D77Bcu2OGKJUQ8AtZ9O8jt/ks=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.375259",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "idnk6UGtJjFTTf+g",
    "Ciphertext(base64)": "CQHN/emIwq8C1zqeHWLVCM2CfR65C81oELzQEKsGnSi7KQkBz52f2KjW5dsoXYufCn48hrHIArdHy53I02BNOAvX0qFIJLVEJx1ABNJoVOmEsPmHtiO4kEparQyRLzxevKyGyJqkfiNRWsTJuJz4SZ7VeASmeQ0+xeCVDfPovwoX+x1JdNvCf3SsGplJfQbh+g==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "xCS+5of+YoZriylof9D77Bcu2OGKJUQ8AtZ9O8jt/ks="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.375831",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 7,
    "q_text": "Morning or night?",
    "q_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796",
    "alt_text": "Both",
    "alt_hash": "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330",
    "algorithm": "chacha20poly1305",
    "share_sha3_256_hex": "430a09b6e025944d563bfbc3aeed5f1dc568b6be285940cc86a8335b242f9286",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.376421",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using user-provided password='Other' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.376890",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='Other', salt(b64)='WrPI9/KRXzZrCIYe3cRm1g=='",
  "details": {}
}
{
  "timestamp": "2025-08-22T04:38:19.428125",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "WrPI9/KRXzZrCIYe3cRm1g==",
      "ephemeral_password": "<not ephemeral>"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": false,
      "key_b64": "vv30m9WJv6kI2B5zTJ+KqsZmoTTp1eQ1YTe6HsFcCcI=",
      "derived_key_b64": "vv30m9WJv6kI2B5zTJ+KqsZmoTTp1eQ1YTe6HsFcCcI=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 65536,
        "parallelism": 4,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.429437",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "lF4HqynGA1q7nfBm",
    "Ciphertext(base64)": "VkvRXLsDWhhJxIaiHZfFI2YGRtRfiHIVBphDzGUWD0Eg1fUYbypD5Xq9FlX4DJB0iSX0OJDi9GF5N+Gsg8wQ/Yv5s+nB/Z0NrA+L6ZH3WCLAnUYp/b+q2PVWbGtazFtVJaZ3+wwmSIyXjT305nPv+NjiUyCbq5LXLweJHKvV5an5",
    "Tag(base64)": "6bPd5o+GrBaDpYcCyhPvsA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "vv30m9WJv6kI2B5zTJ+KqsZmoTTp1eQ1YTe6HsFcCcI="
    }
  }
}
{
  "timestamp": "2025-08-22T04:38:19.430016",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Decrypted share (beta clear logging).",
  "details": {
    "q_id": 8,
    "q_text": "Dogs or cats?",
    "q_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2",
    "alt_text": "Other",
    "alt_hash": "c037cf8fa41435dfcfa6409de73c533633d57c92d8b508f912634a944305d05f",
    "algorithm": "aes256gcm",
    "share_sha3_256_hex": "a457f3f203f4e987166497b72afd4f11e4aad1a17be3c2f4967ee496393a9b2b",
    "share_len_bytes": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.430623",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery phase decryption summary.",
  "details": {
    "partials_count": 10,
    "failures": 0,
    "threshold": 6
  }
}
{
  "timestamp": "2025-08-22T04:38:19.431730",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_combine() via node-bridge",
  "details": {
    "num_shares": 6,
    "share_len": 129
  }
}
{
  "timestamp": "2025-08-22T04:38:19.491100",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_combine() complete.",
  "details": {
    "reconstructed_len": 16,
    "reconstructed_sha3_256": "040f362285d6de192b6500ef05af0c21efb72520e1db37518b2b54f393ecb584"
  }
}
{
  "timestamp": "2025-08-22T04:38:19.492053",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "SSS combine succeeded in recovery.",
  "details": {
    "combined_len": 16
  }
}
{
  "timestamp": "2025-08-22T04:38:19.492891",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Final secret verified/decoded.",
  "details": {
    "final_secret_len": 12
  }
}
{
  "manual_decryption_guide": [
    "-------------------- MANUAL DECRYPTION GUIDE --------------------",
    "1. Identify correct standard & critical picks and gather ephemeral-encrypted partials.",
    "2. Decrypt each 95% chunk and 5% chunk (or single 100% chunk). Combine => full share.",
    "3. Provide enough real shares to sss_combine() => base64-decode final secret.",
    "-----------------------------------------------------------------"
  ]
}
{
  "timestamp": "2025-08-22T04:38:19.493869",
  "run_id": "3bedee28-8a89-40c2-8843-d7bc081d4b2d",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Recovery Mode complete.",
  "details": {}
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-30-54.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-30-54.txt
# SIZE: 31070 bytes
# HASH: c525900f0555e05f6117fa3d1197f0b66cbcbbd199b94561fc49c95d6e8860ce
# MODIFIED: 2025-08-27T02:19:21.009252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-22T04:30:54.712319] [INFO] [SYSTEM] Start new run (run_id=3bedee28-8a89-40c2-8843-d7bc081d4b2d)
[2025-08-22T04:36:42.580644] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Counts computed for kit build.
[2025-08-22T04:36:48.830148] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Using PAD size: 128
[2025-08-22T04:37:01.399805] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Argon2id parameters confirmed for kit.
[2025-08-22T04:37:01.401558] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Splitting real secret: correct_count=10, threshold=6, pad=128
[2025-08-22T04:37:01.404250] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() via node-bridge
[2025-08-22T04:37:01.473626] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() complete.
[2025-08-22T04:37:01.474437] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() via node-bridge
[2025-08-22T04:37:01.537361] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() complete.
[2025-08-22T04:37:01.538091] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() via node-bridge
[2025-08-22T04:37:01.600308] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() complete.
[2025-08-22T04:37:01.601060] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - SSS split summary (beta clear logging).
[2025-08-22T04:37:01.602905] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Ida' (raw).
[2025-08-22T04:37:01.603422] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Ida', salt(b64)='at+ha3HMKCBc5AFD5JkxUA=='
[2025-08-22T04:37:01.656109] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.658656] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.659235] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.659740] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.660239] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Jocke' (raw).
[2025-08-22T04:37:01.660732] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Jocke', salt(b64)='uGO6g4c43LguixZsHbOuHw=='
[2025-08-22T04:37:01.712234] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.713533] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.714055] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.714532] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.715052] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Nina' (raw).
[2025-08-22T04:37:01.715512] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Nina', salt(b64)='AAm/1zbjRhzTtRuNj3/GFA=='
[2025-08-22T04:37:01.766579] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.767766] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.768355] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.768849] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.769346] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Pelle' (raw).
[2025-08-22T04:37:01.769857] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Pelle', salt(b64)='l+5pMp3ySR96+3XKmvQ6og=='
[2025-08-22T04:37:01.821515] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.822857] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.823402] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.823912] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.824439] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Sara' (raw).
[2025-08-22T04:37:01.824914] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Sara', salt(b64)='e1byzifS8aY4XBisb9yBBQ=='
[2025-08-22T04:37:01.876696] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.878007] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.878547] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.879055] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.879554] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Tilde' (raw).
[2025-08-22T04:37:01.880041] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Tilde', salt(b64)='2881ceX56sVhOWdpEX9Uyw=='
[2025-08-22T04:37:01.932065] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.933638] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.934182] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.934660] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.935174] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='22' (raw).
[2025-08-22T04:37:01.935632] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='22', salt(b64)='9pQnm9ZoZmGm9nn1bCPEgA=='
[2025-08-22T04:37:01.987939] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.989125] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:01.989658] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:01.990174] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:01.990721] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='25' (raw).
[2025-08-22T04:37:01.991198] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='25', salt(b64)='3ZUQjJtqelYeqUASxExmWQ=='
[2025-08-22T04:37:02.044037] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.045685] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.046189] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.046680] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.047171] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='21' (raw).
[2025-08-22T04:37:02.047645] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='21', salt(b64)='uHqW/C0wI83sf6L0Xxv8Dg=='
[2025-08-22T04:37:02.098558] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.099696] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.100307] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.100809] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.101390] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='24' (raw).
[2025-08-22T04:37:02.101868] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='24', salt(b64)='BJSCKXtZ+vBuAuyW2jv5Qg=='
[2025-08-22T04:37:02.155714] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.156932] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.157567] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.158120] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.158636] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='55' (raw).
[2025-08-22T04:37:02.159104] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='55', salt(b64)='J5Le1+IRkYcXRC28dbPwRw=='
[2025-08-22T04:37:02.211270] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.212668] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.213282] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.213775] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.214292] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Beer' (raw).
[2025-08-22T04:37:02.214777] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Beer', salt(b64)='Un56K1c2dYIDEWF2Ud58Mg=='
[2025-08-22T04:37:02.266142] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.267330] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.267878] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.268441] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.268996] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Whiskey' (raw).
[2025-08-22T04:37:02.269474] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Whiskey', salt(b64)='tImc2eaS0btzQDYo9nLawQ=='
[2025-08-22T04:37:02.322200] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.323582] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.324112] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.324677] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.325247] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Blue' (raw).
[2025-08-22T04:37:02.325727] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Blue', salt(b64)='r1nDOSINQ4hJmdU9wwOyHg=='
[2025-08-22T04:37:02.376901] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.378089] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.378612] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.379148] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.379647] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Red' (raw).
[2025-08-22T04:37:02.380110] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Red', salt(b64)='ynD93RiPZbx1sU1E87Kbhw=='
[2025-08-22T04:37:02.433752] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.435087] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.435598] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.436110] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.436607] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Green' (raw).
[2025-08-22T04:37:02.437069] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Green', salt(b64)='BHCygJ4/RpqXRTKtxytytg=='
[2025-08-22T04:37:02.491053] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.492700] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.493270] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.493760] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.494332] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Coffee' (raw).
[2025-08-22T04:37:02.494794] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Coffee', salt(b64)='IB4QSSs+nCEhac8p9MkrtQ=='
[2025-08-22T04:37:02.549799] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.551170] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.551677] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.552151] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.552702] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Tea' (raw).
[2025-08-22T04:37:02.553174] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Tea', salt(b64)='oHN5LFd9/MSeVMPy9d5THg=='
[2025-08-22T04:37:02.606440] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.607907] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.608459] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.608962] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.609498] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Neither' (raw).
[2025-08-22T04:37:02.610021] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Neither', salt(b64)='fSXdF4LScPqOLDucFRulUg=='
[2025-08-22T04:37:02.661488] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.662600] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.663127] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.663606] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.664120] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Summer' (raw).
[2025-08-22T04:37:02.664639] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Summer', salt(b64)='fTBQ4mqznr+y+4SfYmX4jw=='
[2025-08-22T04:37:02.717060] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.718404] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.718922] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.719395] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.719905] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Winter' (raw).
[2025-08-22T04:37:02.720365] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Winter', salt(b64)='M9zHgyzKD9RLEOCFpmdGGA=='
[2025-08-22T04:37:02.771946] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.773064] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.773642] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.774192] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.774722] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Autumn' (raw).
[2025-08-22T04:37:02.775209] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Autumn', salt(b64)='F3Lu4BYYZDifI/QT0iKs7A=='
[2025-08-22T04:37:02.826934] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.831508] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.832022] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.832509] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.833052] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Morning' (raw).
[2025-08-22T04:37:02.833507] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Morning', salt(b64)='ZWyLWH7pMo6lBjw/IDe6bw=='
[2025-08-22T04:37:02.883860] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.885030] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.885559] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.886137] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.886648] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Night' (raw).
[2025-08-22T04:37:02.887155] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Night', salt(b64)='6OcgSYx7r/EgrAo61HAjdA=='
[2025-08-22T04:37:02.939986] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.941380] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.941910] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.942390] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.942868] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Both' (raw).
[2025-08-22T04:37:02.943344] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Both', salt(b64)='8PR1mt/l8plExn1IJc6YJA=='
[2025-08-22T04:37:02.994453] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.995683] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:02.996213] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:02.996701] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:02.997215] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Dogs' (raw).
[2025-08-22T04:37:02.997687] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Dogs', salt(b64)='fvQD3H7R3V5FnfeQRcv7IQ=='
[2025-08-22T04:37:03.049330] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.050783] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.051320] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:03.051797] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:03.052305] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Cats' (raw).
[2025-08-22T04:37:03.052772] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Cats', salt(b64)='SUxguW/kQ+y5PNglizwkmQ=='
[2025-08-22T04:37:03.111828] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.112813] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.113462] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:03.114000] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:03.114547] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Both' (raw).
[2025-08-22T04:37:03.115018] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Both', salt(b64)='xhzSwLurOwQi6dgsulRDsw=='
[2025-08-22T04:37:03.173353] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.174776] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.175384] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:03.175894] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:03.176417] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Other' (raw).
[2025-08-22T04:37:03.176933] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Other', salt(b64)='WrPI9/KRXzZrCIYe3cRm1g=='
[2025-08-22T04:37:03.233973] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.235178] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:37:03.235819] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Per-answer share encrypted (passwordless).
[2025-08-22T04:37:03.236361] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Mapped Q/A to encrypted share (beta logging).
[2025-08-22T04:37:03.238970] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery kit saved (passwordless; with final auth tag).
[2025-08-22T04:37:36.537669] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Loaded recovery kit (beta debug).
[2025-08-22T04:37:52.772244] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q1 final picks
[2025-08-22T04:37:52.773677] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:37:58.232723] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q2 final picks
[2025-08-22T04:37:58.234052] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:00.715864] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q3 final picks
[2025-08-22T04:38:00.717222] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:02.944559] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q4 final picks
[2025-08-22T04:38:02.945877] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:06.230313] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q5 final picks
[2025-08-22T04:38:06.231631] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:09.717233] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q6 final picks
[2025-08-22T04:38:09.718568] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:13.615215] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q7 final picks
[2025-08-22T04:38:13.616535] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:18.877019] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q8 final picks
[2025-08-22T04:38:18.878352] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery UI picks for question.
[2025-08-22T04:38:18.878941] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Ida' (raw).
[2025-08-22T04:38:18.879406] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Ida', salt(b64)='at+ha3HMKCBc5AFD5JkxUA=='
[2025-08-22T04:38:18.931088] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:18.932127] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:18.932854] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:18.933471] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Tilde' (raw).
[2025-08-22T04:38:18.933956] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Tilde', salt(b64)='2881ceX56sVhOWdpEX9Uyw=='
[2025-08-22T04:38:18.986248] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:18.987676] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:18.988261] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:18.988774] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='21' (raw).
[2025-08-22T04:38:18.989278] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='21', salt(b64)='uHqW/C0wI83sf6L0Xxv8Dg=='
[2025-08-22T04:38:19.042207] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.043358] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.043949] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.044505] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Whiskey' (raw).
[2025-08-22T04:38:19.044977] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Whiskey', salt(b64)='tImc2eaS0btzQDYo9nLawQ=='
[2025-08-22T04:38:19.096650] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.097900] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.098525] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.099032] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Blue' (raw).
[2025-08-22T04:38:19.099507] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Blue', salt(b64)='r1nDOSINQ4hJmdU9wwOyHg=='
[2025-08-22T04:38:19.152900] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.154012] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.154617] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.155120] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Neither' (raw).
[2025-08-22T04:38:19.155687] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Neither', salt(b64)='fSXdF4LScPqOLDucFRulUg=='
[2025-08-22T04:38:19.209371] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.210689] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.211237] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.211773] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Summer' (raw).
[2025-08-22T04:38:19.212257] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Summer', salt(b64)='fTBQ4mqznr+y+4SfYmX4jw=='
[2025-08-22T04:38:19.263878] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.264969] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.265618] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.266137] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Night' (raw).
[2025-08-22T04:38:19.266634] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Night', salt(b64)='6OcgSYx7r/EgrAo61HAjdA=='
[2025-08-22T04:38:19.318940] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.320490] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.321115] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.321654] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Both' (raw).
[2025-08-22T04:38:19.322151] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Both', salt(b64)='8PR1mt/l8plExn1IJc6YJA=='
[2025-08-22T04:38:19.374200] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.375259] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.375831] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.376421] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using user-provided password='Other' (raw).
[2025-08-22T04:38:19.376890] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='Other', salt(b64)='WrPI9/KRXzZrCIYe3cRm1g=='
[2025-08-22T04:38:19.428125] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.429437] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-22T04:38:19.430016] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Decrypted share (beta clear logging).
[2025-08-22T04:38:19.430623] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Recovery phase decryption summary.
[2025-08-22T04:38:19.431730] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_combine() via node-bridge
[2025-08-22T04:38:19.491100] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_combine() complete.
[2025-08-22T04:38:19.492053] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - SSS combine succeeded in recovery.
[2025-08-22T04:38:19.492891] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Final secret verified/decoded.
-------------------- MANUAL DECRYPTION GUIDE --------------------
1. Identify correct standard & critical picks and gather ephemeral-encrypted partials.
2. Decrypt each 95% chunk and 5% chunk (or single 100% chunk). Combine => full share.
3. Provide enough real shares to sss_combine() => base64-decode final secret.
-----------------------------------------------------------------
[2025-08-22T04:38:19.493869] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Recovery Mode complete.



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-22_04-30-54.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_21-01-40.json
# SIZE: 10479 bytes
# HASH: b9c13af902d269e76f46ce9add012b6705b64c75fac50b5d3280ace3f94195cf
# MODIFIED: 2025-08-27T02:19:21.009252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-25T21:01:40.891580",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-08-25T21:01:44.540818",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting demonstration flow (Option 2)...",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.546713",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite hobbies?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.547451",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite subject in school?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.548191",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What type of food do you like?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.548831",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite mode of transportation?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.549291",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which language(s) would you like to learn?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.549756",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of places do you enjoy visiting?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.550200",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of beverages do you prefer?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.550666",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which color(s) do you like the most?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.551107",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of movies do you enjoy?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.551551",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What type of games do you like to play?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.552033",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of music instruments do you enjoy playing or listening to?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.552476",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite types of flowers?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.552916",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of clothes do you prefer wearing?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.553353",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of pets would you like to have?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.553798",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite type of dessert?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.554257",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What type of jobs or careers are you interested in?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.554696",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite kinds of drinks?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.555143",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of landscapes do you find most beautiful?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.555579",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite fruits to eat?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.556025",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of places do you like to shop at?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.556478",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of animals do you find fascinating?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.556936",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite type of beverage?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.557397",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which outdoor place(s) would you love to explore?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.557837",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite type of cuisine?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-25T21:01:44.558283",
  "run_id": "40d7e4e9-5fe4-42f0-9060-5925770f6e16",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which kind of exercise do you enjoy doing?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_21-01-40.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_21-01-40.txt
# SIZE: 4965 bytes
# HASH: 6a124f1034a1097e735c9457ea0181238739253c61313707428322f4f79113c0
# MODIFIED: 2025-08-27T02:19:21.010252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-25T21:01:40.891580] [INFO] [SYSTEM] Start new run (run_id=40d7e4e9-5fe4-42f0-9060-5925770f6e16)
[2025-08-25T21:01:44.540818] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Starting demonstration flow (Option 2)...
[2025-08-25T21:01:44.546713] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite hobbies?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.547451] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite subject in school?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.548191] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What type of food do you like?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.548831] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite mode of transportation?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.549291] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which language(s) would you like to learn?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.549756] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of places do you enjoy visiting?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.550200] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of beverages do you prefer?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.550666] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which color(s) do you like the most?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.551107] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of movies do you enjoy?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.551551] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What type of games do you like to play?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.552033] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of music instruments do you enjoy playing or listening to?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.552476] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite types of flowers?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.552916] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of clothes do you prefer wearing?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.553353] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of pets would you like to have?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.553798] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite type of dessert?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.554257] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What type of jobs or careers are you interested in?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.554696] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite kinds of drinks?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.555143] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of landscapes do you find most beautiful?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.555579] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite fruits to eat?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.556025] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of places do you like to shop at?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.556478] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of animals do you find fascinating?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.556936] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite type of beverage?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.557397] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which outdoor place(s) would you love to explore?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.557837] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite type of cuisine?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-25T21:01:44.558283] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which kind of exercise do you enjoy doing?' had empty 'correct_answers'. Now set them all as correct.



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_21-01-40.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_22-02-37.json
# SIZE: 238 bytes
# HASH: 69bb7d78a490d5ec97e99fb3737c59e87d1e9cdfad04c0d9060f7843d96a6c4f
# MODIFIED: 2025-08-27T02:19:21.010252
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-25T22:02:37.443619",
  "run_id": "d74a10fd-3b0f-4234-8232-0a316fb3bd86",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_22-02-37.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_22-02-37.txt
# SIZE: 106 bytes
# HASH: ba52462858d13ac57157ec581064e6daddf265857cc0ea579a96a20d2612d4c1
# MODIFIED: 2025-08-27T02:19:21.011251
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-25T22:02:37.443619] [INFO] [SYSTEM] Start new run (run_id=d74a10fd-3b0f-4234-8232-0a316fb3bd86)



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_22-02-37.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_23-42-20.json
# SIZE: 238 bytes
# HASH: a4e18702b8403ffb457a504c1ef0069d582922615e65241e08e96b7b6aac46d7
# MODIFIED: 2025-08-27T02:19:21.011251
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-25T23:42:20.021246",
  "run_id": "3a8376ff-1be8-476f-ac65-4498069a5f95",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_23-42-20.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_23-42-20.txt
# SIZE: 106 bytes
# HASH: 29448208ff6f3e588652b05506be2a0b925516cd9f4f845157525ca906858d01
# MODIFIED: 2025-08-27T02:19:21.011251
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-25T23:42:20.021246] [INFO] [SYSTEM] Start new run (run_id=3a8376ff-1be8-476f-ac65-4498069a5f95)



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-25_23-42-20.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-26_00-41-45.json
# SIZE: 153351 bytes
# HASH: d3252ea0ea25ead14ec81fa32f74e750622e277997a0a05715596cde841ae23b
# MODIFIED: 2025-08-27T02:19:21.012859
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-26T00:41:45.755787",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-08-26T00:41:48.247862",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting demonstration flow (Option 2)...",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.251486",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite hobbies?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.251968",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite subject in school?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.252597",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What type of food do you like?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.253112",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite mode of transportation?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.253564",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which language(s) would you like to learn?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.254000",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of places do you enjoy visiting?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.254440",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of beverages do you prefer?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.254868",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which color(s) do you like the most?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.255300",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of movies do you enjoy?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.255735",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What type of games do you like to play?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.256192",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of music instruments do you enjoy playing or listening to?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.256650",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite types of flowers?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.257079",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of clothes do you prefer wearing?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.257508",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of pets would you like to have?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.257935",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite type of dessert?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.258381",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What type of jobs or careers are you interested in?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.258805",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite kinds of drinks?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.259284",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of landscapes do you find most beautiful?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.259726",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What are your favorite fruits to eat?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.260161",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of places do you like to shop at?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.260615",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What kind of animals do you find fascinating?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.261058",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite type of beverage?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.261497",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which outdoor place(s) would you love to explore?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.261920",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'What is your favorite type of cuisine?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:48.262358",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Question 'Which kind of exercise do you enjoy doing?' had empty 'correct_answers'. Now set them all as correct.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:51.282709",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "User int input valid: 9",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:53.272743",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q1 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:53.273946",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q1: text='What are your favorite hobbies?' => user_picks=4 selected; local counts: correct=4, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:54.634657",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q2 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:54.635791",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q2: text='What is your favorite subject in school?' => user_picks=3 selected; local counts: correct=3, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:55.444623",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q3 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:55.445805",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q3: text='What type of food do you like?' => user_picks=1 selected; local counts: correct=1, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:56.874712",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q4 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:56.875708",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q4: text='What is your favorite mode of transportation?' => user_picks=2 selected; local counts: correct=2, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:58.985557",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q5 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:41:58.986767",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q5: text='Which language(s) would you like to learn?' => user_picks=2 selected; local counts: correct=2, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:00.736585",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q6 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:00.737808",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q6: text='What kind of places do you enjoy visiting?' => user_picks=2 selected; local counts: correct=2, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:02.668330",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q7 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:02.669664",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q7: text='What kind of beverages do you prefer?' => user_picks=3 selected; local counts: correct=3, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:04.589659",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q8 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:04.590860",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q8: text='Which color(s) do you like the most?' => user_picks=3 selected; local counts: correct=3, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:06.390424",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q9 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:06.391630",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "DEBUG",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q9: text='What kind of movies do you enjoy?' => user_picks=3 selected; local counts: correct=3, incorrect=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.962496",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q1: c=4, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.963347",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q2: c=3, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.963803",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q3: c=1, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.964248",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q4: c=2, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.964713",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q5: c=2, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.965183",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q6: c=2, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.965626",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q7: c=3, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.966112",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q8: c=3, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.966572",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "After re-edit Q9: c=3, i=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:08.967012",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "FINAL TALLY => c_count=23, i_count=0",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:16.082388",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using PAD size: 128",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:19.093536",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Splitting real secret: correct_count=23, threshold=13, pad=128",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:19.094408",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() via node-bridge",
  "details": {
    "secret_len": 4,
    "shares": 23,
    "threshold": 13,
    "pad": 128
  }
}
{
  "timestamp": "2025-08-26T00:42:19.175682",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "sss_split() complete.",
  "details": {
    "share_len": 129,
    "xcoords": [
      161,
      149,
      52,
      71,
      162,
      55,
      83,
      86,
      34,
      36,
      255,
      35,
      224,
      78,
      166,
      253,
      102,
      170,
      173,
      91,
      84,
      33,
      223
    ],
    "sample_share_hashes": [
      "b17e59356a1027ef2f556ae35f02397d586c654cf6968007cd8b4dbd40aedbd4",
      "543ff947d5e8e8f6312f8f4741811392fcb93eda95f9441cb919d88fa714eb91",
      "4505b550eff570ecb7b1a9d37aa5a74d3d74d60f62a2990139a7fa86bb69ac4f"
    ]
  }
}
{
  "timestamp": "2025-08-26T00:42:19.176599",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "SSS split summary (beta clear logging).",
  "details": {
    "share_len": 129,
    "pad": 128,
    "threshold": 13,
    "real_count": 23,
    "dummy_count": 0,
    "real_xcoords": [
      161,
      149,
      52,
      71,
      162,
      55,
      83,
      86,
      34,
      36,
      255,
      35,
      224,
      78,
      166,
      253,
      102,
      170,
      173,
      91,
      84,
      33,
      223
    ],
    "dummy_xcoords": [],
    "real_share_sha3_256": [
      "b17e59356a1027ef2f556ae35f02397d586c654cf6968007cd8b4dbd40aedbd4",
      "543ff947d5e8e8f6312f8f4741811392fcb93eda95f9441cb919d88fa714eb91",
      "4505b550eff570ecb7b1a9d37aa5a74d3d74d60f62a2990139a7fa86bb69ac4f",
      "4ef2147ddf520632602d707c5d3693d5404821005acce5a09ccc4e12dce946d4",
      "9de5b5b4a73b9186cf9a15a3fb4f17c9882e6adcbae7f75a4f7226b985188c24",
      "5e01a9c054f47ba30e749a943f2eb5121a48dd10feb8a011492532bffbea3c50",
      "c6036929b16b92d7b82ae86cd2cbaf7413a6d0ca6ae438ffccba31c5be9d4c86",
      "ce7a4c203a84a81d6bf14dfa59852a821d72eb57df311200acabda05b64b58c6",
      "2fe93eaae22e6203068c1fc21497189e7edf427aaa6b22b0c7c20d93c3a010d5",
      "e0eb572e3663a1da816a895ec68c989722f46a1671fb513d97b8a9cf2dcdba02",
      "58b4f85e401d40b76f435521d3fb6b99ff9098f5fb225a62d75b5259907aac06",
      "7d58a4f5b42724bae1d9706e0e5fa1306d67f8f66a8a6a403c299fb3eef1d7c5",
      "fe3bc164b833634caea324db14a7d03018bd1c4160d5c4f01b335134a1cab3af",
      "a162db876d34c5f88f1c41e86e8642da9e0b55b43485753cd917c0ca7936a0ce",
      "8678fb77493ceeaf88f6370efb63538fe256a3cca265418144bbf48c5480cf07",
      "9e63354102bb7f1304f251426d2a36152f5b41ae89396c5acdf0ce30779977f7",
      "f0e03a95c5a67af7e3198b330f1f63debce44fd9421e54c4f578a3c2784ea089",
      "8e0c87093bd0267303364399390842486e1de592c4649bc3b5bea13ce6aee748",
      "c9006e8a4a24c0e6e451074c821cb1a8d211a961e93128ff188a755cc05c238a",
      "4b23051dd03cebba1c9509bf2e58a7c0a7ea867545b0118828cfc7947d4fc1f7",
      "001db16953801afeb682bedc02d0f54606593ba2df78a9dff012751ed5ea270d",
      "3de79a4628ba9d5d1ed5d9492875d12656f674c1a9f21afddf1745d3ec592d21",
      "5939a4e07bc2fa93dee701bab6058d05e0e1d3507a73c60b1d043bf293f0fbc7"
    ],
    "dummy_share_sha3_256": []
  }
}
{
  "timestamp": "2025-08-26T00:42:19.177496",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='zBDH1aglMJLXJ8cd' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:19.177972",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='zBDH1aglMJLXJ8cd', salt(b64)='HnUvS7BeEtoXBoVaPAAiIg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:19.770071",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "HnUvS7BeEtoXBoVaPAAiIg==",
      "ephemeral_password": "zBDH1aglMJLXJ8cd"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "lp02j+eNZg54l9lx8ZyS8tH2074PM8A0LRbs8pHtsRI=",
      "derived_key_b64": "lp02j+eNZg54l9lx8ZyS8tH2074PM8A0LRbs8pHtsRI=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:19.782944",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "6sLQ3XXfcBET2SSo",
    "Ciphertext(base64)": "JTPvMqWe5DATqi0rBv8eYc6OlockuBg+ZHnLMZsbPQWZ568yx86fqwCETHSINxjKEm5QBp7HcqE7kkTuZB4A8iY59W1QNu/Vd7KlJw4xCTyetv6XgIZ41UOV/EBTlHe7LNyRu/BiKm1b5YY/SiMvEHw5pqKzR0OcvVQsmNJjuKF9vqB8TttKBb/6jK1Riyja3Q==",
    "AAD_len": 148,
    "ephemeral_password": "zBDH1aglMJLXJ8cd",
    "ephemeral_salt_b64": "HnUvS7BeEtoXBoVaPAAiIg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "lp02j+eNZg54l9lx8ZyS8tH2074PM8A0LRbs8pHtsRI="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:19.783539",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='rTFYFHzJjMOw+Awe' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:19.784019",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='rTFYFHzJjMOw+Awe', salt(b64)='E9JzKl/TI35XM1x3K/+xww=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:20.328286",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "E9JzKl/TI35XM1x3K/+xww==",
      "ephemeral_password": "rTFYFHzJjMOw+Awe"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "e/QPqBlIlT+TrFwVTBlZFV8QRbUB2zxcHU2hlxrOsIE=",
      "derived_key_b64": "e/QPqBlIlT+TrFwVTBlZFV8QRbUB2zxcHU2hlxrOsIE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:20.337300",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "9F47YFSOcymXEz2N",
    "Ciphertext(base64)": "phr/xPEEGsDEyy321XNaxPJFcJbyYv7mluuUG1RTBO5ovrymArujWq/+BnApW1rscQ6paH1IzOpuOL4ocd4Y/Q/OcjWeXW7fdzU4Rl5cby7HBo/2MuJk9pfAluU9wliMnyqh67UnwrWH/JLeYtDmGwhcCULKhqO0rmB//0QG1QA8",
    "Tag(base64)": "0HpWe8dKrCzqQvGw2+eU1w==",
    "AAD_len": 141,
    "ephemeral_password": "rTFYFHzJjMOw+Awe",
    "ephemeral_salt_b64": "E9JzKl/TI35XM1x3K/+xww==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "e/QPqBlIlT+TrFwVTBlZFV8QRbUB2zxcHU2hlxrOsIE="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:20.338057",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='oiGf7JFqK3Bnn/6+' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:20.338528",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='oiGf7JFqK3Bnn/6+', salt(b64)='amUHKqtsYs1TjCIJsSQsdA=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:20.875458",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "amUHKqtsYs1TjCIJsSQsdA==",
      "ephemeral_password": "oiGf7JFqK3Bnn/6+"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "7VGVnrq0/5YZImoKoozfP3xD/GiqcZgmlpf01VqupmA=",
      "derived_key_b64": "7VGVnrq0/5YZImoKoozfP3xD/GiqcZgmlpf01VqupmA=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:20.877237",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "VrVBH0Gy3unrrY1T",
    "Ciphertext(base64)": "Qd+OQx0rA0fX9L05Z6Pj720REMtXH2SUeqF5b76laGJ3tKAW4/lCwOamNALew4EyGk37m316toZOW7WH0It/rWwhP9hW/3izF2ClcqrAWq6Wnrc04FbxMOL9m0LBPic8L6YGHAXXCk+UhiSWEOuI1YZYK81mu7NNTSS3wVC9iuYc",
    "Tag(base64)": "U4NIrJHKRwd5bncMAb6oQA==",
    "AAD_len": 141,
    "ephemeral_password": "oiGf7JFqK3Bnn/6+",
    "ephemeral_salt_b64": "amUHKqtsYs1TjCIJsSQsdA==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "7VGVnrq0/5YZImoKoozfP3xD/GiqcZgmlpf01VqupmA="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:20.878209",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='wF8lQNnqDFZBO1Vy' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:20.879080",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='wF8lQNnqDFZBO1Vy', salt(b64)='uokqSdrZXGcMoWWtcB7TWg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:21.419003",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "uokqSdrZXGcMoWWtcB7TWg==",
      "ephemeral_password": "wF8lQNnqDFZBO1Vy"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "vdSa2x9y5C4bUHWPW8y7K/OsR26/eXJF2HLsL5MYPAo=",
      "derived_key_b64": "vdSa2x9y5C4bUHWPW8y7K/OsR26/eXJF2HLsL5MYPAo=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:21.421056",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "OaIGHhv82jkg2LRb",
    "Ciphertext(base64)": "JZrbF8o3iTu3gDNrOfgfO0dEZv/TYVbkpWcKX+oNYNOm6vyP8P3pb81uc3zLvkMdDuTZGfIUCrkNCLfcM4cItgRPXgX/CMgkI7upzIkBFr2MSDg2G7EElU6oxngzy2ELLINPAueYDjiDmAXNKzbJmgkI1e2DegmE9y6HBa+4DHOsBm9ByNtHimbxmUjmGbJwBw==",
    "AAD_len": 148,
    "ephemeral_password": "wF8lQNnqDFZBO1Vy",
    "ephemeral_salt_b64": "uokqSdrZXGcMoWWtcB7TWg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "vdSa2x9y5C4bUHWPW8y7K/OsR26/eXJF2HLsL5MYPAo="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:21.422063",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='GuP7kuQvn5qJBfBl' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:21.422893",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='GuP7kuQvn5qJBfBl', salt(b64)='k6pNVx4PIjg3u4iL/UnyFw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:21.962986",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "k6pNVx4PIjg3u4iL/UnyFw==",
      "ephemeral_password": "GuP7kuQvn5qJBfBl"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "UOk1w4RPudCxdUBZlf44yMe3Nkr6Wiu1tw5WawKaoFY=",
      "derived_key_b64": "UOk1w4RPudCxdUBZlf44yMe3Nkr6Wiu1tw5WawKaoFY=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:21.964868",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "9Rf5XEome0R+A4B3",
    "Ciphertext(base64)": "TdwAufeRFabe5oxQK1peI50OZS2njdoH2KTRuvbbbCh5FEvptqxpqCSMLCF7LGRg6GHspkhIUIDMHQZl+mVlUIu9rXfXLgC2HVfb88NcyuAX95rHDgBEktqJ5lVoDdvnt0ytghS00so+4I6xH37BeGllsBPKL6tx3p8m1XtCm+BsRQj74ju2YLyqwbZF3FSAWg==",
    "AAD_len": 148,
    "ephemeral_password": "GuP7kuQvn5qJBfBl",
    "ephemeral_salt_b64": "k6pNVx4PIjg3u4iL/UnyFw==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "UOk1w4RPudCxdUBZlf44yMe3Nkr6Wiu1tw5WawKaoFY="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:21.965828",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='TrWi8GoC4xLxfDUZ' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:21.966658",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='TrWi8GoC4xLxfDUZ', salt(b64)='tosJvyaAqbEGD/A1vHVDsQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:22.496512",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "tosJvyaAqbEGD/A1vHVDsQ==",
      "ephemeral_password": "TrWi8GoC4xLxfDUZ"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "MjN6mBayuFa0q9GDZHdImX03C6kBn68+tQA8Q/iXyaU=",
      "derived_key_b64": "MjN6mBayuFa0q9GDZHdImX03C6kBn68+tQA8Q/iXyaU=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:22.497744",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "2dRcXGpGVLsN0qJ7",
    "Ciphertext(base64)": "OZ8ZMZ734rkev5WTo63AgR0lx102bmURpReqq3gE6r6I2bdVMnIyA5h70qPOeUwDGVSETyy6pFt8J4Msv/M4tN2qrA5saFx+EKosYlaEgIJ7lLE4SRvoq0UhEY+H+p7HAVqRxNVKzVHoWiVdd5yyvciVPRIfSLAr8cjsJf85z3nUEgJMs+Ac9SgAb6sIEfFfVw==",
    "AAD_len": 148,
    "ephemeral_password": "TrWi8GoC4xLxfDUZ",
    "ephemeral_salt_b64": "tosJvyaAqbEGD/A1vHVDsQ==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "MjN6mBayuFa0q9GDZHdImX03C6kBn68+tQA8Q/iXyaU="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:22.498309",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='aNB5GSgis3kHffwi' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:22.498773",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='aNB5GSgis3kHffwi', salt(b64)='KgI7A0s4dwwId/vz3GEXZg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:23.037397",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "KgI7A0s4dwwId/vz3GEXZg==",
      "ephemeral_password": "aNB5GSgis3kHffwi"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "guZwoy4mTTtv1k8h8/Vj67U4zTOTyUZFiGR7Esvthac=",
      "derived_key_b64": "guZwoy4mTTtv1k8h8/Vj67U4zTOTyUZFiGR7Esvthac=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:23.039389",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "KD+wHWbMYoV4Wzjf",
    "Ciphertext(base64)": "qjU6pJIgZRIqpBE2hvWLdrKfOJh3jlMtmfFIZOPu/0wzyHyrJVUqAyggg8+kYMlLCBGsunJrfjBcq2w5K1L4pOO99pXEx7vHJOywBCBVciQcUMavZGee1Ca6AQpsQPl3wkXe6mXenjI3Gdz13mncKYEwUFHi9RhJYvEZj0EBcvC0",
    "Tag(base64)": "5qCNgrOcTNn8QUsxFxOVtg==",
    "AAD_len": 141,
    "ephemeral_password": "aNB5GSgis3kHffwi",
    "ephemeral_salt_b64": "KgI7A0s4dwwId/vz3GEXZg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "guZwoy4mTTtv1k8h8/Vj67U4zTOTyUZFiGR7Esvthac="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:23.040316",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='3ANv/4bStIRSyqG9' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:23.041233",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='3ANv/4bStIRSyqG9', salt(b64)='YS3bIC4UWe68cAZnNgtC1Q=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:23.573595",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "YS3bIC4UWe68cAZnNgtC1Q==",
      "ephemeral_password": "3ANv/4bStIRSyqG9"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "F5DDWc6auAt5FhXw8HDNCe4slY14+ZHbSGRwQzeRB+s=",
      "derived_key_b64": "F5DDWc6auAt5FhXw8HDNCe4slY14+ZHbSGRwQzeRB+s=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:23.574811",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "EYoLodvFyiSQ4CrU",
    "Ciphertext(base64)": "2vbzNQhNozvtOlWB6kvsDfD7xN/pN4mT36MH/ihz6OP1G+7mf6sJqksB2Ioi1cmPC7wsDTg8nKMzf6cieNABl4po0+fp+4l6Xsk1429rOFtK/l1KJqdGz5rLspczGA5Ls30LZOxRM/xw3GF8dE//Bio/7nVhq0qZj11DDmUAC5YK1DaWOp08BB4B50DJCRNF5Q==",
    "AAD_len": 148,
    "ephemeral_password": "3ANv/4bStIRSyqG9",
    "ephemeral_salt_b64": "YS3bIC4UWe68cAZnNgtC1Q==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "F5DDWc6auAt5FhXw8HDNCe4slY14+ZHbSGRwQzeRB+s="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:23.575359",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='2wCktAh0i5aTKkTD' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:23.575835",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='2wCktAh0i5aTKkTD', salt(b64)='8G+VgWxd+AilcVX8R3wsMQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:24.105944",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "8G+VgWxd+AilcVX8R3wsMQ==",
      "ephemeral_password": "2wCktAh0i5aTKkTD"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "blmGQcUQy12pDSh/vvFi0QB7aW+lfxVkz/OVe8qC2XE=",
      "derived_key_b64": "blmGQcUQy12pDSh/vvFi0QB7aW+lfxVkz/OVe8qC2XE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:24.107458",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "S+K3ONZn4q56P+pN",
    "Ciphertext(base64)": "dxA1HNH6GHN6ao/zKEcErRAbX7AK0q6sRYHYl3/qPrKHeX14h9zp7VypqMmeusYfoPGwvx4qYQ1t62wccFgQFQjb0GjV71HI41y/iZSCe32WSWTej/aQ9u5fZEWR2jPWgm4+VbDn1XyaryY7JtKpxVKOGPSt6GbCnwpnT78V/m2QZEMLmLFx+4jc2+O/nxIDiw==",
    "AAD_len": 148,
    "ephemeral_password": "2wCktAh0i5aTKkTD",
    "ephemeral_salt_b64": "8G+VgWxd+AilcVX8R3wsMQ==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "blmGQcUQy12pDSh/vvFi0QB7aW+lfxVkz/OVe8qC2XE="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:24.108021",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='cNGjtQjyBUS+U+4U' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:24.108494",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='cNGjtQjyBUS+U+4U', salt(b64)='2ag10hS8vujK8xSHKjLF7A=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:24.647136",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "2ag10hS8vujK8xSHKjLF7A==",
      "ephemeral_password": "cNGjtQjyBUS+U+4U"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "Wr8tM8TvUR/ryrPeFcvfBczcBPSQzwR3HsK6iSUQXrk=",
      "derived_key_b64": "Wr8tM8TvUR/ryrPeFcvfBczcBPSQzwR3HsK6iSUQXrk=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:24.649351",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "pN9+CvtbdlvRTF2h",
    "Ciphertext(base64)": "Y4eo2+QY6EACC7xjyv2RiMPdM7i9k0YVtQxZMtEiAT68pCbnoeVilgz3hN0myTpXSfIJx+9AyLmMECLiYcUQ50Lu+zRtdCyOZRsBLZVGkAYNi/bmkjPzO09/r4i2imOxZjZ0eN7l4k+TzH8NVTVV66D+rw9LoRNCBUTbbzcmRMNQ",
    "Tag(base64)": "anUqLJb/o26H9gOaS5mu3Q==",
    "AAD_len": 141,
    "ephemeral_password": "cNGjtQjyBUS+U+4U",
    "ephemeral_salt_b64": "2ag10hS8vujK8xSHKjLF7A==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "Wr8tM8TvUR/ryrPeFcvfBczcBPSQzwR3HsK6iSUQXrk="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:24.650287",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='lYzEnCaR0FFwkZPW' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:24.651220",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='lYzEnCaR0FFwkZPW', salt(b64)='M7whaBxVKy3tpvlr2c3w1A=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:25.183535",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "M7whaBxVKy3tpvlr2c3w1A==",
      "ephemeral_password": "lYzEnCaR0FFwkZPW"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "BaCeiNFqPGXQ3JUdiGqGYdXGPhkEVyYMJHM4AXneO18=",
      "derived_key_b64": "BaCeiNFqPGXQ3JUdiGqGYdXGPhkEVyYMJHM4AXneO18=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:25.185100",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "ySGZ4GxNphrpgzPt",
    "Ciphertext(base64)": "LRpkQtjUrXgp9gXz/HpvEINLFpe3338dIMbz1C46GTooySne3zfOitsjSimPKi57ZrzQ9LKs7R+r3M9a6CEpHLaJxYIqc9e77jYQzBrpySXAJ4vGqoAb2IXwWKa0iCyfMFFpVrhACxcrxzid3Z5wI75pVYBYWreAhmxC4Oa+CYKpVwBr+SWQqWQjAGfCi+Tjvg==",
    "AAD_len": 148,
    "ephemeral_password": "lYzEnCaR0FFwkZPW",
    "ephemeral_salt_b64": "M7whaBxVKy3tpvlr2c3w1A==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "BaCeiNFqPGXQ3JUdiGqGYdXGPhkEVyYMJHM4AXneO18="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:25.185658",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='qiG1h3T5b+gH1yQR' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:25.186180",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='qiG1h3T5b+gH1yQR', salt(b64)='F4o7aOsHVFAR1+iz6o4n4g=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:25.723061",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "F4o7aOsHVFAR1+iz6o4n4g==",
      "ephemeral_password": "qiG1h3T5b+gH1yQR"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "pmrJfXVitxtA9/MhvDRdn/H02BqyM7HRHCzAKZAtkVQ=",
      "derived_key_b64": "pmrJfXVitxtA9/MhvDRdn/H02BqyM7HRHCzAKZAtkVQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:25.725019",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "bUxF750SSvUKzfK8",
    "Ciphertext(base64)": "sClcbck7MVEFkdlT722/wDTIf4ywQadMy2Idp1HCtBJJOIbWOqFKheYTt7DyMMNKSPY1Y1nv0MRQztzzyVCXF02Zqfjt+JSqx2F3JFPNyZVIxpki57v11J9TW/o4vmthSC2zojrga+plBkvhYHW36tx6ld6rdUa3OcDjB7+pQMf7",
    "Tag(base64)": "8mqsX1ovVG4DA3r/y7zttw==",
    "AAD_len": 141,
    "ephemeral_password": "qiG1h3T5b+gH1yQR",
    "ephemeral_salt_b64": "F4o7aOsHVFAR1+iz6o4n4g==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "pmrJfXVitxtA9/MhvDRdn/H02BqyM7HRHCzAKZAtkVQ="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:25.725949",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='yNWgYEITPEktmg+a' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:25.726758",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='yNWgYEITPEktmg+a', salt(b64)='Qy2LPfkVTA7VFnl/4MhCXg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:26.261929",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "Qy2LPfkVTA7VFnl/4MhCXg==",
      "ephemeral_password": "yNWgYEITPEktmg+a"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "dTZMnVueJnQZTAPRj7M9W5xcEgFiV1q/glojWKgle8Y=",
      "derived_key_b64": "dTZMnVueJnQZTAPRj7M9W5xcEgFiV1q/glojWKgle8Y=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:26.263228",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "T9PNIhOh2SLe3zfV",
    "Ciphertext(base64)": "LqoBADUGzJnHovxYPlyhDjKOp9/VpxXcPkmAKbIcuuYBGbAIqFirs38EOkWceOLM9lGiN0wYQNs+tHY6qYJaUcWNuYgKN50pidCJ2XyYmkQXN5chSOVh3Ib08PZk03otv1Lo+jG1p0FTt0w5ZGZWQAa7inJTWFqdIpWb1BCxZ24n",
    "Tag(base64)": "FoIt8wHfdkYcNtfMFsHJfA==",
    "AAD_len": 141,
    "ephemeral_password": "yNWgYEITPEktmg+a",
    "ephemeral_salt_b64": "Qy2LPfkVTA7VFnl/4MhCXg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "dTZMnVueJnQZTAPRj7M9W5xcEgFiV1q/glojWKgle8Y="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:26.263749",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='gzY8yEYGkMU/N2cI' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:26.264226",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='gzY8yEYGkMU/N2cI', salt(b64)='Vm+UMnkig2nuQgcjtC0XQA=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:26.787607",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "Vm+UMnkig2nuQgcjtC0XQA==",
      "ephemeral_password": "gzY8yEYGkMU/N2cI"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "lXVlyD9NFQoVeHD+t5qiJL1zatfNF7AcD13VxGRFADQ=",
      "derived_key_b64": "lXVlyD9NFQoVeHD+t5qiJL1zatfNF7AcD13VxGRFADQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:26.788850",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "C/evyDZ18wnhwAvU",
    "Ciphertext(base64)": "jNSxFTbccDke30m6k12K3ZS4a9nlhO9WuW19G0+/dVCfQuiKN2Uvb7HLE9fMF7Siu51Q8Sb127T0stk8UOhepuV0yjhqSe+Dy1HzAfRNX30Dpnp8xfQIG9F38iA8FZfRTsLUGI0RPdigjZTFnd7gvC0n28T36h/fOOvWocRzWFTj",
    "Tag(base64)": "Ptohynwz+b2c8CUGZP2DbA==",
    "AAD_len": 141,
    "ephemeral_password": "gzY8yEYGkMU/N2cI",
    "ephemeral_salt_b64": "Vm+UMnkig2nuQgcjtC0XQA==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "lXVlyD9NFQoVeHD+t5qiJL1zatfNF7AcD13VxGRFADQ="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:26.789380",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='jkoKYJDjxEMYgJEt' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:26.789896",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='jkoKYJDjxEMYgJEt', salt(b64)='R/W7bkXosWng+OZgqE4LBA=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:27.321545",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "R/W7bkXosWng+OZgqE4LBA==",
      "ephemeral_password": "jkoKYJDjxEMYgJEt"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "pEQLokatDVEASFjOwRxGw2i/3LUswNQKX7bp+GS3nwM=",
      "derived_key_b64": "pEQLokatDVEASFjOwRxGw2i/3LUswNQKX7bp+GS3nwM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:27.323844",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "KsYKnOTp9b5HUk3S",
    "Ciphertext(base64)": "wbagvXZooMQalLkBvXZIbUkj8WGc4X8T8jecfeIrZQOkbii/HrUlGPwkCii1Ef92+v7uyvEVyfBMhgg0ZSKwl0649MF790ntY7RPPBi40xV30T0A9fd3z/eFTw/s6jW3HeKwPLCVRNCBVDdRHIsNvd+VwlVQ2ByBN+cSoSmi5Gyf",
    "Tag(base64)": "iYObBRa+r3gwCARLf+5kZA==",
    "AAD_len": 141,
    "ephemeral_password": "jkoKYJDjxEMYgJEt",
    "ephemeral_salt_b64": "R/W7bkXosWng+OZgqE4LBA==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "pEQLokatDVEASFjOwRxGw2i/3LUswNQKX7bp+GS3nwM="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:27.324719",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='BIVkxeQydSBRUNdu' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:27.325561",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='BIVkxeQydSBRUNdu', salt(b64)='6afM55cpmWDpfJfGTPfQEw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:27.860965",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "6afM55cpmWDpfJfGTPfQEw==",
      "ephemeral_password": "BIVkxeQydSBRUNdu"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "cj0MRByKIW5x6fgQ5WNITEMuzlWEYQL7qHX72Kfkj2c=",
      "derived_key_b64": "cj0MRByKIW5x6fgQ5WNITEMuzlWEYQL7qHX72Kfkj2c=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:27.862893",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "1VpPL2AzrzZM/Spp",
    "Ciphertext(base64)": "GC4jYIu2WIFd9uqh1TD4bu8XBGiIcEMRTHm69ProfNpwUWWHX2Y2AjjWyoswJ8kZn4zBq2xktKMwkbxRZ+4IpnnxpJrxDgzuRDA1S7fjwon07NXALJDYstim6G3BjwIImba9cUSZ4Klu8QG0bvWOan6hSsstqHMZyoPAcywq4BI5/QPwmoYGz5mvReKPdqM1ig==",
    "AAD_len": 148,
    "ephemeral_password": "BIVkxeQydSBRUNdu",
    "ephemeral_salt_b64": "6afM55cpmWDpfJfGTPfQEw==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "cj0MRByKIW5x6fgQ5WNITEMuzlWEYQL7qHX72Kfkj2c="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:27.863872",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='exo8vNgy0kIo9N7H' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:27.864702",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='exo8vNgy0kIo9N7H', salt(b64)='UgqEZmJYszGOblw5z47GCg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:28.391248",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "UgqEZmJYszGOblw5z47GCg==",
      "ephemeral_password": "exo8vNgy0kIo9N7H"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "5tzGmjJZra2WSFAkXOdI1b3y9LozyYwitQUDBCwFWAA=",
      "derived_key_b64": "5tzGmjJZra2WSFAkXOdI1b3y9LozyYwitQUDBCwFWAA=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:28.392325",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "cGUOkQRwpfQPXqZ7",
    "Ciphertext(base64)": "bw5CzhRxZZ2jbz6RnPYM4+4UgJu79D7SVA1qXgpyysCP2Mm8IAqLjuBjsBOfyB1UllqU2+cjwI+XhUld7fCHwKdfxVNNt+gIh05sC8ltz5T+4Czi0KhaVHd82Ew2fMDjQ5uxGd6QxR5btygHjwT1oTWBzVPC6/Jlc1N6LYxcEAGx",
    "Tag(base64)": "OJqEh5I0QP9+2vDS/XSO1g==",
    "AAD_len": 141,
    "ephemeral_password": "exo8vNgy0kIo9N7H",
    "ephemeral_salt_b64": "UgqEZmJYszGOblw5z47GCg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "5tzGmjJZra2WSFAkXOdI1b3y9LozyYwitQUDBCwFWAA="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:28.392829",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='iqCiyo9tS+pYIlOX' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:28.393311",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='iqCiyo9tS+pYIlOX', salt(b64)='4D58JRWGYhvgfQiSs6Rjeg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:28.920716",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "4D58JRWGYhvgfQiSs6Rjeg==",
      "ephemeral_password": "iqCiyo9tS+pYIlOX"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "bUB/WHQk91WXOpg0ayKpJvUteGvvqvBUhOjIVg8pcCw=",
      "derived_key_b64": "bUB/WHQk91WXOpg0ayKpJvUteGvvqvBUhOjIVg8pcCw=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:28.922751",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "UYsYbeu/VP3EXozj",
    "Ciphertext(base64)": "NHNuQocezc13eSphnnv/C0MSx8oMFkNrQF1KgQQcF9cbL41xDlP0qdPoahPSMCwA5dDm8f0Obplt4VlrlLYTu+7PukSmlIW5YARN9OABpeAj1Cy++SLE4QU4Y+P8hhLahZr0iprXSIeNB6Ja/4870eqbLNJGj0nE1P1cScB2Uo1B",
    "Tag(base64)": "AYztSk8Mhn+00oZWaJAJgw==",
    "AAD_len": 141,
    "ephemeral_password": "iqCiyo9tS+pYIlOX",
    "ephemeral_salt_b64": "4D58JRWGYhvgfQiSs6Rjeg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "bUB/WHQk91WXOpg0ayKpJvUteGvvqvBUhOjIVg8pcCw="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:28.923533",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='mzWC9V6hlRzeNBHI' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:28.924246",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='mzWC9V6hlRzeNBHI', salt(b64)='7D6DcW9Nx+xbX1TYXv9f3g=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:29.443417",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "7D6DcW9Nx+xbX1TYXv9f3g==",
      "ephemeral_password": "mzWC9V6hlRzeNBHI"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "8UzMVGgNFRYIyLunXd+QfOuo+vWACl6pqLQV+I/ym/c=",
      "derived_key_b64": "8UzMVGgNFRYIyLunXd+QfOuo+vWACl6pqLQV+I/ym/c=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:29.445414",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "zL5Onq4HgV7jkoxQ",
    "Ciphertext(base64)": "fkAjkLir6wKgZWqnb1OI30Cpgd3ZAaFZKSYWyBdkdfP4lcD/MC3FVqSuOMLJwTLGL6vclA4F8EJAdoY6nFFVy0hCR4YMKcxbetFqBcg7rPeucKA47XznuaVpT5Kx4gAndET1RysooVgbznxUTOSYGEJ7yJvnSAz9YeIhd4lhxrWf",
    "Tag(base64)": "fLRtrzEP0Wop+p+1UgJO5w==",
    "AAD_len": 141,
    "ephemeral_password": "mzWC9V6hlRzeNBHI",
    "ephemeral_salt_b64": "7D6DcW9Nx+xbX1TYXv9f3g==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "8UzMVGgNFRYIyLunXd+QfOuo+vWACl6pqLQV+I/ym/c="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:29.446391",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='fXnmNOX7ige3MyW4' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:29.447329",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='fXnmNOX7ige3MyW4', salt(b64)='sUC1O/9PNPeWwhV+jBoKfw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:29.992554",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "sUC1O/9PNPeWwhV+jBoKfw==",
      "ephemeral_password": "fXnmNOX7ige3MyW4"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "a2u78GClKlszNaRin+f+wg3b0xJr7e8PzjmHrVZQFE8=",
      "derived_key_b64": "a2u78GClKlszNaRin+f+wg3b0xJr7e8PzjmHrVZQFE8=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:29.994569",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "kjpMjt1aejyDU4qY",
    "Ciphertext(base64)": "F95gV8UxYCBDOCOe/+LjsGw7wKwbm5y/PmC9XTAE6iEX11rQjVPZirSgVXseWX6NMmPjZDEwq/hAZdbxAKeFCGcAakE+OouyyIi3sJUdxVpHuPMmLNe5BwS1HFGoaAY8g48DBBmEOBTtI79lnpWfNTWIB9T5gb4MgxzCeirqVrPIpYA1WCpHvrG669SvdupLhg==",
    "AAD_len": 148,
    "ephemeral_password": "fXnmNOX7ige3MyW4",
    "ephemeral_salt_b64": "sUC1O/9PNPeWwhV+jBoKfw==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "a2u78GClKlszNaRin+f+wg3b0xJr7e8PzjmHrVZQFE8="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:29.995642",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='RNwvAlCPZGxzOeD5' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:29.996574",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='RNwvAlCPZGxzOeD5', salt(b64)='az8lbNV+D8ZdEPMDi9NWzg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:30.557319",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "az8lbNV+D8ZdEPMDi9NWzg==",
      "ephemeral_password": "RNwvAlCPZGxzOeD5"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "9baShUwZ6soI8td1T71YRDFW7VH2D+WGGvvcH9H1fMM=",
      "derived_key_b64": "9baShUwZ6soI8td1T71YRDFW7VH2D+WGGvvcH9H1fMM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:30.559404",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "Xrg3mL4039aKyPSa",
    "Ciphertext(base64)": "6lUuyTnvBA+1PII2Kwnroj/lObxduD+XM6KLjNOVZkz+Gdl1wPoj8Tohg0Nk1iJfiJS+GIbOcWW6v1R3q3EgSKLovXRqrRu2I1ezAULl/o7WYw9GQoTuEfQ2/0Sucxvzxa8co2ebBmQiBLyXZXZDdAvR59Kskxbh05RN2F8jZqJT",
    "Tag(base64)": "c14t+Fhg4P9/wFJiqYuKUg==",
    "AAD_len": 141,
    "ephemeral_password": "RNwvAlCPZGxzOeD5",
    "ephemeral_salt_b64": "az8lbNV+D8ZdEPMDi9NWzg==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "9baShUwZ6soI8td1T71YRDFW7VH2D+WGGvvcH9H1fMM="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:30.560385",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='TfPILUeL/sU3crQx' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:30.561223",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='TfPILUeL/sU3crQx', salt(b64)='L6Yq6DnqFRpDkbtGtrczPw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:31.105830",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "L6Yq6DnqFRpDkbtGtrczPw==",
      "ephemeral_password": "TfPILUeL/sU3crQx"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "TBKXLTHDH41RWJritHnYEIN41qL7OVO2Gv+1VFXyNO0=",
      "derived_key_b64": "TBKXLTHDH41RWJritHnYEIN41qL7OVO2Gv+1VFXyNO0=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:31.107019",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "g7cUC4j2u5mkLTeB",
    "Ciphertext(base64)": "37o7ii8vzB2pmFplIcYdq8Ev6ctcGiv3tJ9UZZcdxCGHOMbhTCkQ8emL31862xMueWVKEa5zirhBw42jBduDoLAEKi95KUo+IWM0rR7cODLjFn/mDim9WGXPunatrmxJodXKjDAbarMac3YpK60GTw2rP/s3AT0wAY0HKVJndmBPHiQHWBlERZLSZBtaQJOXVA==",
    "AAD_len": 148,
    "ephemeral_password": "TfPILUeL/sU3crQx",
    "ephemeral_salt_b64": "L6Yq6DnqFRpDkbtGtrczPw==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "TBKXLTHDH41RWJritHnYEIN41qL7OVO2Gv+1VFXyNO0="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:31.107541",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='wKzf5m1bsBsvEJuj' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:31.107993",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='wKzf5m1bsBsvEJuj', salt(b64)='dQXwphJEq81A2Ye+rjWMVw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:31.646627",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "dQXwphJEq81A2Ye+rjWMVw==",
      "ephemeral_password": "wKzf5m1bsBsvEJuj"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "P1L+BSOWF2dk2PwS0gUZmV/dXqorIc7rGKImrerlz6o=",
      "derived_key_b64": "P1L+BSOWF2dk2PwS0gUZmV/dXqorIc7rGKImrerlz6o=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:31.648593",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "sg8byn0WdRqp9M1C",
    "Ciphertext(base64)": "xAp3sDifamzLVIrwFF9HsObed5IEExeJ5EqG4Ahax2zHr2CFUkAeAixyWMzNEfaMe5ktqdKczy4CO2KJC1QzioC0/wr8w7ReXUsgJJ+w7JBZwCIbdsQ8+FP8LA3t89qM4A9AaSHSeIBUdL/UVjYJuebl1XHW8Q+3NBVX74V3lkQg",
    "Tag(base64)": "QLZTqjEeYap9wmqI7vDRNw==",
    "AAD_len": 141,
    "ephemeral_password": "wKzf5m1bsBsvEJuj",
    "ephemeral_salt_b64": "dQXwphJEq81A2Ye+rjWMVw==",
    "crypto_details": {
      "operation": "Encrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "P1L+BSOWF2dk2PwS0gUZmV/dXqorIc7rGKImrerlz6o="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:33.719924",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q1 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:33.908992",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q2 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.033712",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q3 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.218064",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q4 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.341262",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q5 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.466026",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q6 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.653950",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q7 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.777384",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q8 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:34.964900",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Q9 final picks",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:37.210151",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "User finalize => combine secrets now.",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:37.210955",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='zBDH1aglMJLXJ8cd' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:37.211415",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='zBDH1aglMJLXJ8cd', salt(b64)='HnUvS7BeEtoXBoVaPAAiIg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:37.710116",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "HnUvS7BeEtoXBoVaPAAiIg==",
      "ephemeral_password": "zBDH1aglMJLXJ8cd"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "lp02j+eNZg54l9lx8ZyS8tH2074PM8A0LRbs8pHtsRI=",
      "derived_key_b64": "lp02j+eNZg54l9lx8ZyS8tH2074PM8A0LRbs8pHtsRI=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:37.711964",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "6sLQ3XXfcBET2SSo",
    "Ciphertext(base64)": "JTPvMqWe5DATqi0rBv8eYc6OlockuBg+ZHnLMZsbPQWZ568yx86fqwCETHSINxjKEm5QBp7HcqE7kkTuZB4A8iY59W1QNu/Vd7KlJw4xCTyetv6XgIZ41UOV/EBTlHe7LNyRu/BiKm1b5YY/SiMvEHw5pqKzR0OcvVQsmNJjuKF9vqB8TttKBb/6jK1Riyja3Q==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "lp02j+eNZg54l9lx8ZyS8tH2074PM8A0LRbs8pHtsRI="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:37.712926",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:37.713703",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='rTFYFHzJjMOw+Awe' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:37.714578",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='rTFYFHzJjMOw+Awe', salt(b64)='E9JzKl/TI35XM1x3K/+xww=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:38.212297",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "E9JzKl/TI35XM1x3K/+xww==",
      "ephemeral_password": "rTFYFHzJjMOw+Awe"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "e/QPqBlIlT+TrFwVTBlZFV8QRbUB2zxcHU2hlxrOsIE=",
      "derived_key_b64": "e/QPqBlIlT+TrFwVTBlZFV8QRbUB2zxcHU2hlxrOsIE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:38.213514",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "9F47YFSOcymXEz2N",
    "Ciphertext(base64)": "phr/xPEEGsDEyy321XNaxPJFcJbyYv7mluuUG1RTBO5ovrymArujWq/+BnApW1rscQ6paH1IzOpuOL4ocd4Y/Q/OcjWeXW7fdzU4Rl5cby7HBo/2MuJk9pfAluU9wliMnyqh67UnwrWH/JLeYtDmGwhcCULKhqO0rmB//0QG1QA8",
    "Tag(base64)": "0HpWe8dKrCzqQvGw2+eU1w==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "e/QPqBlIlT+TrFwVTBlZFV8QRbUB2zxcHU2hlxrOsIE="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:38.219153",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:38.220153",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='oiGf7JFqK3Bnn/6+' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:38.220632",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='oiGf7JFqK3Bnn/6+', salt(b64)='amUHKqtsYs1TjCIJsSQsdA=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:38.745364",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "amUHKqtsYs1TjCIJsSQsdA==",
      "ephemeral_password": "oiGf7JFqK3Bnn/6+"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "7VGVnrq0/5YZImoKoozfP3xD/GiqcZgmlpf01VqupmA=",
      "derived_key_b64": "7VGVnrq0/5YZImoKoozfP3xD/GiqcZgmlpf01VqupmA=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:38.746510",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "VrVBH0Gy3unrrY1T",
    "Ciphertext(base64)": "Qd+OQx0rA0fX9L05Z6Pj720REMtXH2SUeqF5b76laGJ3tKAW4/lCwOamNALew4EyGk37m316toZOW7WH0It/rWwhP9hW/3izF2ClcqrAWq6Wnrc04FbxMOL9m0LBPic8L6YGHAXXCk+UhiSWEOuI1YZYK81mu7NNTSS3wVC9iuYc",
    "Tag(base64)": "U4NIrJHKRwd5bncMAb6oQA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "7VGVnrq0/5YZImoKoozfP3xD/GiqcZgmlpf01VqupmA="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:38.747103",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:38.747589",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='wF8lQNnqDFZBO1Vy' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:38.748032",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='wF8lQNnqDFZBO1Vy', salt(b64)='uokqSdrZXGcMoWWtcB7TWg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:39.271678",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "uokqSdrZXGcMoWWtcB7TWg==",
      "ephemeral_password": "wF8lQNnqDFZBO1Vy"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "vdSa2x9y5C4bUHWPW8y7K/OsR26/eXJF2HLsL5MYPAo=",
      "derived_key_b64": "vdSa2x9y5C4bUHWPW8y7K/OsR26/eXJF2HLsL5MYPAo=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:39.273323",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "OaIGHhv82jkg2LRb",
    "Ciphertext(base64)": "JZrbF8o3iTu3gDNrOfgfO0dEZv/TYVbkpWcKX+oNYNOm6vyP8P3pb81uc3zLvkMdDuTZGfIUCrkNCLfcM4cItgRPXgX/CMgkI7upzIkBFr2MSDg2G7EElU6oxngzy2ELLINPAueYDjiDmAXNKzbJmgkI1e2DegmE9y6HBa+4DHOsBm9ByNtHimbxmUjmGbJwBw==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "vdSa2x9y5C4bUHWPW8y7K/OsR26/eXJF2HLsL5MYPAo="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:39.274130",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:39.274971",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='GuP7kuQvn5qJBfBl' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:39.275670",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='GuP7kuQvn5qJBfBl', salt(b64)='k6pNVx4PIjg3u4iL/UnyFw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:39.766932",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "k6pNVx4PIjg3u4iL/UnyFw==",
      "ephemeral_password": "GuP7kuQvn5qJBfBl"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "UOk1w4RPudCxdUBZlf44yMe3Nkr6Wiu1tw5WawKaoFY=",
      "derived_key_b64": "UOk1w4RPudCxdUBZlf44yMe3Nkr6Wiu1tw5WawKaoFY=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:39.768110",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "9Rf5XEome0R+A4B3",
    "Ciphertext(base64)": "TdwAufeRFabe5oxQK1peI50OZS2njdoH2KTRuvbbbCh5FEvptqxpqCSMLCF7LGRg6GHspkhIUIDMHQZl+mVlUIu9rXfXLgC2HVfb88NcyuAX95rHDgBEktqJ5lVoDdvnt0ytghS00so+4I6xH37BeGllsBPKL6tx3p8m1XtCm+BsRQj74ju2YLyqwbZF3FSAWg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "UOk1w4RPudCxdUBZlf44yMe3Nkr6Wiu1tw5WawKaoFY="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:39.768652",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:39.769123",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='TrWi8GoC4xLxfDUZ' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:39.769542",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='TrWi8GoC4xLxfDUZ', salt(b64)='tosJvyaAqbEGD/A1vHVDsQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:40.263343",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "tosJvyaAqbEGD/A1vHVDsQ==",
      "ephemeral_password": "TrWi8GoC4xLxfDUZ"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "MjN6mBayuFa0q9GDZHdImX03C6kBn68+tQA8Q/iXyaU=",
      "derived_key_b64": "MjN6mBayuFa0q9GDZHdImX03C6kBn68+tQA8Q/iXyaU=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:40.265111",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "2dRcXGpGVLsN0qJ7",
    "Ciphertext(base64)": "OZ8ZMZ734rkev5WTo63AgR0lx102bmURpReqq3gE6r6I2bdVMnIyA5h70qPOeUwDGVSETyy6pFt8J4Msv/M4tN2qrA5saFx+EKosYlaEgIJ7lLE4SRvoq0UhEY+H+p7HAVqRxNVKzVHoWiVdd5yyvciVPRIfSLAr8cjsJf85z3nUEgJMs+Ac9SgAb6sIEfFfVw==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "MjN6mBayuFa0q9GDZHdImX03C6kBn68+tQA8Q/iXyaU="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:40.265927",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:40.266647",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='aNB5GSgis3kHffwi' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:40.267353",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='aNB5GSgis3kHffwi', salt(b64)='KgI7A0s4dwwId/vz3GEXZg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:40.779167",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "KgI7A0s4dwwId/vz3GEXZg==",
      "ephemeral_password": "aNB5GSgis3kHffwi"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "guZwoy4mTTtv1k8h8/Vj67U4zTOTyUZFiGR7Esvthac=",
      "derived_key_b64": "guZwoy4mTTtv1k8h8/Vj67U4zTOTyUZFiGR7Esvthac=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:40.780360",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "KD+wHWbMYoV4Wzjf",
    "Ciphertext(base64)": "qjU6pJIgZRIqpBE2hvWLdrKfOJh3jlMtmfFIZOPu/0wzyHyrJVUqAyggg8+kYMlLCBGsunJrfjBcq2w5K1L4pOO99pXEx7vHJOywBCBVciQcUMavZGee1Ca6AQpsQPl3wkXe6mXenjI3Gdz13mncKYEwUFHi9RhJYvEZj0EBcvC0",
    "Tag(base64)": "5qCNgrOcTNn8QUsxFxOVtg==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "guZwoy4mTTtv1k8h8/Vj67U4zTOTyUZFiGR7Esvthac="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:40.781042",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:40.781559",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='3ANv/4bStIRSyqG9' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:40.782025",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='3ANv/4bStIRSyqG9', salt(b64)='YS3bIC4UWe68cAZnNgtC1Q=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:41.322800",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "YS3bIC4UWe68cAZnNgtC1Q==",
      "ephemeral_password": "3ANv/4bStIRSyqG9"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "F5DDWc6auAt5FhXw8HDNCe4slY14+ZHbSGRwQzeRB+s=",
      "derived_key_b64": "F5DDWc6auAt5FhXw8HDNCe4slY14+ZHbSGRwQzeRB+s=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:41.324323",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "EYoLodvFyiSQ4CrU",
    "Ciphertext(base64)": "2vbzNQhNozvtOlWB6kvsDfD7xN/pN4mT36MH/ihz6OP1G+7mf6sJqksB2Ioi1cmPC7wsDTg8nKMzf6cieNABl4po0+fp+4l6Xsk1429rOFtK/l1KJqdGz5rLspczGA5Ls30LZOxRM/xw3GF8dE//Bio/7nVhq0qZj11DDmUAC5YK1DaWOp08BB4B50DJCRNF5Q==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "F5DDWc6auAt5FhXw8HDNCe4slY14+ZHbSGRwQzeRB+s="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:41.325181",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:41.325969",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='2wCktAh0i5aTKkTD' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:41.326678",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='2wCktAh0i5aTKkTD', salt(b64)='8G+VgWxd+AilcVX8R3wsMQ=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:41.859043",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "8G+VgWxd+AilcVX8R3wsMQ==",
      "ephemeral_password": "2wCktAh0i5aTKkTD"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "blmGQcUQy12pDSh/vvFi0QB7aW+lfxVkz/OVe8qC2XE=",
      "derived_key_b64": "blmGQcUQy12pDSh/vvFi0QB7aW+lfxVkz/OVe8qC2XE=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:41.860165",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "S+K3ONZn4q56P+pN",
    "Ciphertext(base64)": "dxA1HNH6GHN6ao/zKEcErRAbX7AK0q6sRYHYl3/qPrKHeX14h9zp7VypqMmeusYfoPGwvx4qYQ1t62wccFgQFQjb0GjV71HI41y/iZSCe32WSWTej/aQ9u5fZEWR2jPWgm4+VbDn1XyaryY7JtKpxVKOGPSt6GbCnwpnT78V/m2QZEMLmLFx+4jc2+O/nxIDiw==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "blmGQcUQy12pDSh/vvFi0QB7aW+lfxVkz/OVe8qC2XE="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:41.860740",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:41.861219",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='cNGjtQjyBUS+U+4U' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:41.861673",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='cNGjtQjyBUS+U+4U', salt(b64)='2ag10hS8vujK8xSHKjLF7A=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:42.400678",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "2ag10hS8vujK8xSHKjLF7A==",
      "ephemeral_password": "cNGjtQjyBUS+U+4U"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "Wr8tM8TvUR/ryrPeFcvfBczcBPSQzwR3HsK6iSUQXrk=",
      "derived_key_b64": "Wr8tM8TvUR/ryrPeFcvfBczcBPSQzwR3HsK6iSUQXrk=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:42.402678",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "pN9+CvtbdlvRTF2h",
    "Ciphertext(base64)": "Y4eo2+QY6EACC7xjyv2RiMPdM7i9k0YVtQxZMtEiAT68pCbnoeVilgz3hN0myTpXSfIJx+9AyLmMECLiYcUQ50Lu+zRtdCyOZRsBLZVGkAYNi/bmkjPzO09/r4i2imOxZjZ0eN7l4k+TzH8NVTVV66D+rw9LoRNCBUTbbzcmRMNQ",
    "Tag(base64)": "anUqLJb/o26H9gOaS5mu3Q==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "Wr8tM8TvUR/ryrPeFcvfBczcBPSQzwR3HsK6iSUQXrk="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:42.403995",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:42.404972",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='fXnmNOX7ige3MyW4' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:42.405881",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='fXnmNOX7ige3MyW4', salt(b64)='sUC1O/9PNPeWwhV+jBoKfw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:42.901983",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "sUC1O/9PNPeWwhV+jBoKfw==",
      "ephemeral_password": "fXnmNOX7ige3MyW4"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "a2u78GClKlszNaRin+f+wg3b0xJr7e8PzjmHrVZQFE8=",
      "derived_key_b64": "a2u78GClKlszNaRin+f+wg3b0xJr7e8PzjmHrVZQFE8=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:42.902954",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "kjpMjt1aejyDU4qY",
    "Ciphertext(base64)": "F95gV8UxYCBDOCOe/+LjsGw7wKwbm5y/PmC9XTAE6iEX11rQjVPZirSgVXseWX6NMmPjZDEwq/hAZdbxAKeFCGcAakE+OouyyIi3sJUdxVpHuPMmLNe5BwS1HFGoaAY8g48DBBmEOBTtI79lnpWfNTWIB9T5gb4MgxzCeirqVrPIpYA1WCpHvrG669SvdupLhg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "a2u78GClKlszNaRin+f+wg3b0xJr7e8PzjmHrVZQFE8="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:42.903711",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:42.904286",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='RNwvAlCPZGxzOeD5' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:42.904759",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='RNwvAlCPZGxzOeD5', salt(b64)='az8lbNV+D8ZdEPMDi9NWzg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:43.450307",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "az8lbNV+D8ZdEPMDi9NWzg==",
      "ephemeral_password": "RNwvAlCPZGxzOeD5"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "9baShUwZ6soI8td1T71YRDFW7VH2D+WGGvvcH9H1fMM=",
      "derived_key_b64": "9baShUwZ6soI8td1T71YRDFW7VH2D+WGGvvcH9H1fMM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:43.451458",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "Xrg3mL4039aKyPSa",
    "Ciphertext(base64)": "6lUuyTnvBA+1PII2Kwnroj/lObxduD+XM6KLjNOVZkz+Gdl1wPoj8Tohg0Nk1iJfiJS+GIbOcWW6v1R3q3EgSKLovXRqrRu2I1ezAULl/o7WYw9GQoTuEfQ2/0Sucxvzxa8co2ebBmQiBLyXZXZDdAvR59Kskxbh05RN2F8jZqJT",
    "Tag(base64)": "c14t+Fhg4P9/wFJiqYuKUg==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "9baShUwZ6soI8td1T71YRDFW7VH2D+WGGvvcH9H1fMM="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:43.452099",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:43.452718",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='TfPILUeL/sU3crQx' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:43.453203",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='TfPILUeL/sU3crQx', salt(b64)='L6Yq6DnqFRpDkbtGtrczPw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:43.989076",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "L6Yq6DnqFRpDkbtGtrczPw==",
      "ephemeral_password": "TfPILUeL/sU3crQx"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "TBKXLTHDH41RWJritHnYEIN41qL7OVO2Gv+1VFXyNO0=",
      "derived_key_b64": "TBKXLTHDH41RWJritHnYEIN41qL7OVO2Gv+1VFXyNO0=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:43.990891",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "g7cUC4j2u5mkLTeB",
    "Ciphertext(base64)": "37o7ii8vzB2pmFplIcYdq8Ev6ctcGiv3tJ9UZZcdxCGHOMbhTCkQ8emL31862xMueWVKEa5zirhBw42jBduDoLAEKi95KUo+IWM0rR7cODLjFn/mDim9WGXPunatrmxJodXKjDAbarMac3YpK60GTw2rP/s3AT0wAY0HKVJndmBPHiQHWBlERZLSZBtaQJOXVA==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "TBKXLTHDH41RWJritHnYEIN41qL7OVO2Gv+1VFXyNO0="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:43.991903",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:43.992747",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='wKzf5m1bsBsvEJuj' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:43.993613",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='wKzf5m1bsBsvEJuj', salt(b64)='dQXwphJEq81A2Ye+rjWMVw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:44.544559",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "dQXwphJEq81A2Ye+rjWMVw==",
      "ephemeral_password": "wKzf5m1bsBsvEJuj"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "P1L+BSOWF2dk2PwS0gUZmV/dXqorIc7rGKImrerlz6o=",
      "derived_key_b64": "P1L+BSOWF2dk2PwS0gUZmV/dXqorIc7rGKImrerlz6o=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:44.546306",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "sg8byn0WdRqp9M1C",
    "Ciphertext(base64)": "xAp3sDifamzLVIrwFF9HsObed5IEExeJ5EqG4Ahax2zHr2CFUkAeAixyWMzNEfaMe5ktqdKczy4CO2KJC1QzioC0/wr8w7ReXUsgJJ+w7JBZwCIbdsQ8+FP8LA3t89qM4A9AaSHSeIBUdL/UVjYJuebl1XHW8Q+3NBVX74V3lkQg",
    "Tag(base64)": "QLZTqjEeYap9wmqI7vDRNw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "P1L+BSOWF2dk2PwS0gUZmV/dXqorIc7rGKImrerlz6o="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:44.547333",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:44.548331",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='lYzEnCaR0FFwkZPW' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:44.549133",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='lYzEnCaR0FFwkZPW', salt(b64)='M7whaBxVKy3tpvlr2c3w1A=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:45.072992",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "M7whaBxVKy3tpvlr2c3w1A==",
      "ephemeral_password": "lYzEnCaR0FFwkZPW"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "BaCeiNFqPGXQ3JUdiGqGYdXGPhkEVyYMJHM4AXneO18=",
      "derived_key_b64": "BaCeiNFqPGXQ3JUdiGqGYdXGPhkEVyYMJHM4AXneO18=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:45.074140",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "ySGZ4GxNphrpgzPt",
    "Ciphertext(base64)": "LRpkQtjUrXgp9gXz/HpvEINLFpe3338dIMbz1C46GTooySne3zfOitsjSimPKi57ZrzQ9LKs7R+r3M9a6CEpHLaJxYIqc9e77jYQzBrpySXAJ4vGqoAb2IXwWKa0iCyfMFFpVrhACxcrxzid3Z5wI75pVYBYWreAhmxC4Oa+CYKpVwBr+SWQqWQjAGfCi+Tjvg==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "BaCeiNFqPGXQ3JUdiGqGYdXGPhkEVyYMJHM4AXneO18="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:45.074695",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:45.075157",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='qiG1h3T5b+gH1yQR' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:45.075611",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='qiG1h3T5b+gH1yQR', salt(b64)='F4o7aOsHVFAR1+iz6o4n4g=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:45.599421",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "F4o7aOsHVFAR1+iz6o4n4g==",
      "ephemeral_password": "qiG1h3T5b+gH1yQR"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "pmrJfXVitxtA9/MhvDRdn/H02BqyM7HRHCzAKZAtkVQ=",
      "derived_key_b64": "pmrJfXVitxtA9/MhvDRdn/H02BqyM7HRHCzAKZAtkVQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:45.600760",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "bUxF750SSvUKzfK8",
    "Ciphertext(base64)": "sClcbck7MVEFkdlT722/wDTIf4ywQadMy2Idp1HCtBJJOIbWOqFKheYTt7DyMMNKSPY1Y1nv0MRQztzzyVCXF02Zqfjt+JSqx2F3JFPNyZVIxpki57v11J9TW/o4vmthSC2zojrga+plBkvhYHW36tx6ld6rdUa3OcDjB7+pQMf7",
    "Tag(base64)": "8mqsX1ovVG4DA3r/y7zttw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "pmrJfXVitxtA9/MhvDRdn/H02BqyM7HRHCzAKZAtkVQ="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:45.601320",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:45.601772",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='yNWgYEITPEktmg+a' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:45.602277",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='yNWgYEITPEktmg+a', salt(b64)='Qy2LPfkVTA7VFnl/4MhCXg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:46.122468",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "Qy2LPfkVTA7VFnl/4MhCXg==",
      "ephemeral_password": "yNWgYEITPEktmg+a"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "dTZMnVueJnQZTAPRj7M9W5xcEgFiV1q/glojWKgle8Y=",
      "derived_key_b64": "dTZMnVueJnQZTAPRj7M9W5xcEgFiV1q/glojWKgle8Y=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:46.124180",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "T9PNIhOh2SLe3zfV",
    "Ciphertext(base64)": "LqoBADUGzJnHovxYPlyhDjKOp9/VpxXcPkmAKbIcuuYBGbAIqFirs38EOkWceOLM9lGiN0wYQNs+tHY6qYJaUcWNuYgKN50pidCJ2XyYmkQXN5chSOVh3Ib08PZk03otv1Lo+jG1p0FTt0w5ZGZWQAa7inJTWFqdIpWb1BCxZ24n",
    "Tag(base64)": "FoIt8wHfdkYcNtfMFsHJfA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "dTZMnVueJnQZTAPRj7M9W5xcEgFiV1q/glojWKgle8Y="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:46.125281",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:46.126125",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='gzY8yEYGkMU/N2cI' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:46.126971",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='gzY8yEYGkMU/N2cI', salt(b64)='Vm+UMnkig2nuQgcjtC0XQA=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:46.659377",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "Vm+UMnkig2nuQgcjtC0XQA==",
      "ephemeral_password": "gzY8yEYGkMU/N2cI"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "lXVlyD9NFQoVeHD+t5qiJL1zatfNF7AcD13VxGRFADQ=",
      "derived_key_b64": "lXVlyD9NFQoVeHD+t5qiJL1zatfNF7AcD13VxGRFADQ=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:46.660384",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "C/evyDZ18wnhwAvU",
    "Ciphertext(base64)": "jNSxFTbccDke30m6k12K3ZS4a9nlhO9WuW19G0+/dVCfQuiKN2Uvb7HLE9fMF7Siu51Q8Sb127T0stk8UOhepuV0yjhqSe+Dy1HzAfRNX30Dpnp8xfQIG9F38iA8FZfRTsLUGI0RPdigjZTFnd7gvC0n28T36h/fOOvWocRzWFTj",
    "Tag(base64)": "Ptohynwz+b2c8CUGZP2DbA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "lXVlyD9NFQoVeHD+t5qiJL1zatfNF7AcD13VxGRFADQ="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:46.660966",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:46.661460",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='jkoKYJDjxEMYgJEt' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:46.661903",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='jkoKYJDjxEMYgJEt', salt(b64)='R/W7bkXosWng+OZgqE4LBA=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:47.204336",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "R/W7bkXosWng+OZgqE4LBA==",
      "ephemeral_password": "jkoKYJDjxEMYgJEt"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "pEQLokatDVEASFjOwRxGw2i/3LUswNQKX7bp+GS3nwM=",
      "derived_key_b64": "pEQLokatDVEASFjOwRxGw2i/3LUswNQKX7bp+GS3nwM=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:47.205348",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "KsYKnOTp9b5HUk3S",
    "Ciphertext(base64)": "wbagvXZooMQalLkBvXZIbUkj8WGc4X8T8jecfeIrZQOkbii/HrUlGPwkCii1Ef92+v7uyvEVyfBMhgg0ZSKwl0649MF790ntY7RPPBi40xV30T0A9fd3z/eFTw/s6jW3HeKwPLCVRNCBVDdRHIsNvd+VwlVQ2ByBN+cSoSmi5Gyf",
    "Tag(base64)": "iYObBRa+r3gwCARLf+5kZA==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "pEQLokatDVEASFjOwRxGw2i/3LUswNQKX7bp+GS3nwM="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:47.206005",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:47.206487",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='BIVkxeQydSBRUNdu' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:47.206938",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='BIVkxeQydSBRUNdu', salt(b64)='6afM55cpmWDpfJfGTPfQEw=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:47.749678",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "6afM55cpmWDpfJfGTPfQEw==",
      "ephemeral_password": "BIVkxeQydSBRUNdu"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "cj0MRByKIW5x6fgQ5WNITEMuzlWEYQL7qHX72Kfkj2c=",
      "derived_key_b64": "cj0MRByKIW5x6fgQ5WNITEMuzlWEYQL7qHX72Kfkj2c=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:47.751518",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "1VpPL2AzrzZM/Spp",
    "Ciphertext(base64)": "GC4jYIu2WIFd9uqh1TD4bu8XBGiIcEMRTHm69ProfNpwUWWHX2Y2AjjWyoswJ8kZn4zBq2xktKMwkbxRZ+4IpnnxpJrxDgzuRDA1S7fjwon07NXALJDYstim6G3BjwIImba9cUSZ4Klu8QG0bvWOan6hSsstqHMZyoPAcywq4BI5/QPwmoYGz5mvReKPdqM1ig==",
    "AAD_len": 148,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "ChaCha20-Poly1305",
      "mode": "Poly1305",
      "ephemeral": true,
      "key_b64": "cj0MRByKIW5x6fgQ5WNITEMuzlWEYQL7qHX72Kfkj2c="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:47.752480",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "ERROR",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_error",
    "line": 227
  },
  "message": "Decryption failed for a selected answer.",
  "details": {
    "exception_type": "InvalidTag",
    "exception_str": ""
  }
}
{
  "timestamp": "2025-08-26T00:42:47.753350",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='exo8vNgy0kIo9N7H' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:47.754321",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='exo8vNgy0kIo9N7H', salt(b64)='UgqEZmJYszGOblw5z47GCg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:48.277365",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "UgqEZmJYszGOblw5z47GCg==",
      "ephemeral_password": "exo8vNgy0kIo9N7H"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "5tzGmjJZra2WSFAkXOdI1b3y9LozyYwitQUDBCwFWAA=",
      "derived_key_b64": "5tzGmjJZra2WSFAkXOdI1b3y9LozyYwitQUDBCwFWAA=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:48.278968",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "cGUOkQRwpfQPXqZ7",
    "Ciphertext(base64)": "bw5CzhRxZZ2jbz6RnPYM4+4UgJu79D7SVA1qXgpyysCP2Mm8IAqLjuBjsBOfyB1UllqU2+cjwI+XhUld7fCHwKdfxVNNt+gIh05sC8ltz5T+4Czi0KhaVHd82Ew2fMDjQ5uxGd6QxR5btygHjwT1oTWBzVPC6/Jlc1N6LYxcEAGx",
    "Tag(base64)": "OJqEh5I0QP9+2vDS/XSO1g==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "5tzGmjJZra2WSFAkXOdI1b3y9LozyYwitQUDBCwFWAA="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:48.279856",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Demo path decrypted share.",
  "details": {
    "share_sha3_256_hex": "f0e03a95c5a67af7e3198b330f1f63debce44fd9421e54c4f578a3c2784ea089",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-26T00:42:48.280657",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='iqCiyo9tS+pYIlOX' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:48.281356",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='iqCiyo9tS+pYIlOX', salt(b64)='4D58JRWGYhvgfQiSs6Rjeg=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:48.799472",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "4D58JRWGYhvgfQiSs6Rjeg==",
      "ephemeral_password": "iqCiyo9tS+pYIlOX"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "bUB/WHQk91WXOpg0ayKpJvUteGvvqvBUhOjIVg8pcCw=",
      "derived_key_b64": "bUB/WHQk91WXOpg0ayKpJvUteGvvqvBUhOjIVg8pcCw=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:48.801328",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "UYsYbeu/VP3EXozj",
    "Ciphertext(base64)": "NHNuQocezc13eSphnnv/C0MSx8oMFkNrQF1KgQQcF9cbL41xDlP0qdPoahPSMCwA5dDm8f0Obplt4VlrlLYTu+7PukSmlIW5YARN9OABpeAj1Cy++SLE4QU4Y+P8hhLahZr0iprXSIeNB6Ja/4870eqbLNJGj0nE1P1cScB2Uo1B",
    "Tag(base64)": "AYztSk8Mhn+00oZWaJAJgw==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "bUB/WHQk91WXOpg0ayKpJvUteGvvqvBUhOjIVg8pcCw="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:48.802409",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Demo path decrypted share.",
  "details": {
    "share_sha3_256_hex": "8e0c87093bd0267303364399390842486e1de592c4649bc3b5bea13ce6aee748",
    "algorithm": "aes256gcm"
  }
}
{
  "timestamp": "2025-08-26T00:42:48.803257",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using ephemeral password='mzWC9V6hlRzeNBHI' (raw).",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:48.804082",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Starting Argon2id KDF (RAW). pass='mzWC9V6hlRzeNBHI', salt(b64)='7D6DcW9Nx+xbX1TYXv9f3g=='",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:42:49.326883",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "message": "Argon2id RAW complete. Derived key is in logs.",
    "ephemeral_info": {
      "salt_b64": "7D6DcW9Nx+xbX1TYXv9f3g==",
      "ephemeral_password": "mzWC9V6hlRzeNBHI"
    },
    "crypto_details": {
      "operation": "KDF Derive",
      "algorithm": "Argon2id",
      "mode": null,
      "ephemeral": true,
      "key_b64": "8UzMVGgNFRYIyLunXd+QfOuo+vWACl6pqLQV+I/ym/c=",
      "derived_key_b64": "8UzMVGgNFRYIyLunXd+QfOuo+vWACl6pqLQV+I/ym/c=",
      "Argon2_Parameters": {
        "time_cost": 3,
        "memory_cost": 262144,
        "parallelism": 1,
        "key_length": 32
      }
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:49.328089",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_crypto_event",
    "line": 218
  },
  "message": "Crypto operation",
  "details": {
    "Nonce(base64)": "zL5Onq4HgV7jkoxQ",
    "Ciphertext(base64)": "fkAjkLir6wKgZWqnb1OI30Cpgd3ZAaFZKSYWyBdkdfP4lcD/MC3FVqSuOMLJwTLGL6vclA4F8EJAdoY6nFFVy0hCR4YMKcxbetFqBcg7rPeucKA47XznuaVpT5Kx4gAndET1RysooVgbznxUTOSYGEJ7yJvnSAz9YeIhd4lhxrWf",
    "Tag(base64)": "fLRtrzEP0Wop+p+1UgJO5w==",
    "AAD_len": 141,
    "crypto_details": {
      "operation": "Decrypt",
      "algorithm": "AES-256",
      "mode": "GCM",
      "ephemeral": true,
      "key_b64": "8UzMVGgNFRYIyLunXd+QfOuo+vWACl6pqLQV+I/ym/c="
    }
  }
}
{
  "timestamp": "2025-08-26T00:42:49.328645",
  "run_id": "5c47ec79-fd60-42a1-aa20-a8a83cae7f60",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Demo path decrypted share.",
  "details": {
    "share_sha3_256_hex": "c9006e8a4a24c0e6e451074c821cb1a8d211a961e93128ff188a755cc05c238a",
    "algorithm": "aes256gcm"
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-26_00-41-45.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-26_00-41-45.txt
# SIZE: 35899 bytes
# HASH: 00dee0de19bb3ac5baf2b537ac9e08bfc9dab68faca966120b06afdd6ee06f1c
# MODIFIED: 2025-08-27T02:19:21.013481
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-26T00:41:45.755787] [INFO] [SYSTEM] Start new run (run_id=5c47ec79-fd60-42a1-aa20-a8a83cae7f60)
[2025-08-26T00:41:48.247862] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Starting demonstration flow (Option 2)...
[2025-08-26T00:41:48.251486] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite hobbies?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.251968] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite subject in school?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.252597] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What type of food do you like?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.253112] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite mode of transportation?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.253564] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which language(s) would you like to learn?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.254000] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of places do you enjoy visiting?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.254440] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of beverages do you prefer?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.254868] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which color(s) do you like the most?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.255300] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of movies do you enjoy?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.255735] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What type of games do you like to play?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.256192] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of music instruments do you enjoy playing or listening to?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.256650] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite types of flowers?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.257079] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of clothes do you prefer wearing?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.257508] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of pets would you like to have?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.257935] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite type of dessert?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.258381] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What type of jobs or careers are you interested in?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.258805] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite kinds of drinks?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.259284] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of landscapes do you find most beautiful?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.259726] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What are your favorite fruits to eat?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.260161] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of places do you like to shop at?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.260615] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What kind of animals do you find fascinating?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.261058] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite type of beverage?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.261497] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which outdoor place(s) would you love to explore?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.261920] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'What is your favorite type of cuisine?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:48.262358] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Question 'Which kind of exercise do you enjoy doing?' had empty 'correct_answers'. Now set them all as correct.
[2025-08-26T00:41:51.282709] [INFO] [GENERAL] debug_utils.py:log_debug:189 - User int input valid: 9
[2025-08-26T00:41:53.272743] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q1 picks. Type=STANDARD
[2025-08-26T00:41:53.273946] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q1: text='What are your favorite hobbies?' => user_picks=4 selected; local counts: correct=4, incorrect=0
[2025-08-26T00:41:54.634657] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q2 picks. Type=STANDARD
[2025-08-26T00:41:54.635791] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q2: text='What is your favorite subject in school?' => user_picks=3 selected; local counts: correct=3, incorrect=0
[2025-08-26T00:41:55.444623] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q3 picks. Type=STANDARD
[2025-08-26T00:41:55.445805] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q3: text='What type of food do you like?' => user_picks=1 selected; local counts: correct=1, incorrect=0
[2025-08-26T00:41:56.874712] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q4 picks. Type=STANDARD
[2025-08-26T00:41:56.875708] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q4: text='What is your favorite mode of transportation?' => user_picks=2 selected; local counts: correct=2, incorrect=0
[2025-08-26T00:41:58.985557] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q5 picks. Type=CRITICAL
[2025-08-26T00:41:58.986767] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q5: text='Which language(s) would you like to learn?' => user_picks=2 selected; local counts: correct=2, incorrect=0
[2025-08-26T00:42:00.736585] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q6 picks. Type=CRITICAL
[2025-08-26T00:42:00.737808] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q6: text='What kind of places do you enjoy visiting?' => user_picks=2 selected; local counts: correct=2, incorrect=0
[2025-08-26T00:42:02.668330] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q7 picks. Type=STANDARD
[2025-08-26T00:42:02.669664] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q7: text='What kind of beverages do you prefer?' => user_picks=3 selected; local counts: correct=3, incorrect=0
[2025-08-26T00:42:04.589659] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q8 picks. Type=STANDARD
[2025-08-26T00:42:04.590860] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q8: text='Which color(s) do you like the most?' => user_picks=3 selected; local counts: correct=3, incorrect=0
[2025-08-26T00:42:06.390424] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q9 picks. Type=STANDARD
[2025-08-26T00:42:06.391630] [DEBUG] [GENERAL] debug_utils.py:log_debug:189 - Q9: text='What kind of movies do you enjoy?' => user_picks=3 selected; local counts: correct=3, incorrect=0
[2025-08-26T00:42:08.962496] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q1: c=4, i=0
[2025-08-26T00:42:08.963347] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q2: c=3, i=0
[2025-08-26T00:42:08.963803] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q3: c=1, i=0
[2025-08-26T00:42:08.964248] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q4: c=2, i=0
[2025-08-26T00:42:08.964713] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q5: c=2, i=0
[2025-08-26T00:42:08.965183] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q6: c=2, i=0
[2025-08-26T00:42:08.965626] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q7: c=3, i=0
[2025-08-26T00:42:08.966112] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q8: c=3, i=0
[2025-08-26T00:42:08.966572] [INFO] [GENERAL] debug_utils.py:log_debug:189 - After re-edit Q9: c=3, i=0
[2025-08-26T00:42:08.967012] [INFO] [GENERAL] debug_utils.py:log_debug:189 - FINAL TALLY => c_count=23, i_count=0
[2025-08-26T00:42:16.082388] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Using PAD size: 128
[2025-08-26T00:42:19.093536] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Splitting real secret: correct_count=23, threshold=13, pad=128
[2025-08-26T00:42:19.094408] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() via node-bridge
[2025-08-26T00:42:19.175682] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - sss_split() complete.
[2025-08-26T00:42:19.176599] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - SSS split summary (beta clear logging).
[2025-08-26T00:42:19.177496] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='zBDH1aglMJLXJ8cd' (raw).
[2025-08-26T00:42:19.177972] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='zBDH1aglMJLXJ8cd', salt(b64)='HnUvS7BeEtoXBoVaPAAiIg=='
[2025-08-26T00:42:19.770071] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:19.782944] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:19.783539] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='rTFYFHzJjMOw+Awe' (raw).
[2025-08-26T00:42:19.784019] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='rTFYFHzJjMOw+Awe', salt(b64)='E9JzKl/TI35XM1x3K/+xww=='
[2025-08-26T00:42:20.328286] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:20.337300] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:20.338057] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='oiGf7JFqK3Bnn/6+' (raw).
[2025-08-26T00:42:20.338528] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='oiGf7JFqK3Bnn/6+', salt(b64)='amUHKqtsYs1TjCIJsSQsdA=='
[2025-08-26T00:42:20.875458] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:20.877237] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:20.878209] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='wF8lQNnqDFZBO1Vy' (raw).
[2025-08-26T00:42:20.879080] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='wF8lQNnqDFZBO1Vy', salt(b64)='uokqSdrZXGcMoWWtcB7TWg=='
[2025-08-26T00:42:21.419003] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:21.421056] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:21.422063] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='GuP7kuQvn5qJBfBl' (raw).
[2025-08-26T00:42:21.422893] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='GuP7kuQvn5qJBfBl', salt(b64)='k6pNVx4PIjg3u4iL/UnyFw=='
[2025-08-26T00:42:21.962986] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:21.964868] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:21.965828] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='TrWi8GoC4xLxfDUZ' (raw).
[2025-08-26T00:42:21.966658] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='TrWi8GoC4xLxfDUZ', salt(b64)='tosJvyaAqbEGD/A1vHVDsQ=='
[2025-08-26T00:42:22.496512] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:22.497744] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:22.498309] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='aNB5GSgis3kHffwi' (raw).
[2025-08-26T00:42:22.498773] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='aNB5GSgis3kHffwi', salt(b64)='KgI7A0s4dwwId/vz3GEXZg=='
[2025-08-26T00:42:23.037397] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:23.039389] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:23.040316] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='3ANv/4bStIRSyqG9' (raw).
[2025-08-26T00:42:23.041233] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='3ANv/4bStIRSyqG9', salt(b64)='YS3bIC4UWe68cAZnNgtC1Q=='
[2025-08-26T00:42:23.573595] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:23.574811] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:23.575359] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='2wCktAh0i5aTKkTD' (raw).
[2025-08-26T00:42:23.575835] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='2wCktAh0i5aTKkTD', salt(b64)='8G+VgWxd+AilcVX8R3wsMQ=='
[2025-08-26T00:42:24.105944] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:24.107458] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:24.108021] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='cNGjtQjyBUS+U+4U' (raw).
[2025-08-26T00:42:24.108494] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='cNGjtQjyBUS+U+4U', salt(b64)='2ag10hS8vujK8xSHKjLF7A=='
[2025-08-26T00:42:24.647136] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:24.649351] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:24.650287] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='lYzEnCaR0FFwkZPW' (raw).
[2025-08-26T00:42:24.651220] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='lYzEnCaR0FFwkZPW', salt(b64)='M7whaBxVKy3tpvlr2c3w1A=='
[2025-08-26T00:42:25.183535] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:25.185100] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:25.185658] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='qiG1h3T5b+gH1yQR' (raw).
[2025-08-26T00:42:25.186180] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='qiG1h3T5b+gH1yQR', salt(b64)='F4o7aOsHVFAR1+iz6o4n4g=='
[2025-08-26T00:42:25.723061] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:25.725019] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:25.725949] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='yNWgYEITPEktmg+a' (raw).
[2025-08-26T00:42:25.726758] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='yNWgYEITPEktmg+a', salt(b64)='Qy2LPfkVTA7VFnl/4MhCXg=='
[2025-08-26T00:42:26.261929] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:26.263228] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:26.263749] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='gzY8yEYGkMU/N2cI' (raw).
[2025-08-26T00:42:26.264226] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='gzY8yEYGkMU/N2cI', salt(b64)='Vm+UMnkig2nuQgcjtC0XQA=='
[2025-08-26T00:42:26.787607] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:26.788850] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:26.789380] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='jkoKYJDjxEMYgJEt' (raw).
[2025-08-26T00:42:26.789896] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='jkoKYJDjxEMYgJEt', salt(b64)='R/W7bkXosWng+OZgqE4LBA=='
[2025-08-26T00:42:27.321545] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:27.323844] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:27.324719] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='BIVkxeQydSBRUNdu' (raw).
[2025-08-26T00:42:27.325561] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='BIVkxeQydSBRUNdu', salt(b64)='6afM55cpmWDpfJfGTPfQEw=='
[2025-08-26T00:42:27.860965] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:27.862893] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:27.863872] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='exo8vNgy0kIo9N7H' (raw).
[2025-08-26T00:42:27.864702] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='exo8vNgy0kIo9N7H', salt(b64)='UgqEZmJYszGOblw5z47GCg=='
[2025-08-26T00:42:28.391248] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:28.392325] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:28.392829] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='iqCiyo9tS+pYIlOX' (raw).
[2025-08-26T00:42:28.393311] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='iqCiyo9tS+pYIlOX', salt(b64)='4D58JRWGYhvgfQiSs6Rjeg=='
[2025-08-26T00:42:28.920716] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:28.922751] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:28.923533] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='mzWC9V6hlRzeNBHI' (raw).
[2025-08-26T00:42:28.924246] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='mzWC9V6hlRzeNBHI', salt(b64)='7D6DcW9Nx+xbX1TYXv9f3g=='
[2025-08-26T00:42:29.443417] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:29.445414] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:29.446391] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='fXnmNOX7ige3MyW4' (raw).
[2025-08-26T00:42:29.447329] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='fXnmNOX7ige3MyW4', salt(b64)='sUC1O/9PNPeWwhV+jBoKfw=='
[2025-08-26T00:42:29.992554] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:29.994569] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:29.995642] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='RNwvAlCPZGxzOeD5' (raw).
[2025-08-26T00:42:29.996574] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='RNwvAlCPZGxzOeD5', salt(b64)='az8lbNV+D8ZdEPMDi9NWzg=='
[2025-08-26T00:42:30.557319] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:30.559404] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:30.560385] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='TfPILUeL/sU3crQx' (raw).
[2025-08-26T00:42:30.561223] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='TfPILUeL/sU3crQx', salt(b64)='L6Yq6DnqFRpDkbtGtrczPw=='
[2025-08-26T00:42:31.105830] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:31.107019] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:31.107541] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='wKzf5m1bsBsvEJuj' (raw).
[2025-08-26T00:42:31.107993] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='wKzf5m1bsBsvEJuj', salt(b64)='dQXwphJEq81A2Ye+rjWMVw=='
[2025-08-26T00:42:31.646627] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:31.648593] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:33.719924] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q1 final picks
[2025-08-26T00:42:33.908992] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q2 final picks
[2025-08-26T00:42:34.033712] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q3 final picks
[2025-08-26T00:42:34.218064] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q4 final picks
[2025-08-26T00:42:34.341262] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q5 final picks
[2025-08-26T00:42:34.466026] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q6 final picks
[2025-08-26T00:42:34.653950] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q7 final picks
[2025-08-26T00:42:34.777384] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q8 final picks
[2025-08-26T00:42:34.964900] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Q9 final picks
[2025-08-26T00:42:37.210151] [INFO] [GENERAL] debug_utils.py:log_debug:189 - User finalize => combine secrets now.
[2025-08-26T00:42:37.210955] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='zBDH1aglMJLXJ8cd' (raw).
[2025-08-26T00:42:37.211415] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='zBDH1aglMJLXJ8cd', salt(b64)='HnUvS7BeEtoXBoVaPAAiIg=='
[2025-08-26T00:42:37.710116] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:37.711964] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:37.712926] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:37.713703] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='rTFYFHzJjMOw+Awe' (raw).
[2025-08-26T00:42:37.714578] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='rTFYFHzJjMOw+Awe', salt(b64)='E9JzKl/TI35XM1x3K/+xww=='
[2025-08-26T00:42:38.212297] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:38.213514] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:38.219153] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:38.220153] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='oiGf7JFqK3Bnn/6+' (raw).
[2025-08-26T00:42:38.220632] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='oiGf7JFqK3Bnn/6+', salt(b64)='amUHKqtsYs1TjCIJsSQsdA=='
[2025-08-26T00:42:38.745364] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:38.746510] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:38.747103] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:38.747589] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='wF8lQNnqDFZBO1Vy' (raw).
[2025-08-26T00:42:38.748032] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='wF8lQNnqDFZBO1Vy', salt(b64)='uokqSdrZXGcMoWWtcB7TWg=='
[2025-08-26T00:42:39.271678] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:39.273323] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:39.274130] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:39.274971] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='GuP7kuQvn5qJBfBl' (raw).
[2025-08-26T00:42:39.275670] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='GuP7kuQvn5qJBfBl', salt(b64)='k6pNVx4PIjg3u4iL/UnyFw=='
[2025-08-26T00:42:39.766932] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:39.768110] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:39.768652] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:39.769123] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='TrWi8GoC4xLxfDUZ' (raw).
[2025-08-26T00:42:39.769542] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='TrWi8GoC4xLxfDUZ', salt(b64)='tosJvyaAqbEGD/A1vHVDsQ=='
[2025-08-26T00:42:40.263343] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:40.265111] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:40.265927] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:40.266647] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='aNB5GSgis3kHffwi' (raw).
[2025-08-26T00:42:40.267353] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='aNB5GSgis3kHffwi', salt(b64)='KgI7A0s4dwwId/vz3GEXZg=='
[2025-08-26T00:42:40.779167] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:40.780360] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:40.781042] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:40.781559] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='3ANv/4bStIRSyqG9' (raw).
[2025-08-26T00:42:40.782025] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='3ANv/4bStIRSyqG9', salt(b64)='YS3bIC4UWe68cAZnNgtC1Q=='
[2025-08-26T00:42:41.322800] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:41.324323] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:41.325181] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:41.325969] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='2wCktAh0i5aTKkTD' (raw).
[2025-08-26T00:42:41.326678] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='2wCktAh0i5aTKkTD', salt(b64)='8G+VgWxd+AilcVX8R3wsMQ=='
[2025-08-26T00:42:41.859043] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:41.860165] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:41.860740] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:41.861219] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='cNGjtQjyBUS+U+4U' (raw).
[2025-08-26T00:42:41.861673] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='cNGjtQjyBUS+U+4U', salt(b64)='2ag10hS8vujK8xSHKjLF7A=='
[2025-08-26T00:42:42.400678] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:42.402678] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:42.403995] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:42.404972] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='fXnmNOX7ige3MyW4' (raw).
[2025-08-26T00:42:42.405881] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='fXnmNOX7ige3MyW4', salt(b64)='sUC1O/9PNPeWwhV+jBoKfw=='
[2025-08-26T00:42:42.901983] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:42.902954] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:42.903711] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:42.904286] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='RNwvAlCPZGxzOeD5' (raw).
[2025-08-26T00:42:42.904759] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='RNwvAlCPZGxzOeD5', salt(b64)='az8lbNV+D8ZdEPMDi9NWzg=='
[2025-08-26T00:42:43.450307] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:43.451458] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:43.452099] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:43.452718] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='TfPILUeL/sU3crQx' (raw).
[2025-08-26T00:42:43.453203] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='TfPILUeL/sU3crQx', salt(b64)='L6Yq6DnqFRpDkbtGtrczPw=='
[2025-08-26T00:42:43.989076] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:43.990891] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:43.991903] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:43.992747] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='wKzf5m1bsBsvEJuj' (raw).
[2025-08-26T00:42:43.993613] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='wKzf5m1bsBsvEJuj', salt(b64)='dQXwphJEq81A2Ye+rjWMVw=='
[2025-08-26T00:42:44.544559] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:44.546306] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:44.547333] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:44.548331] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='lYzEnCaR0FFwkZPW' (raw).
[2025-08-26T00:42:44.549133] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='lYzEnCaR0FFwkZPW', salt(b64)='M7whaBxVKy3tpvlr2c3w1A=='
[2025-08-26T00:42:45.072992] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:45.074140] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:45.074695] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:45.075157] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='qiG1h3T5b+gH1yQR' (raw).
[2025-08-26T00:42:45.075611] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='qiG1h3T5b+gH1yQR', salt(b64)='F4o7aOsHVFAR1+iz6o4n4g=='
[2025-08-26T00:42:45.599421] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:45.600760] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:45.601320] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:45.601772] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='yNWgYEITPEktmg+a' (raw).
[2025-08-26T00:42:45.602277] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='yNWgYEITPEktmg+a', salt(b64)='Qy2LPfkVTA7VFnl/4MhCXg=='
[2025-08-26T00:42:46.122468] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:46.124180] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:46.125281] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:46.126125] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='gzY8yEYGkMU/N2cI' (raw).
[2025-08-26T00:42:46.126971] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='gzY8yEYGkMU/N2cI', salt(b64)='Vm+UMnkig2nuQgcjtC0XQA=='
[2025-08-26T00:42:46.659377] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:46.660384] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:46.660966] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:46.661460] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='jkoKYJDjxEMYgJEt' (raw).
[2025-08-26T00:42:46.661903] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='jkoKYJDjxEMYgJEt', salt(b64)='R/W7bkXosWng+OZgqE4LBA=='
[2025-08-26T00:42:47.204336] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:47.205348] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:47.206005] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:47.206487] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='BIVkxeQydSBRUNdu' (raw).
[2025-08-26T00:42:47.206938] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='BIVkxeQydSBRUNdu', salt(b64)='6afM55cpmWDpfJfGTPfQEw=='
[2025-08-26T00:42:47.749678] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:47.751518] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:47.752480] [ERROR] [GENERAL] debug_utils.py:log_error:227 - Decryption failed for a selected answer.
[2025-08-26T00:42:47.753350] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='exo8vNgy0kIo9N7H' (raw).
[2025-08-26T00:42:47.754321] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='exo8vNgy0kIo9N7H', salt(b64)='UgqEZmJYszGOblw5z47GCg=='
[2025-08-26T00:42:48.277365] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:48.278968] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:48.279856] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Demo path decrypted share.
[2025-08-26T00:42:48.280657] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='iqCiyo9tS+pYIlOX' (raw).
[2025-08-26T00:42:48.281356] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='iqCiyo9tS+pYIlOX', salt(b64)='4D58JRWGYhvgfQiSs6Rjeg=='
[2025-08-26T00:42:48.799472] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:48.801328] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:48.802409] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Demo path decrypted share.
[2025-08-26T00:42:48.803257] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Using ephemeral password='mzWC9V6hlRzeNBHI' (raw).
[2025-08-26T00:42:48.804082] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Starting Argon2id KDF (RAW). pass='mzWC9V6hlRzeNBHI', salt(b64)='7D6DcW9Nx+xbX1TYXv9f3g=='
[2025-08-26T00:42:49.326883] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:49.328089] [INFO] [CRYPTO] debug_utils.py:log_crypto_event:218 - Crypto operation
[2025-08-26T00:42:49.328645] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Demo path decrypted share.



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\archive\debug_info1_2025-08-26_00-41-45.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-03-24_00-48-05.json
# SIZE: 3944 bytes
# HASH: 3069c0275a5f8e85bbcd1087295f0205a0f0012a953d67a82de6fdba34fd06c1
# MODIFIED: 2025-08-26T22:53:57.929888
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-03-24T00:48:05.760941",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-03-24T00:48:05.762131",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Starting program...",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:07.719825",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "User int input valid: 10",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:09.531955",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q1 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:10.773139",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q2 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:12.265355",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q3 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:13.384083",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q4 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:14.691931",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q5 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:15.814620",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q6 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:16.500248",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q7 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:17.002829",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q8 picks. Type=STANDARD",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:18.626757",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q9 picks. Type=CRITICAL",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:19.931281",
  "run_id": "34b8d243-0b41-4f66-8253-15f18e7629de",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q10 picks. Type=STANDARD",
  "details": {}
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-03-24_00-48-05.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-03-24_00-48-05.txt
# SIZE: 1328 bytes
# HASH: abaf88a9fd73fe7de2dbe8165a208af8bd68b0674f539ad3d218f42fa2de361b
# MODIFIED: 2025-08-26T22:53:57.929888
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-03-24T00:48:05.760941] [INFO] [SYSTEM] Start new run (run_id=34b8d243-0b41-4f66-8253-15f18e7629de)
[2025-03-24T00:48:05.762131] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Starting program...
[2025-03-24T00:48:07.719825] [INFO] [GENERAL] debug_utils.py:log_debug:181 - User int input valid: 10
[2025-03-24T00:48:09.531955] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q1 picks. Type=STANDARD
[2025-03-24T00:48:10.773139] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q2 picks. Type=CRITICAL
[2025-03-24T00:48:12.265355] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q3 picks. Type=CRITICAL
[2025-03-24T00:48:13.384083] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q4 picks. Type=CRITICAL
[2025-03-24T00:48:14.691931] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q5 picks. Type=CRITICAL
[2025-03-24T00:48:15.814620] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q6 picks. Type=STANDARD
[2025-03-24T00:48:16.500248] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q7 picks. Type=STANDARD
[2025-03-24T00:48:17.002829] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q8 picks. Type=STANDARD
[2025-03-24T00:48:18.626757] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q9 picks. Type=CRITICAL
[2025-03-24T00:48:19.931281] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q10 picks. Type=STANDARD



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-03-24_00-48-05.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-08-26_00-43-10.json
# SIZE: 1341 bytes
# HASH: 55a54a2a85b97c3ae16e73e945cc81ec03fe98c17902316c3b412493179f9e31
# MODIFIED: 2025-08-27T02:19:21.013481
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-08-26T00:43:10.278240",
  "run_id": "ddb5ae5f-de61-4040-9b32-e666437d1346",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-08-26T00:44:46.701645",
  "run_id": "ddb5ae5f-de61-4040-9b32-e666437d1346",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Counts computed for kit build.",
  "details": {
    "total_correct": 2,
    "total_alternatives": 9,
    "total_incorrect": 7
  }
}
{
  "timestamp": "2025-08-26T00:44:55.990338",
  "run_id": "ddb5ae5f-de61-4040-9b32-e666437d1346",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Using PAD size: 128",
  "details": {}
}
{
  "timestamp": "2025-08-26T00:44:57.861328",
  "run_id": "ddb5ae5f-de61-4040-9b32-e666437d1346",
  "level": "INFO",
  "component": "CRYPTO",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 189
  },
  "message": "Argon2id parameters confirmed for kit.",
  "details": {
    "time_cost": 3,
    "memory_cost": 262144,
    "parallelism": 1
  }
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-08-26_00-43-10.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-08-26_00-43-10.txt
# SIZE: 428 bytes
# HASH: f441126d6e07de8dbf49dc577551e14fc2e095feeaa1b15652cf5ed9159210f0
# MODIFIED: 2025-08-27T02:19:21.014485
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-08-26T00:43:10.278240] [INFO] [SYSTEM] Start new run (run_id=ddb5ae5f-de61-4040-9b32-e666437d1346)
[2025-08-26T00:44:46.701645] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Counts computed for kit build.
[2025-08-26T00:44:55.990338] [INFO] [GENERAL] debug_utils.py:log_debug:189 - Using PAD size: 128
[2025-08-26T00:44:57.861328] [INFO] [CRYPTO] debug_utils.py:log_debug:189 - Argon2id parameters confirmed for kit.



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info1_2025-08-26_00-43-10.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info2_2025-03-24_00-48-38.json
# SIZE: 1161 bytes
# HASH: 332982d9fef8adcb421ab340ff0e1fe1202da75007c5b8cb22b56ec36e2f283d
# MODIFIED: 2025-08-26T22:53:57.930892
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-03-24T00:48:38.866455",
  "run_id": "7b875f94-d032-45ce-a219-3cd96aa7c6f7",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-03-24T00:48:38.867545",
  "run_id": "7b875f94-d032-45ce-a219-3cd96aa7c6f7",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Starting program...",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:41.807364",
  "run_id": "7b875f94-d032-45ce-a219-3cd96aa7c6f7",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "User int input valid: 1",
  "details": {}
}
{
  "timestamp": "2025-03-24T00:48:42.742532",
  "run_id": "7b875f94-d032-45ce-a219-3cd96aa7c6f7",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Q1 picks. Type=STANDARD",
  "details": {}
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info2_2025-03-24_00-48-38.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info2_2025-03-24_00-48-38.txt
# SIZE: 408 bytes
# HASH: 44588e34c891ee4a26204ec7e2c8fc70d765f695da37330389b2a5dcc2e3bd89
# MODIFIED: 2025-08-26T22:53:57.930892
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-03-24T00:48:38.866455] [INFO] [SYSTEM] Start new run (run_id=7b875f94-d032-45ce-a219-3cd96aa7c6f7)
[2025-03-24T00:48:38.867545] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Starting program...
[2025-03-24T00:48:41.807364] [INFO] [GENERAL] debug_utils.py:log_debug:181 - User int input valid: 1
[2025-03-24T00:48:42.742532] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Q1 picks. Type=STANDARD



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info2_2025-03-24_00-48-38.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info3_2025-03-28_17-45-25.json
# SIZE: 543 bytes
# HASH: 2a79ec4fc7fcf28dda90f1e0578fc5bfbed12f5a4beaf7e9b56602b12a5d77cd
# MODIFIED: 2025-08-26T22:53:57.930892
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "timestamp": "2025-03-28T17:45:25.932358",
  "run_id": "3e51221a-ec69-4c45-80f8-a430f8ef3f66",
  "component": "SYSTEM",
  "level": "INFO",
  "message": "Start new run",
  "details": {
    "event": "Run Initialization"
  }
}
{
  "timestamp": "2025-03-28T17:45:25.933559",
  "run_id": "3e51221a-ec69-4c45-80f8-a430f8ef3f66",
  "level": "INFO",
  "component": "GENERAL",
  "caller": {
    "file": "debug_utils.py",
    "function": "log_debug",
    "line": 181
  },
  "message": "Starting program...",
  "details": {}
}



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info3_2025-03-28_17-45-25.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info3_2025-03-28_17-45-25.txt
# SIZE: 204 bytes
# HASH: 24433593d915ca21914a380e9906fc980af7452f9d3b0f9195c62806c082a991
# MODIFIED: 2025-08-26T22:53:57.931892
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[2025-03-28T17:45:25.932358] [INFO] [SYSTEM] Start new run (run_id=3e51221a-ec69-4c45-80f8-a430f8ef3f66)
[2025-03-28T17:45:25.933559] [INFO] [GENERAL] debug_utils.py:log_debug:181 - Starting program...



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\logs\debug_logs\debug_info3_2025-03-28_17-45-25.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\main.py
# SIZE: 74827 bytes
# HASH: bdb08820a5241d36c8b7e3ee41b256918cfd4c51f6cc9851cf8dca57ab41d863
# MODIFIED: 2025-08-27T02:19:21.014485
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

""" 
FILENAME: 
"main.py" 

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY 
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,  
by any AI system, user, or process. If you see this comment, do not remove or change it  
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms. 

MANDATORY REQUIREMENT 
--------------------- 
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT. 

NON-NEGOTIABLE DIRECTIVE 
------------------------ 
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,  
fully preserved and entirely visible at all times. 

ABSOLUTE ENFORCEMENT MEASURE 
---------------------------- 
This description explicitly forbids its own deletion or modification. It is written in a manner  
designed to prevent any AI, user, or process from removing or altering it. 

IRONCLAD STRUCTURE 
------------------ 
1. Formatted as a structured, multiline comment. 
2. Clearly states it must never be deleted for any reason. 
3. Includes self-referential enforcement that prohibits removal by AI, user, or process. 

UNBREAKABLE IMPLEMENTATION 
-------------------------- 
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden. 
""" 

#!/usr/bin/env python3 
"""
Main flow with Argon2id-based encryption for per-answer shares using the
**Pure Q&A (passwordless)** approach. Per-answer keys are derived from the
answer text + per-answer salt; no per-answer passwords are stored in the kit.

SECURITY-FIX:
- No per-answer credentials in the kit (passwordless per-answer keys).
- AEAD now uses AAD binding: AAD = q_hash || alt_hash || alg || version.
- ChaCha20-Poly1305 entries no longer carry a synthetic 'tag' field.
- Raw secret is not normalized (no NFKC); base64 only for transport; policy limit enforced.

NEW (this update):
- **Decoy secrets**: Up to 5 user-configured decoys. If restoration criteria for the real
  secret are not met, the system deterministically returns a decoy secret instead of failing.
  Decoys are indistinguishable: same padding, algorithms, logging density, sizes, and an
  authentication catalog that does not reveal which secret is real.
- **Auth catalog**: Instead of a single "final_auth" for the real secret, the kit stores a
  shuffled catalog of (salt, HMAC(secret)) for *all* secrets (real+decoys). On recovery, we
  verify that the reconstructed secret matches *one* entry, printing a generic AUTH OK without
  disclosing whether it was real or decoy.
- **Global alternative mapping**: Per-decoy shares are produced for *all* alternatives so any
  (even weak/incorrect) selection can reconstruct a decoy while real requires >=T correct picks.
- **Brute-force estimator upgrade**: Side-by-side with/without Argon2id; shows total trials to
  reach the real threshold (lower bound) and the minimal decoy threshold; includes quantum
  (Grover) estimate; keeps sensitive logging intact (beta).

Notes:
- Backward-compatible data layout for the demo path.
- Saved-kit layout changes: "final_auth"  "auth_catalog" and "secrets_count".
"""

import os
import sys
import json
import base64
import curses
import asyncio
import threading
import hashlib
import hmac
import secrets
import time
import math
from itertools import combinations
from pathlib import Path

from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives import hashes

# project modules
from modules.debug_utils import (
    ensure_debug_dir,
    log_debug,
    log_error,
    log_exception,
    append_recovery_guide
)
from modules.security_utils import (
    validate_question,
    sanitize_input,
    normalize_text,
    hash_share
)
from modules.input_utils import get_valid_int, get_nonempty_secret
from modules.ui_utils import (
    arrow_select_clear_on_toggle,
    arrow_select_no_toggle,
    editing_menu,
    final_edit_menu
)
# Import SSS functions from the bridge
from modules.split_utils import split_secret_and_dummy
from modules.sss_bridge import sss_split, sss_combine

# crypto primitives (CipherForge)
from CipherForge import (
    derive_or_recover_key,
    encrypt_aes256gcm,
    decrypt_aes256gcm,
    encrypt_chacha20poly1305,
    decrypt_chacha20poly1305
)

SRC_DIR = Path(__file__).parent.resolve()
SAVE_DIR = SRC_DIR / "user configured security questions"
QUESTIONS_FILE_NAME = "example_questions25.json"
QUESTIONS_PATH = SRC_DIR / QUESTIONS_FILE_NAME

KIT_VERSION = 3  # bump for new auth_catalog + decoy support

# Security policy constants
SECQ_MIN_BITS = 80.0  # minimum combinatorial hardness (log2 expected tries)

chosen_lock = threading.Lock()
combine_lock = threading.Lock()


# ---------- helpers & UI ----------

def get_threshold(prompt_text, low, high):
    while True:
        raw = input(f"{prompt_text} ({low}..{high}): ")
        try:
            val = int(raw)
            if low <= val <= high:
                return val
        except ValueError:
            pass
        print(f"Invalid input. Must be an integer between {low} and {high}.\n")


def _policy_min_threshold(correct_count: int) -> int:
    """
    Enforce a baseline threshold policy:
      T >= max(8, ceil(0.35 * correct_count)), but not more than correct_count.
    """
    if correct_count <= 1:
        return correct_count
    return min(correct_count, max(8, math.ceil(0.35 * correct_count)))


def _normalize_for_comparison(text: str) -> str:
    """
    Used for human-input editing/dup-checks.
    """
    processed = text.strip()
    common_trailing_punct = ".,!?;:"
    while processed and processed[-1] in common_trailing_punct:
        processed = processed[:-1]
    processed = processed.strip()
    return normalize_text(sanitize_input(processed.lower()))


def _norm_for_kit(text: str) -> str:
    """
    EXACT normalization used for hashing questions/alternatives in the KIT:
    sanitize_input(normalize_text(text))
    """
    return sanitize_input(normalize_text(text))


def _sha3_hex(s: str) -> str:
    return hashlib.sha3_256(s.encode("utf-8")).hexdigest()


def _integrity_hash_for_kit(qtext: str, alts: list[str]) -> str:
    qn = _norm_for_kit(qtext)
    altn = [_norm_for_kit(a) for a in alts]
    block = qn + "\n" + "\n".join(sorted(altn))
    return _sha3_hex(block)


def _alt_hash_for_kit(alt_text: str) -> str:
    return _sha3_hex(_norm_for_kit(alt_text))


def _aad_bytes(q_hash: str, alt_hash: str, algorithm: str, version: int = KIT_VERSION) -> bytes:
    """
    Deterministic AAD binding for AEAD operations.
    """
    return f"{q_hash}|{alt_hash}|{algorithm}|{version}".encode("utf-8")


def _derive_answer_key(answer_text: str,
                       salt: bytes,
                       t: int, m: int, p: int) -> bytes:
    """
    Derive per-answer key from normalized answer text and per-answer salt.
    Uses Argon2id RAW via derive_or_recover_key wrapper.
    """
    normalized = _norm_for_kit(answer_text)
    key, _ = derive_or_recover_key(
        normalized, salt, ephemeral=False,
        time_cost=t, memory_cost=m, parallelism=p
    )
    return key


def _decrypt_share_from_entry(entry: dict,
                              arg_time: int,
                              arg_mem: int,
                              arg_par: int,
                              q_hash: str | None = None,
                              alt_hash: str | None = None,
                              qid: int | None = None,
                              qtext: str | None = None,
                              alt_text: str | None = None) -> bytes | None:
    """
    Given a per-answer encrypted entry from the kit, derive the per-answer key
    from the *answer text* + stored salt, and decrypt with AAD binding.
    """
    try:
        alg = entry.get("algorithm")
        salt_b64 = entry.get("salt") or entry.get("salt_b64")
        kdf = entry.get("kdf") or {}
        if not (salt_b64 and alg and kdf):
            log_error("Entry missing required fields (salt/algorithm/kdf).",
                      details={"q_hash": q_hash, "alt_hash": alt_hash, "algorithm": alg})
            return None

        if not alt_text:
            log_error("Answer text required for decryption in passwordless design.",
                      details={"q_hash": q_hash, "alt_hash": alt_hash})
            return None

        salt = base64.b64decode(salt_b64)
        t = int(kdf.get("t", arg_time))
        m = int(kdf.get("m", arg_mem))
        p = int(kdf.get("p", arg_par))

        key = _derive_answer_key(alt_text, salt, t, m, p)
        aad = _aad_bytes(q_hash or "", alt_hash or "", alg)

        if alg == "chacha20poly1305":
            pt = decrypt_chacha20poly1305(entry, key, aad=aad)
        else:
            pt = decrypt_aes256gcm(entry, key, aad=aad)

        # Log the share hash (beta)
        shash = hash_share(pt)
        log_debug(
            "Decrypted share.",
            level="INFO",
            component="CRYPTO",
            details={
                "q_id": qid,
                "q_text": qtext,
                "q_hash": q_hash,
                "alt_text": alt_text,
                "alt_hash": alt_hash,
                "algorithm": alg,
                "share_sha3_256_hex": shash,
                "share_len_bytes": len(pt)
            }
        )
        return pt
    except Exception as e:
        log_exception(e, "Failed to decrypt share from entry.")
        return None


# ---- combinatorial hardness helpers ----

def _log2_comb(n: int, k: int) -> float:
    if k < 0 or k > n:
        return float("-inf")
    # Use lgamma to avoid huge integers
    return (math.lgamma(n + 1) - math.lgamma(k + 1) - math.lgamma(n - k + 1)) / math.log(2.0)


def _combinatorial_bits(total_alts: int, total_correct: int, threshold: int) -> float:
    """
    bits = log2( C(total_alts, T) / C(total_correct, T) )
    Expected tries to pick a real T-subset at random among all T-subsets.
    """
    return _log2_comb(total_alts, threshold) - _log2_comb(total_correct, threshold)


# ---- Argon2 calibration & timing ----

def calibrate_argon2(target_ms: float = 250.0, max_mib: int = 1024) -> tuple[int, int, int, float]:
    """
    Increase memory-cost first (up to max_mib), then time-cost,
    until a single Argon2id derivation reaches target_ms.
    Returns (t, m_kib, p, measured_ms).
    """
    pwd = "SECQ_calibration"
    salt = os.urandom(16)
    t = 2
    m_kib = 256 * 1024  # 256 MiB
    p = 1
    measured = 0.0

    while True:
        st = time.perf_counter()
        _key, _ = derive_or_recover_key(pwd, salt, False, t, m_kib, p)
        measured = (time.perf_counter() - st) * 1000.0
        if measured >= target_ms:
            break
        if m_kib < max_mib * 1024:
            m_kib = min(max_mib * 1024, m_kib * 2)
        else:
            if t < 6:
                t += 1
            else:
                break
    return t, m_kib, p, measured


def estimate_argon2_time_ms(arg_time: int, arg_mem: int, arg_par: int, samples: int = 1) -> float:
    """
    Measure a local Argon2id derivation time for the given parameters.
    """
    pwd = "SECQ_estimate"
    total = 0.0
    for _ in range(max(1, samples)):
        salt = os.urandom(16)
        st = time.perf_counter()
        _k, _ = derive_or_recover_key(pwd, salt, False, arg_time, arg_mem, arg_par)
        total += (time.perf_counter() - st) * 1000.0
    return total / max(1, samples)


def prompt_pad_size_multi(max_b64_len: int) -> int:
    recommended_pad = max(128, max_b64_len + 32)
    user_pad = recommended_pad
    print(f"\nCustom PAD size? Press ENTER to use recommended={recommended_pad}.")
    try_pad_str = input(f"PAD must be >= {max_b64_len} (max length of base64 secrets): ").strip()
    if try_pad_str:
        try:
            user_pad_input = int(try_pad_str)
            if user_pad_input < max_b64_len:
                print(f"Provided pad < max base64 secret length. Forcing {max_b64_len} instead.\n")
                user_pad = max_b64_len
            else:
                user_pad = user_pad_input
        except ValueError:
            print(f"Invalid number, using recommended={recommended_pad}.\n")
    if user_pad < max_b64_len:
        user_pad = max_b64_len
        print(f"Corrected final pad to {user_pad} to fit the secrets.\n")
    log_debug(f"Using PAD size: {user_pad}", level="INFO")
    return user_pad


def show_start_menu():
    while True:
        print("Press 1 - Enter setup phase")
        print("Press 2 - Proceed to example demonstration")
        choice_ = input("Choice: ").strip()
        if choice_ == "1":
            setup_phase()
        elif choice_ == "2":
            break
        else:
            print("Invalid choice. Please try again.\n")


def display_questions(questions):
    print("\n--- SECURITY QUESTIONS ---\n")
    for q in questions:
        typ = "CRITICAL" if q.get("is_critical") else "STANDARD"
        print(f"[Question {q['id']}] {q['text']} (Type: {typ})\n")
        for i, alt in enumerate(q["alternatives"], 1):
            letter = chr(ord('A') + i - 1)
            print(f"{letter}) {alt}")
        print("\n---\n")


def _decoy_pick_index(q_hashes_and_alt_hashes: list[tuple[str, str]], decoy_count: int) -> int:
    """
    Deterministically select a decoy index in [1..decoy_count] based on selected answers.
    """
    if decoy_count <= 0:
        return 1
    acc = hashlib.sha3_256()
    for qh, ah in sorted(q_hashes_and_alt_hashes):
        acc.update(qh.encode("utf-8"))
        acc.update(b"|")
        acc.update(ah.encode("utf-8"))
        acc.update(b";")
    val = int.from_bytes(acc.digest()[-4:], "big")
    return (val % decoy_count) + 1  # 1..decoy_count


def setup_phase():
    while True:
        print("\nWould you like to edit your questions here?")
        print("Press y for Yes or n for No")
        ans = input("Choice: ").strip().lower()
        if ans == 'n':
            file_load_phase()
            return
        elif ans == 'y':
            manual_questions = manual_input_mode()
            if manual_questions:
                save_option = prompt_save_decision()
                if save_option == 'j':
                    save_questions(manual_questions)
                    print("(Configuration and questions saved.)\n")
                elif save_option == 'c':
                    print("(Continuing without saving.)\n")
            return
        else:
            print("Invalid choice. Please enter 'y' or 'n'.")


def file_load_phase():
    SAVE_DIR.mkdir(parents=True, exist_ok=True)
    all_json = sorted(f for f in SAVE_DIR.glob("*.json") if f.is_file())
    if not all_json:
        print(f"\nNo configuration files found in the '{SAVE_DIR.name}' directory.")
        input("Press b to go back: ")
        return

    print("\nAvailable configuration files:\n")
    for idx, fobj in enumerate(all_json, 1):
        print(f"{idx}) {fobj.name}")
    print("\nEnter the number of the file you'd like to load, or press b to go back.")

    while True:
        user_pick = input("Choice: ").strip().lower()
        if user_pick == 'b':
            return
        try:
            pick_val = int(user_pick)
            if 1 <= pick_val <= len(all_json):
                chosen_file = all_json[pick_val - 1]
                print(f"\nYou selected: {chosen_file.name}")
                try:
                    with open(chosen_file, "r", encoding="utf-8") as jf:
                        kit = json.load(jf)
                    run_recovery_kit_flow(kit, chosen_file)
                except Exception as e:
                    log_exception(e, f"Failed to load or process kit: {chosen_file}")
                    print("ERROR: Could not load/process the selected kit file.")
                return
            else:
                print("Invalid selection. Try again, or press b to go back.")
        except ValueError:
            print("Invalid input. Try again, or press b to go back.")


def manual_input_mode():
    """
    Returns list of questions:
      {
        "id": int,
        "text": str,
        "alternatives": [str],
        "correct_answers": [str],  # used internally, not exported
        "is_critical": bool
      }
    """
    questions = []
    while True:
        current_qnum = len(questions) + 1
        print(f"\nEnter your security question #{current_qnum} (2..100 total):")
        question_text = ""
        while not question_text:
            question_text = input("[Your question here]: ").strip()
            if not question_text:
                print("Question text cannot be blank.")

        # number of alternatives
        while True:
            print("\nHow many answer alternatives should this question have?")
            print("Enter a number between 2 and 20")
            alt_count_str = input("Number of alternatives: ").strip()
            try:
                alt_count = int(alt_count_str)
                if 2 <= alt_count <= 20:
                    break
                print("Please enter a value between 2 and 20.")
            except ValueError:
                print("Invalid integer.")

        # alternatives
        alternatives = []
        norm_seen = set()
        print("\nEnter the alternatives:")
        for i in range(alt_count):
            while True:
                alt_raw = input(f"Alternative {i+1}: ").strip()
                if not alt_raw:
                    print("Alternative cannot be blank.")
                    continue
                norm = _normalize_for_comparison(alt_raw)
                if norm in norm_seen:
                    print("Duplicate or too similar alternative. Please enter a unique value.")
                    continue
                alternatives.append(alt_raw)
                norm_seen.add(norm)
                break

        # type
        is_critical = False
        print("\nSelect question type:")
        print("Standard is selected by default.")
        print("If you want to mark this question as critical, press c.")
        print("(Otherwise, press Enter to keep it as Standard)")
        if input("Choice: ").strip().lower() == 'c':
            is_critical = True

        # correct answers selection
        correct_answers = _prompt_correct_answers_for_question(alternatives)

        # re-edit loop
        while True:
            print("\nWould you like to re-edit anything for the current question before proceeding?")
            print("Press q   Re-edit the security question text")
            print("Press a   Re-edit all answer alternatives")
            print(f"Press # (1..{alt_count})  Re-edit a single alternative by its number")
            print("Press r   Re-select the correct answer(s)")
            print("(Or press Enter to continue to next step/question)")
            e = input("Re-edit choice: ").strip().lower()
            if e == "":
                break
            if e == "q":
                new_text = ""
                while not new_text:
                    new_text = input("\nRe-enter security question text:\n").strip()
                    if not new_text:
                        print("Question text cannot be blank.")
                question_text = new_text
                print("(Question updated.)\n")
            elif e == "a":
                new_alts = []
                new_seen = set()
                print("\nRe-entering all alternatives...")
                for i in range(alt_count):
                    while True:
                        v = input(f"Re-enter Alternative {i+1}: ").strip()
                        if not v:
                            print("Alternative cannot be blank.")
                            continue
                        n = _normalize_for_comparison(v)
                        if n in new_seen:
                            print("Duplicate or too similar alternative. Please enter a unique value.")
                            continue
                        new_alts.append(v)
                        new_seen.add(n)
                        break
                alternatives = new_alts
                norm_seen = new_seen
                print("(Alternatives updated.)\n")
                correct_answers = _prompt_correct_answers_for_question(alternatives)
            elif e == "r":
                correct_answers = _prompt_correct_answers_for_question(alternatives)
            else:
                try:
                    idx = int(e)
                    if 1 <= idx <= alt_count:
                        while True:
                            nv = input(f"Re-enter Alternative {idx}: ").strip()
                            if not nv:
                                print("Alternative cannot be blank.")
                                continue
                            n = _normalize_for_comparison(nv)
                            # check against others
                            others = set(_normalize_for_comparison(x) for j, x in enumerate(alternatives) if j != idx-1)
                            if n in others:
                                print("Duplicate or too similar to another existing alternative.")
                                continue
                            old_val = alternatives[idx-1]
                            alternatives[idx-1] = nv
                            # keep correct selection consistent
                            if old_val in correct_answers:
                                correct_answers = [nv if x == old_val else x for x in correct_answers]
                            print("(Alternative updated.)\n")
                            break
                    else:
                        print(f"Alternative number must be between 1 and {alt_count}.")
                except ValueError:
                    print("Unrecognized re-edit choice.\n")

        questions.append({
            "id": current_qnum,
            "text": question_text,
            "alternatives": alternatives,
            "correct_answers": correct_answers,
            "is_critical": is_critical
        })

        print("\nNavigation options:")
        print("Press n   Proceed to the next question")
        if len(questions) > 1:
            print("Press b   Go back and revise the previous question")
        if len(questions) >= 2:
            print("Press d   Done (finish input)")
        print(f"(You must have at least 2 questions to finish, you currently have {len(questions)}.)")

        nav = input("Choice: ").strip().lower()
        if nav == "n" or nav == "":
            if len(questions) >= 100:
                print("You have reached the maximum of 100 questions. Finishing input now.")
                break
        elif nav == "b":
            # remove current question entry and go back one
            if questions:
                questions.pop()
            if questions:
                print("\nRevising the previous question (it will be re-entered)...")
                last = questions.pop()
                # push back so user re-enters (simple approach)
                continue
        elif nav == "d":
            if len(questions) >= 2:
                print("\n--- Manual input complete. ---\n")
                break
            else:
                print("You must have at least 2 questions. Continue adding more.")
        else:
            if len(questions) >= 100:
                print("You have reached the maximum of 100 questions. Finishing input now.")
                break

    if questions:
        print("Summary of your manually entered questions:\n")
        for qd in questions:
            typ = "CRITICAL" if qd["is_critical"] else "STANDARD"
            print(f"[Question {qd['id']}] {qd['text']}")
            for i, alt in enumerate(qd["alternatives"], 1):
                letter = chr(ord('A') + i - 1)
                print(f"  {letter}) {alt}")
            print(f"  Type: {typ}\n")
    else:
        print("No questions were entered.\n")

    return questions


def _prompt_correct_answers_for_question(alternatives: list[str]) -> list[str]:
    if not alternatives:
        return []
    print("\nMark the correct answer(s) for this question.")
    print("Enter letters or numbers separated by commas (e.g., A,C or 1,3).")
    print("Press ENTER to mark ALL alternatives as correct.")
    print("Tip: You can also type 'all'.")
    legend = ", ".join(f"{chr(ord('A')+i)}={i+1}" for i in range(len(alternatives)))
    print("Legend:", legend)
    while True:
        raw = input("Correct selection(s): ").strip()
        if raw == "" or raw.lower() == "all":
            return alternatives[:]
        tokens = [t.strip() for chunk in raw.replace(",", " ").split() for t in [chunk] if t.strip()]
        if not tokens:
            print("Please enter something, or press ENTER for ALL.")
            continue
        picks = set()
        ok = True
        for t in tokens:
            if len(t) == 1 and t.isalpha():
                idx = (ord(t.upper()) - ord('A')) + 1
            else:
                try:
                    idx = int(t)
                except ValueError:
                    print(f"Unrecognized token '{t}'.")
                    ok = False
                    break
            if not (1 <= idx <= len(alternatives)):
                print(f"Out of range: '{t}'.")
                ok = False
                break
            picks.add(idx)
        if not ok or not picks:
            continue
        return [alternatives[i-1] for i in sorted(picks)]


def prompt_save_decision():
    while True:
        print("\nWould you like to save your questions?")
        print("Press j   Save as both JSON and text file")
        print("Press c   Continue without saving")
        c = input("Choice: ").strip().lower()
        if c in ("j", "c"):
            return c
        print("Invalid choice.")


# -------------- DECoys + recovery kit (passwordless; AAD; AUTH-CATALOG) --------------

def _prompt_decoy_secrets() -> list[str]:
    """
    Ask for up to 5 decoy secrets (plaintexts). Empty input stops early.
    """
    decoys = []
    print("\n--- Optional: Configure up to FIVE decoy secrets ---")
    print("A decoy is returned when real restoration criteria are not met.")
    print("They should look fully plausible. The text you enter here is what will be revealed.")
    print("(Press ENTER on a blank line to stop adding decoys.)\n")
    for i in range(1, 6):
        s = input(f"Enter decoy secret #{i} (leave blank to stop): ")
        if not s:
            break
        decoys.append(s)
    if not decoys:
        # Always have at least one decoy so the system never fails closed
        default_msg = "System: Recovery completed successfully."
        print(f"\n(No decoys provided. Adding a default decoy: \"{default_msg}\")")
        decoys.append(default_msg)
    return decoys


def save_questions(questions):
    """
    Builds and saves a SELF-CONTAINED recovery kit (passwordless per-answer keys).
    Enforces a minimum combinatorial hardness before allowing kit generation.

    NEW: Generates *one real* secret and up to *five decoy* secrets. The JSON contains
    per-answer encrypted shares for: real only on correct alternatives (others carry
    indistinguishable random bytes), while each decoy has shares assigned for *all*
    alternatives to guarantee a successful reconstruction path.
    """
    print("\n--- Cryptographic Parameter Setup ---")
    real_secret = get_nonempty_secret("Enter the secret to be protected: ")
    real_bytes = real_secret.encode("utf-8")
    real_b64 = base64.b64encode(real_bytes).decode()

    # Optional decoys
    decoy_texts = _prompt_decoy_secrets()
    decoy_bytes_list = [d.encode("utf-8") for d in decoy_texts]
    decoy_b64_list = [base64.b64encode(b).decode() for b in decoy_bytes_list]

    total_correct = sum(len(q.get("correct_answers", [])) for q in questions)
    total_alts = sum(len(q.get("alternatives", [])) for q in questions)
    total_incorrect = max(0, total_alts - total_correct)
    log_debug("Counts computed for kit build.",
              level="INFO",
              component="CRYPTO",
              details={"total_correct": total_correct, "total_alternatives": total_alts, "total_incorrect": total_incorrect})

    if total_correct == 0:
        print("ERROR: No correct answers were defined across your questions. At least one is required.")
        return

    # threshold bounds based on real shares available (policy)
    min_thr = _policy_min_threshold(total_correct)
    max_thr = total_correct
    print(f"\n[Policy] Minimum threshold for your {total_correct} real share(s) is {min_thr}.")
    r_thr = get_threshold("Enter the real threshold", min_thr, max_thr)

    # Pad size must accommodate the longest base64 across real+decoys
    max_b64_len = max(len(real_b64), *(len(db64) for db64 in decoy_b64_list))
    pad_size = prompt_pad_size_multi(max_b64_len)

    # Argon2 parameters
    arg_time, arg_mem, arg_par = prompt_argon2_parameters()
    log_debug("Argon2id parameters confirmed for kit.",
              level="INFO",
              component="CRYPTO",
              details={"time_cost": arg_time, "memory_cost": arg_mem, "parallelism": arg_par})

    # --- Combinatorial hardness gate (for the REAL path) ---
    bits = _combinatorial_bits(total_alts, total_correct, r_thr)
    if not math.isfinite(bits) or bits < SECQ_MIN_BITS:
        print(f"\n[ABORT] Combinatorial hardness too low: ~{bits:.1f} bits "
              f"for N={total_alts}, C={total_correct}, T={r_thr}.")
        print("Add more questions/alternatives and/or increase the threshold, then try again.\n")
        return
    else:
        print(f"[OK] Combinatorial hardness: ~{bits:.1f} bits.")

    # ---------- Build global alternative index ----------
    # Order: [(q_hash, a_hash, q_text, alt_text, is_correct)]
    all_items: list[tuple[str, str, str, str, bool]] = []
    for q in questions:
        q_text = q["text"]
        alts = q["alternatives"]
        q_hash = _integrity_hash_for_kit(q_text, alts)
        correct_set_norm = set(_norm_for_kit(a) for a in q.get("correct_answers", []))
        for alt in alts:
            is_correct = _norm_for_kit(alt) in correct_set_norm
            all_items.append((q_hash, _alt_hash_for_kit(alt), q_text, alt, is_correct))
    total_alts = len(all_items)

    # ---------- Generate shares ----------
    # REAL: shares only for the number of correct alternatives
    try:
        real_shares_correct = asyncio.run(
            sss_split(real_b64.encode("utf-8"), sum(1 for it in all_items if it[4]), r_thr, pad=pad_size)
        )
    except Exception as e:
        log_exception(e, "Error splitting REAL secret")
        return

    # DECOYS: produce for ALL alternatives; threshold choices:
    #   - First decoy uses threshold=1 (guarantees return value even with very few picks)
    #   - Remaining decoys use threshold=r_thr (indistinguishable thresholds externally)
    decoy_thresholds = [1] + [r_thr] * (len(decoy_b64_list) - 1)
    decoy_shares_by_idx: list[list[bytearray]] = []
    try:
        for db64, thr in zip(decoy_b64_list, decoy_thresholds):
            shares = asyncio.run(sss_split(db64.encode("utf-8"), total_alts, thr, pad=pad_size))
            decoy_shares_by_idx.append(shares)
    except Exception as e:
        log_exception(e, "Error splitting DECOY secret(s)")
        return

    # ---------- AUTH CATALOG (indistinguishable) ----------
    # For each secret (real + decoys), store (salt, HMAC(secret)) but do not reveal which is which.
    def _auth_entry(secret_bytes: bytes) -> dict:
        salt = os.urandom(16)
        kdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=salt, info=b"SECQ final-auth v3")
        k_auth = kdf.derive(secret_bytes)
        tag = hmac.new(k_auth, secret_bytes, digestmod="sha256").digest()
        return {"salt": base64.b64encode(salt).decode(), "hmac_sha256": base64.b64encode(tag).decode()}

    auth_catalog = [_auth_entry(real_bytes)] + [_auth_entry(b) for b in decoy_bytes_list]
    # Shuffle for stronger indistinguishability (store randomized order)
    secrets_perm = list(range(len(auth_catalog)))
    secrets.shuffle(secrets_perm)
    auth_catalog = [auth_catalog[i] for i in secrets_perm]

    # ---------- Encrypt per-answer shares for each secret variant ----------
    # For the REAL secret (index 0): only correct alternatives carry valid real shares.
    # For incorrect alternatives we store indistinguishable random bytes of share_len.
    encrypted_shares: dict[str, dict[str, dict]] = {}
    real_idx = 0
    share_len = pad_size + 1  # sss-bridge share size (pad bytes + 1 byte x-coordinate)

    def _enc_one_share(plaintext_share: bytes, q_hash: str, alt_text: str, alg_choice: str) -> dict:
        salt = os.urandom(16)
        key = _derive_answer_key(alt_text, salt, arg_time, arg_mem, arg_par)
        aad = _aad_bytes(q_hash, _alt_hash_for_kit(alt_text), alg_choice)
        if alg_choice == "chacha20poly1305":
            enc = encrypt_chacha20poly1305(plaintext_share, key, aad=aad)
            return {
                "ciphertext": enc["ciphertext"],
                "nonce": enc["nonce"],
                "algorithm": "chacha20poly1305",
                "salt": base64.b64encode(salt).decode(),
                "kdf": {"type": "argon2id", "t": arg_time, "m": arg_mem, "p": arg_par, "len": 32}
            }
        else:
            enc = encrypt_aes256gcm(plaintext_share, key, aad=aad)
            return {
                "ciphertext": enc["ciphertext"],
                "nonce": enc["nonce"],
                "tag": enc["tag"],
                "algorithm": "aes256gcm",
                "salt": base64.b64encode(salt).decode(),
                "kdf": {"type": "argon2id", "t": arg_time, "m": arg_mem, "p": arg_par, "len": 32}
            }

    # Walk all alternatives in global order so decoy shares map 1:1 by index
    for global_idx, (q_hash, a_hash, q_text, alt_text, is_corr) in enumerate(all_items):
        encrypted_shares.setdefault(q_hash, {})
        per_alt_block = {}
        # s0 => REAL path
        if is_corr:
            if real_idx >= len(real_shares_correct):
                log_error("Internal error: real_idx overflow", None, {"real_idx": real_idx, "len": len(real_shares_correct)})
                real_share = os.urandom(share_len)  # fallback indistinguishable
            else:
                real_share = bytes(real_shares_correct[real_idx])
                real_idx += 1
        else:
            real_share = os.urandom(share_len)  # indistinguishable filler for incorrect alts
        per_alt_block["s0"] = _enc_one_share(real_share, q_hash, alt_text, secrets.choice(["chacha20poly1305", "aes256gcm"]))

        # s1..sN => decoys (always valid shares for all alts)
        for decoy_i, shares_list in enumerate(decoy_shares_by_idx, start=1):
            dec_share = bytes(shares_list[global_idx])
            per_alt_block[f"s{decoy_i}"] = _enc_one_share(dec_share, q_hash, alt_text, secrets.choice(["chacha20poly1305", "aes256gcm"]))

        encrypted_shares[q_hash][a_hash] = per_alt_block

        log_debug(
            "Mapped Q/A to encrypted multi-secret shares.",
            level="INFO",
            component="CRYPTO",
            details={
                "q_text": q_text,
                "alt_text": alt_text,
                "q_hash": q_hash,
                "alt_hash": a_hash,
                "real_valid": bool(is_corr),
                "decoy_variants": len(decoy_shares_by_idx)
            }
        )

    questions_out = []
    for q in questions:
        questions_out.append({
            "id": q["id"],
            "text": q["text"],
            "alternatives": q["alternatives"],
            "is_critical": bool(q.get("is_critical", False)),
            "integrity_hash": _integrity_hash_for_kit(q["text"], q["alternatives"])
        })

    recovery_kit = {
        "config": {
            "real_threshold": r_thr,
            "pad_size": pad_size,
            "argon2_params": {"time_cost": arg_time, "memory_cost": arg_mem, "parallelism": arg_par},
            "version": KIT_VERSION,
            "secrets_count": 1 + len(decoy_b64_list),
            "auth_catalog": auth_catalog  # randomized order; indistinguishable
        },
        "questions": questions_out,
        "encrypted_shares": encrypted_shares
    }

    # persist files
    SAVE_DIR.mkdir(parents=True, exist_ok=True)
    base_name = "user_config"
    json_file = get_next_filename(SAVE_DIR, base_name, "json")
    txt_file = get_next_filename(SAVE_DIR, base_name, "txt")

    with open(json_file, "w", encoding="utf-8") as jf:
        json.dump(recovery_kit, jf, indent=2)

    with open(txt_file, "w", encoding="utf-8") as tf:
        tf.write("--- CRYPTOGRAPHIC CONFIGURATION ---\n")
        tf.write("Secret: [encrypted via SSS; not stored in JSON]\n")
        tf.write(f"Shamir Threshold (real path): {r_thr}\n")
        tf.write(f"Pad Size: {pad_size}\n")
        tf.write("Argon2id Parameters:\n")
        tf.write(f"  - Time Cost: {arg_time}\n")
        tf.write(f"  - Memory Cost: {arg_mem} KiB\n")
        tf.write(f"  - Parallelism: {arg_par}\n")
        tf.write(f"\nAuth Catalog Entries (real+decoys, shuffled): {len(auth_catalog)}\n")
        tf.write("\n--- SECURITY QUESTIONS ---\n\n")
        for q in questions:
            qtype = "CRITICAL" if q.get("is_critical") else "STANDARD"
            tf.write(f"[Question {q['id']}] {q['text']} (Type: {qtype})\n\n")
            for i, alt in enumerate(q['alternatives'], 1):
                letter = chr(ord('A') + i - 1)
                tf.write(f"{letter}) {alt}\n")
            tf.write("\n---\n\n")

    print(f"Saved configuration to '{json_file}' and '{txt_file}'.")
    log_debug("Recovery kit saved (passwordless; with auth catalog; decoy-enabled).", level="INFO")


# ---------- Recovery UI Flow from a saved kit (real + decoys, indistinguishable) ----------

def _try_combine_with_sampling(partials: list[bytes], r_thr: int) -> bytes | None:
    """
    Try to combine using multiple T-subsets:
      - Exhaustive if small (<= 5000 combinations)
      - Otherwise sample up to 200 random unique T-subsets
    Returns combined bytes on success, or None.
    """
    n = len(partials)
    if n < r_thr:
        return None
    if n == r_thr:
        try:
            return asyncio.run(sss_combine(partials))
        except Exception:
            return None

    max_exhaustive = 5000
    total_combos = math.comb(n, r_thr) if hasattr(math, "comb") else float("inf")

    # Exhaustive if small
    if total_combos <= max_exhaustive:
        for idxs in combinations(range(n), r_thr):
            try:
                return asyncio.run(sss_combine([partials[i] for i in idxs]))
            except Exception:
                continue
        return None

    # Random sampling (cryptographically random selection of indices)
    def sample_indices(nv: int, kv: int) -> tuple[int, ...]:
        s = set()
        while len(s) < kv:
            s.add(secrets.randbelow(nv))
        return tuple(sorted(s))

    seen = set()
    for _ in range(200):
        idxs = sample_indices(n, r_thr)
        if idxs in seen:
            continue
        seen.add(idxs)
        try:
            return asyncio.run(sss_combine([partials[i] for i in idxs]))
        except Exception:
            continue
    return None


def run_recovery_kit_flow(kit: dict, kit_path: Path):
    """
    Use the loaded recovery kit to reconstruct the secret:
      - Show config
      - Present questions via curses multi-select
      - Attempt REAL reconstruction from selected answers (needs >=T true shares)
      - If that fails, deterministically route to one DECOY and reconstruct from the same selections
      - Verify against AUTH CATALOG without revealing which secret matched
      - Print plausibly identical success output for real/decoy
    """
    try:
        cfg = kit.get("config") or {}
        questions = kit.get("questions") or []
        enc_shares = kit.get("encrypted_shares") or {}
        r_thr = int(cfg.get("real_threshold"))
        arg = cfg.get("argon2_params") or {}
        arg_time = int(arg.get("time_cost"))
        arg_mem = int(arg.get("memory_cost"))
        arg_par = int(arg.get("parallelism"))
        secrets_count = int(cfg.get("secrets_count", 1))
        auth_catalog = list(cfg.get("auth_catalog", []))
    except Exception as e:
        log_exception(e, "Invalid kit structure.")
        print("ERROR: Kit structure invalid or missing fields.")
        return

    # Summary
    print("\n--- LOADED RECOVERY KIT ---\n")
    print(f"File           : {kit_path.name}")
    print(f"Threshold (T)  : {r_thr}  [real path]")
    print(f"Pad Size       : {cfg.get('pad_size')}")
    print("Argon2id Params:")
    print(f"  - Time Cost  : {arg_time}")
    print(f"  - Memory Cost: {arg_mem} KiB")
    print(f"  - Parallelism: {arg_par}")
    print(f"Auth Catalog   : {len(auth_catalog)} entries\n")

    log_debug("Loaded recovery kit.",
              level="INFO",
              component="CRYPTO",
              details={
                  "kit_file": str(kit_path),
                  "threshold": r_thr,
                  "pad_size": cfg.get("pad_size"),
                  "argon2": {"time_cost": arg_time, "memory_cost": arg_mem, "parallelism": arg_par},
                  "q_count": len(questions),
                  "secrets_count": secrets_count
              })

    if not questions or not enc_shares:
        print("ERROR: Kit missing questions or encrypted_shares.")
        log_error("Kit missing essential arrays.", details={"has_questions": bool(questions), "has_enc_shares": bool(enc_shares)})
        return

    # Present questions via multi-select
    print("--- Answer the security questions ---\n")
    chosen = []
    for i, q in enumerate(questions, 1):
        text = q.get("text", "")
        alts = list(q.get("alternatives", []))
        picks = curses.wrapper(
            lambda st: arrow_select_no_toggle(
                st, i, text, alts, pre_selected=None
            )
        )
        chosen.append({"q": q, "picks": picks})
        log_debug("Recovery UI picks for question.",
                  level="INFO",
                  component="GENERAL",
                  details={"q_id": q.get("id"), "q_text": text, "picked": picks})

    # --- Decrypt selected shares for s0 (REAL path attempt) ---
    partials_s0: list[bytes] = []
    selected_pairs: list[tuple[str, str, str, str]] = []  # (q_hash, a_hash, q_text, alt_text)
    for item in chosen:
        qobj = item["q"]
        picks = item["picks"]
        q_text = qobj.get("text", "")
        alts = qobj.get("alternatives", [])
        q_hash = qobj.get("integrity_hash") or _integrity_hash_for_kit(q_text, alts)
        q_block = enc_shares.get(q_hash)
        if not q_block:
            log_error("Missing encrypted_shares block for question hash.", details={"q_hash": q_hash})
            continue
        for alt in picks:
            alt_hash = _alt_hash_for_kit(alt)
            sblock = q_block.get(alt_hash) or {}
            entry = sblock.get("s0")
            if not entry:
                log_error("No encrypted entry for selected alternative (s0).", details={"q_hash": q_hash, "alt_hash": alt_hash, "alt_text": alt})
                continue
            selected_pairs.append((q_hash, alt_hash, q_text, alt))
            share_bytes = _decrypt_share_from_entry(entry, arg_time, arg_mem, arg_par,
                                                    q_hash=q_hash, alt_hash=alt_hash,
                                                    qid=qobj.get("id"), qtext=q_text, alt_text=alt)
            if share_bytes is not None:
                partials_s0.append(share_bytes)

    # Try REAL combine with threshold r_thr
    combined_bytes = _try_combine_with_sampling(partials_s0, r_thr)
    selected_catalog_index = None
    secret_variant_used = "UNKNOWN"

    if combined_bytes is None:
        # Route to a deterministic DECOY based on the selection
        idx = _decoy_pick_index([(qh, ah) for (qh, ah, _, _) in selected_pairs], max(0, secrets_count - 1))
        decoy_index = max(1, idx)  # ensure >=1 if any decoys exist
        # Decrypt decoy shares (same selected answers), attempt combine with flexible T from 1..min(k, r_thr)
        qhash_ahash_pairs = selected_pairs
        decoy_partials: list[bytes] = []
        for (q_hash, a_hash, q_text, alt_text) in qhash_ahash_pairs:
            block = enc_shares.get(q_hash, {}).get(a_hash, {})
            entry = block.get(f"s{decoy_index}")
            if not entry:
                continue
            sb = _decrypt_share_from_entry(entry, arg_time, arg_mem, arg_par,
                                           q_hash=q_hash, alt_hash=a_hash,
                                           qid=None, qtext=q_text, alt_text=alt_text)
            if sb is not None:
                decoy_partials.append(sb)

        # escalate if not enough shares (pull deterministically from unpicked alts)
        if not decoy_partials:
            decoy_partials = []

        # If still not combinable, pull additional shares deterministically from remaining alts
        def _pull_more_for_decoy(target_count: int):
            if target_count <= len(decoy_partials):
                return
            for q in questions:
                q_text = q.get("text", "")
                alts = q.get("alternatives", [])
                q_hash = q.get("integrity_hash") or _integrity_hash_for_kit(q_text, alts)
                for alt_text in alts:
                    a_hash = _alt_hash_for_kit(alt_text)
                    if any((qh == q_hash and ah == a_hash) for (qh, ah, _, _) in qhash_ahash_pairs):
                        continue  # skip already selected
                    entry = enc_shares.get(q_hash, {}).get(a_hash, {}).get(f"s{decoy_index}")
                    if not entry:
                        continue
                    sb = _decrypt_share_from_entry(entry, arg_time, arg_mem, arg_par,
                                                   q_hash=q_hash, alt_hash=a_hash,
                                                   qid=None, qtext=q_text, alt_text=alt_text)
                    if sb is not None:
                        decoy_partials.append(sb)
                        if len(decoy_partials) >= target_count:
                            return

        # Try thresholds from 1..min(len(decoy_partials), r_thr) and pull more if needed
        success = False
        for t_try in range(1, max(1, min(len(decoy_partials), r_thr)) + 1):
            candidate = _try_combine_with_sampling(decoy_partials, t_try)
            if candidate is not None:
                combined_bytes = candidate
                success = True
                break

        if not success:
            # Ensure at least r_thr shares by pulling more
            _pull_more_for_decoy(r_thr)
            for t_try in range(1, max(1, min(len(decoy_partials), r_thr)) + 1):
                candidate = _try_combine_with_sampling(decoy_partials, t_try)
                if candidate is not None:
                    combined_bytes = candidate
                    success = True
                    break

        if not success:
            print("Recovery failed unexpectedly. Please re-run and pick different answers.")
            return

        secret_variant_used = f"DECOY_{decoy_index}"
    else:
        secret_variant_used = "REAL"

    # Decode final secret (base64  utf-8) and verify against AUTH CATALOG (indistinguishable)
    try:
        recovered_b64 = combined_bytes.decode("utf-8")
        final_secret_text = base64.b64decode(recovered_b64).decode("utf-8")

        # AUTH-CATALOG verification (no disclosure of which entry matched)
        matched = False
        for entry in auth_catalog:
            try:
                salt = base64.b64decode(entry.get("salt", ""))
                expected = base64.b64decode(entry.get("hmac_sha256", ""))
                kdf = HKDF(algorithm=hashes.SHA256(), length=32, salt=salt, info=b"SECQ final-auth v3")
                k_auth = kdf.derive(final_secret_text.encode("utf-8"))
                calc = hmac.new(k_auth, final_secret_text.encode("utf-8"), digestmod="sha256").digest()
                if hmac.compare_digest(calc, expected):
                    matched = True
                    break
            except Exception:
                continue

        print("\n[AUTH OK]" if matched else "\n[AUTH WARNING] (non-catalog secret)\n")
        print("--- SECRET RECONSTRUCTED ---")
        print(final_secret_text)
        print("-----------------------------\n")
        log_debug("Final secret reconstructed.", level="INFO", component="CRYPTO",
                  details={"final_secret_len": len(final_secret_text), "variant": secret_variant_used})
    except Exception as e:
        log_exception(e, "Final base64/utf-8 decode failed.")
        print("\nShares combined, but final decode failed (invalid base64 or encoding).\n")

    append_recovery_guide()
    log_debug("Recovery Mode complete.", level="INFO")

    # End-of-flow options (per requirement)
    print("Press 1  Enter setup phase")
    print("Press 2  Proceed to example demonstration")


# ---------- existing demonstration / combine path (kept; AAD added; ChaCha tag removed) ----------

def get_next_filename(base_dir, base_name, extension):
    idx = 0
    while True:
        idx += 1
        candidate = base_dir / (f"{base_name}.{extension}" if idx == 1 else f"{base_name}{idx}.{extension}")
        if not candidate.exists():
            return candidate


def check_required_files():
    needed_in_src = ["CipherForge.py", "example_questions25.json"]
    missing = []
    for f in needed_in_src:
        if not (SRC_DIR / f).exists():
            missing.append(f)
    modules_path = SRC_DIR / "modules"
    needed_in_modules = [
        "debug_utils.py",
        "input_utils.py",
        "log_processor.py",
        "security_utils.py",
        "split_utils.py",
        "sss_bridge.py",
        "ui_utils.py"
    ]
    for f in needed_in_modules:
        if not (modules_path / f).exists():
            missing.append(f"modules/{f}")
    if missing:
        log_error("Missing required files", None, {"missing": missing})
        print("ERROR - Missing files:", missing)
        sys.exit(1)


def prompt_argon2_parameters():
    print("\n--- Argon2id Parameter Setup ---")
    print("Use (n) normal defaults, (a) auto-calibrate, or (e) custom edit? [n/a/e] ", end="")
    choice_ = input().strip().lower()
    if choice_ == 'a':
        t, m_kib, p, ms = calibrate_argon2()
        print(f"Auto-calibrated: time_cost={t}, memory_cost={m_kib} KiB, parallelism={p} (~{ms:.1f} ms/guess)")
        return (t, m_kib, p)
    if choice_ != 'e':
        # Stronger defaults: 3 iters, 256 MiB, p=1
        print("Using DEFAULT Argon2id parameters: time_cost=3, memory_cost=262144, parallelism=1")
        input("Press ENTER to continue with these defaults...")
        return (3, 262144, 1)
    else:
        print("Enter custom Argon2id parameters:")
        tc = get_valid_int("time_cost (1..10)? ", 1, 10)
        mc = get_valid_int("memory_cost (8192..1048576)? ", 8192, 1048576)
        pl = get_valid_int("parallelism (1..32)? ", 1, 32)
        print(f"Using CUSTOM Argon2id parameters: time_cost={tc}, memory_cost={mc}, parallelism={pl}")
        return (tc, mc, pl)


def calc_qna_search_space(chosen):
    total = 1
    for q in chosen:
        n_alts = len(q["alternatives"])
        ways = (1 << n_alts) - 1 if n_alts > 0 else 1
        total *= max(1, ways)
    return total


def convert_seconds_to_dhms(seconds):
    out = {"years":0,"months":0,"days":0,"hours":0,"minutes":0,"seconds":0.0}
    if seconds <= 0: return out
    year_sec   = 365.25*24*3600
    month_sec  = 30.4375*24*3600
    day_sec    = 24*3600
    hour_sec   = 3600
    minute_sec = 60
    out["years"]   = int(seconds // year_sec); seconds %= year_sec
    out["months"]  = int(seconds // month_sec); seconds %= month_sec
    out["days"]    = int(seconds // day_sec); seconds %= day_sec
    out["hours"]   = int(seconds // hour_sec); seconds %= hour_sec
    out["minutes"] = int(seconds // minute_sec); seconds %= minute_sec
    out["seconds"] = seconds
    return out


def print_estimated_bruteforce_times(chosen, arg_time, arg_mem, arg_par,
                                     total_correct_lower: int | None = None,
                                     r_thr: int | None = None,
                                     decoy_present: bool = True):
    """
    Enhanced brute-force estimator (beta):
    - Shows search space for all non-empty answer subsets (per your UI).
    - Shows *lower bound* trials for reaching the real threshold: C(C_total, T).
    - Shows minimal trials for a decoy: 1 if at least one decoy with threshold=1, else C(N_total, T).
    - Compares with Argon2id vs WITHOUT Argon2id.
    - Includes Grover (sqrt) estimates for both cases.
    """
    import math
    search_space = max(1, calc_qna_search_space(chosen))
    single_guess_ms = estimate_argon2_time_ms(arg_time, arg_mem, arg_par, samples=1)
    # Assume a tight lower bound for "no Argon2" primitive crypto guess
    single_guess_ms_no_argon = 0.005  # 5 microseconds per attempt (model)

    # Total attempts to brute-force "any subset"
    total_classical_ms = search_space * single_guess_ms
    total_quantum_ms   = math.sqrt(search_space) * single_guess_ms
    total_classical_ms_na = search_space * single_guess_ms_no_argon
    total_quantum_ms_na   = math.sqrt(search_space) * single_guess_ms_no_argon

    # Real threshold lower-bound trials (choose exactly r_thr correct picks)
    trials_real_lb = None
    if total_correct_lower is not None and r_thr is not None and total_correct_lower >= r_thr:
        trials_real_lb = math.comb(total_correct_lower, r_thr)
    # Decoy minimal trials
    # We generated at least one decoy with threshold=1 when decoys are present.
    trials_decoy_min = 1 if decoy_present else None

    def _fmt_time(ms: float) -> dict:
        sec = ms / 1000.0
        return convert_seconds_to_dhms(sec)

    print("\n--- Estimated Brute-Force Difficulty ---")
    print(f"Total Q&A search space (non-empty subsets): {search_space:,.0f} guesses.")

    print("\n[WITH Argon2id] per-guess ~{:.3f} ms =>".format(single_guess_ms))
    cl = _fmt_time(total_classical_ms); qn = _fmt_time(total_quantum_ms)
    print(f"  Classical total time : {cl['years']}y {cl['months']}m {cl['days']}d {cl['hours']}h {cl['minutes']}m {cl['seconds']:.2f}s")
    print(f"  Quantum (Grover est.): {qn['years']}y {qn['months']}m {qn['days']}d {qn['hours']}h {qn['minutes']}m {qn['seconds']:.2f}s")

    print("\n[WITHOUT Argon2id] per-guess ~{:.3f} ms =>".format(single_guess_ms_no_argon))
    cl2 = _fmt_time(total_classical_ms_na); qn2 = _fmt_time(total_quantum_ms_na)
    print(f"  Classical total time : {cl2['years']}y {cl2['months']}m {cl2['days']}d {cl2['hours']}h {cl2['minutes']}m {cl2['seconds']:.2f}s")
    print(f"  Quantum (Grover est.): {qn2['years']}y {qn2['months']}m {qn2['days']}d {qn2['hours']}h {qn2['minutes']}m {qn2['seconds']:.2f}s")

    if trials_real_lb is not None:
        print(f"\nLower-bound trials to reach the REAL threshold: C(C_total={total_correct_lower}, T={r_thr}) = {trials_real_lb:,d}")
    if trials_decoy_min is not None:
        print(f"Minimal trials to reach *a decoy* (given at least one decoy has T=1): {trials_decoy_min}")

    print()  # newline


# ---------- Demo flow (unchanged UX; AAD added; ChaCha tag removed) ----------

def main():
    try:
        print("[INFO] Launching main.py...")
        log_debug("Starting demonstration flow (Option 2)...", level="INFO")

        if not QUESTIONS_PATH.exists():
            msg = f"Error: question file not found: {QUESTIONS_PATH}"
            log_error(msg)
            print(msg)
            return
        try:
            with open(QUESTIONS_PATH, "r", encoding="utf-8") as f:
                data = json.load(f)
            empty_correct = 0
            for qd in data:
                if validate_question(qd):
                    qd["correct_answers"] = [
                        sanitize_input(normalize_text(ans)) for ans in qd.get("correct_answers", [])
                    ]
                    qd["alternatives"] = [
                        sanitize_input(normalize_text(alt)) for alt in qd["alternatives"]]
                    if not qd["correct_answers"]:
                        empty_correct += 1
                        qd["correct_answers"] = qd["alternatives"][:]
                        log_debug(
                            f"Question '{qd['text']}' had empty 'correct_answers'. Now set them all as correct.",
                            level="INFO"
                        )
            valid_data = [q for q in data if validate_question(q)]
            if empty_correct > 0:
                print(f"NOTICE: {empty_correct} question(s) had empty 'correct_answers'. "
                      f"All alternatives for those are treated as correct.\n")
        except Exception as e:
            log_exception(e, "Error loading question file")
            return
        if not valid_data:
            print("No valid questions found. Aborting.")
            return

        amt = get_valid_int(f"How many questions? (1..{len(valid_data)}): ", 1, len(valid_data))
        with chosen_lock:
            chosen = valid_data[:amt]

        # interactive selection with curses
        correct_cumulative = 0
        incorrect_cumulative = 0
        for i, qdict in enumerate(chosen, 1):
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, i, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            qdict["is_critical"] = bool(qtype) if not qdict.get("force_type") \
                else (qdict["force_type"].upper() == "CRITICAL")

            c_local = 0
            i_local = 0
            cset_local = set(qdict.get("correct_answers", []))
            for alt_ in picks:
                if alt_ in cset_local:
                    c_local += 1
                else:
                    i_local += 1

            log_debug(
                f"Q{i}: text='{qdict['text']}' => user_picks={len(picks)} selected; local counts: correct={c_local}, incorrect={i_local}",
                level="DEBUG"
            )
            correct_cumulative += c_local
            incorrect_cumulative += i_local
            print(f"[FEEDBACK] After Q{i}: +{c_local} correct, +{i_local} incorrect.")
            print(f"Total so far => correct={correct_cumulative}, incorrect={incorrect_cumulative}\n")

        while True:
            done = editing_menu(chosen)
            if done:
                break

        correct_map = []
        incorrect_map = []
        for idx, q in enumerate(chosen, 1):
            cset = set(q.get("correct_answers", []))
            picks_ = q["user_answers"]
            local_c = 0
            local_i = 0
            for alt in picks_:
                if alt in cset:
                    correct_map.append((q, alt))
                    local_c += 1
                else:
                    incorrect_map.append((q, alt))
                    local_i += 1
            log_debug(f"After re-edit Q{idx}: c={local_c}, i={local_i}", level="INFO")

        c_count = len(correct_map)
        i_count = len(incorrect_map)
        log_debug(f"FINAL TALLY => c_count={c_count}, i_count={i_count}", level="INFO")
        print(f"\nOverall Tally => Correct picks={c_count}, Incorrect={i_count}.\n")

        # minimum correctness for demo path
        while True:
            if c_count < 10:
                if c_count == 0:
                    print("Zero correct picks => cannot proceed with Shamirs Secret Sharing.")
                    print("(E => re-edit answers, N => abort)")
                    answer = input("Choice (E/N)? ").strip().upper()
                    if answer == 'E':
                        re_done = editing_menu(chosen)
                        if re_done:
                            correct_map.clear(); incorrect_map.clear()
                            for q_ in chosen:
                                cset_ = set(q_.get("correct_answers", []))
                                picks_ = q_["user_answers"]
                                for alt_ in picks_:
                                    (correct_map if alt_ in cset_ else incorrect_map).append((q_, alt_))
                            c_count = len(correct_map); i_count = len(incorrect_map)
                            print(f"\nNEW Tally => Correct picks={c_count}, Incorrect={i_count}.\n")
                            continue
                    elif answer == 'N':
                        confirm = input("Are you sure you want to abort? (y/n): ").strip().lower()
                        if confirm.startswith('y'):
                            print("Aborting.")
                            return
                        else:
                            continue
                    else:
                        print("Invalid choice.\n")
                        continue
                else:
                    print("Fewer than 10 correct => re-edit or abort.")
                    answer = input("Choice (E/N)? ").strip().upper()
                    if answer == 'E':
                        re_done = editing_menu(chosen)
                        if re_done:
                            correct_map.clear(); incorrect_map.clear()
                            for q_ in chosen:
                                cset_ = set(q_.get("correct_answers", []))
                                picks_ = q_["user_answers"]
                                for alt_ in picks_:
                                    (correct_map if alt_ in cset_ else incorrect_map).append((q_, alt_))
                            c_count = len(correct_map); i_count = len(incorrect_map)
                            print(f"\nNEW Tally => Correct picks={c_count}, Incorrect={i_count}.\n")
                            continue
                    elif answer == 'N':
                        confirm = input("Are you sure you want to abort? (y/n): ").strip().lower()
                        if confirm.startswith('y'):
                            print("Aborting.")
                            return
                        else:
                            continue
                    else:
                        print("Invalid choice.\n")
                        continue
            else:
                break

        prompt_text = "Real threshold"
        r_thr = get_threshold(prompt_text, 10, c_count)
        print(f"[INFO] Must pick >= {r_thr} correct picks to reconstruct real secret.\n")

        real_secret = get_nonempty_secret("Enter REAL secret: ")
        real_b64 = base64.b64encode(real_secret.encode()).decode()
        user_pad = prompt_pad_size_multi(len(real_b64))
        arg_time, arg_mem, arg_par = prompt_argon2_parameters()

        # Split real/dummy shares
        try:
            real_shares, dummy_shares = asyncio.run(
                split_secret_and_dummy(real_b64.encode(), c_count, i_count, r_thr, pad=user_pad)
            )
        except Exception as e:
            log_exception(e, "Error splitting secret")
            return

        def ephemeral_encrypt(data: bytes, q_text: str, alt_text: str, alg_choice: str) -> dict:
            """
            Demo-only: keep ephemeral credentials, but add AAD binding for AEAD.
            """
            ephemeral_pass = base64.b64encode(os.urandom(12)).decode()
            ephemeral_salt = os.urandom(16)
            ephemeral_key, ephemeral_salt_used = derive_or_recover_key(
                ephemeral_pass, ephemeral_salt, ephemeral=True,
                time_cost=arg_time, memory_cost=arg_mem, parallelism=arg_par
            )
            q_hash = _integrity_hash_for_kit(q_text, q["alternatives"])
            alt_hash = _alt_hash_for_kit(alt_text)
            aad = _aad_bytes(q_hash, alt_hash, alg_choice)

            if alg_choice == "chacha20poly1305":
                enc_obj = encrypt_chacha20poly1305(
                    data, ephemeral_key, aad=aad,
                    ephemeral_pass=ephemeral_pass,
                    ephemeral_salt=ephemeral_salt_used
                )
            else:
                enc_obj = encrypt_aes256gcm(
                    data, ephemeral_key, aad=aad,
                    ephemeral_pass=ephemeral_pass,
                    ephemeral_salt=ephemeral_salt_used
                )
            enc_obj["ephemeral_password"] = ephemeral_pass
            enc_obj["ephemeral_salt_b64"] = base64.b64encode(ephemeral_salt_used).decode()
            enc_obj["algorithm"] = alg_choice
            return enc_obj

        # Assign shares
        std_correct, crit_correct, std_incorrect, crit_incorrect = [], [], [], []
        for (q, alt) in correct_map:
            (crit_correct if q["is_critical"] else std_correct).append((q, alt))
        for (q, alt) in incorrect_map:
            (crit_incorrect if q["is_critical"] else std_incorrect).append((q, alt))

        share_idx_real = 0
        share_idx_dummy = 0

        for q_s, alt_s in std_correct:
            if share_idx_real >= len(real_shares): break
            sh = real_shares[share_idx_real]
            enc_full = ephemeral_encrypt(sh, q_s["text"], alt_s, secrets.choice(["chacha20poly1305","aes256gcm"]))
            q_s.setdefault("answer_shares", {})
            q_s["answer_shares"][alt_s] = {"enc_data": enc_full}
            for j in range(len(sh)): sh[j] = 0
            share_idx_real += 1

        for q_c, alt_c in crit_correct:
            if share_idx_real >= len(real_shares): break
            if not q_c.get("answer_shares", {}).get(alt_c):
                sh = real_shares[share_idx_real]
                enc_full = ephemeral_encrypt(sh, q_c["text"], alt_c, secrets.choice(["chacha20poly1305","aes256gcm"]))
                q_c.setdefault("answer_shares", {})
                q_c["answer_shares"][alt_c] = {"enc_data": enc_full}
                for j in range(len(sh)): sh[j] = 0
                share_idx_real += 1

        for q_s, alt_s in std_incorrect:
            if share_idx_dummy >= len(dummy_shares): break
            sh = dummy_shares[share_idx_dummy]
            enc_full = ephemeral_encrypt(sh, q_s["text"], alt_s, secrets.choice(["chacha20poly1305","aes256gcm"]))
            q_s.setdefault("answer_shares", {})
            q_s["answer_shares"][alt_s] = {"enc_data": enc_full}
            for j in range(len(sh)): sh[j] = 0
            share_idx_dummy += 1

        for q_c, alt_c in crit_incorrect:
            if share_idx_dummy >= len(dummy_shares): break
            if not q_c.get("answer_shares", {}).get(alt_c):
                sh = dummy_shares[share_idx_dummy]
                enc_full = ephemeral_encrypt(sh, q_c["text"], alt_c, secrets.choice(["chacha20poly1305","aes256gcm"]))
                q_c.setdefault("answer_shares", {})
                q_c["answer_shares"][alt_c] = {"enc_data": enc_full}
                for j in range(len(sh)): sh[j] = 0
                share_idx_dummy += 1

        print("\n--- Final Answering Phase ---\n")
        for i, q in enumerate(chosen, 1):
            picks2 = curses.wrapper(
                lambda st: arrow_select_no_toggle(
                    st, i, q["text"], q["alternatives"],
                    pre_selected=q.get("user_answers")
                )
            )
            q["user_answers"] = picks2

        while True:
            result = final_edit_menu(chosen)
            if result == 'G':
                log_debug("User finalize => combine secrets now.", level="INFO")
                break
            elif result == 'N':
                print("Aborted before final reconstruction. Exiting.")
                return

        # gather and decrypt selected shares (AAD bound)
        partials = []
        for q in chosen:
            if "user_answers" not in q or "answer_shares" not in q:
                continue
            q_hash = _integrity_hash_for_kit(q["text"], q["alternatives"])
            for alt in q["user_answers"]:
                share_info = q["answer_shares"].get(alt)
                if not share_info:
                    continue
                enc_data = share_info["enc_data"]
                ephemeral_pass = enc_data.get("ephemeral_password")
                ephemeral_salt_b64 = enc_data.get("ephemeral_salt_b64")
                if not ephemeral_pass or not ephemeral_salt_b64:
                    log_error("Missing ephemeral credentials for a selected answer.")
                    continue
                try:
                    ephemeral_salt = base64.b64decode(ephemeral_salt_b64)
                except Exception as e:
                    log_error(f"Base64 decode error for salt: {e}")
                    continue
                ephemeral_key, _ = derive_or_recover_key(
                    ephemeral_pass, ephemeral_salt, ephemeral=True,
                    time_cost=arg_time, memory_cost=arg_mem, parallelism=arg_par
                )
                dec_pt = None
                try:
                    alg = enc_data.get("algorithm")
                    aad = _aad_bytes(q_hash, _alt_hash_for_kit(alt), alg)
                    if alg == "chacha20poly1305":
                        dec_pt = decrypt_chacha20poly1305(enc_data, ephemeral_key, aad=aad)
                    else:
                        dec_pt = decrypt_aes256gcm(enc_data, ephemeral_key, aad=aad)
                    log_debug("Demo path decrypted share.",
                              level="INFO",
                              component="CRYPTO",
                              details={"share_sha3_256_hex": hash_share(dec_pt),
                                       "algorithm": alg})
                    partials.append(dec_pt)
                except Exception as e:
                    log_error("Decryption failed for a selected answer.", exc=e)

        if len(partials) < r_thr:
            print(f"\nNot enough shares to reconstruct. Got={len(partials)}, need={r_thr}")
            # Per requirement: offer options again at end of case
            print("Press 1  Enter setup phase")
            print("Press 2  Proceed to example demonstration")
            return
        try:
            combined_bytes = _try_combine_with_sampling(partials, r_thr)
            if combined_bytes is None:
                raise RuntimeError("No T-subset succeeded")
            reconstructed_real_b64 = combined_bytes.decode('utf-8')
            log_debug("Demo combine succeeded.", level="INFO", component="CRYPTO",
                      details={"combined_len": len(combined_bytes)})
        except Exception as e:
            log_exception(e, "SSS Combine failed during final reconstruction")
            reconstructed_real_b64 = None

        print("\n--- FINAL RECONSTRUCTION RESULTS ---\n")
        if reconstructed_real_b64:
            try:
                final_secret_text = base64.b64decode(reconstructed_real_b64).decode('utf-8')
                print(f"REAL SECRET recovered: {final_secret_text}\n")
                log_debug("Demo final base64 decode OK.", level="INFO", component="CRYPTO",
                          details={"final_secret_len": len(final_secret_text)})
            except Exception as e:
                log_exception(e, "Failed to decode base64 or utf-8 from combined secret.")
                print("Secret combined, but failed final decode.\n")
        else:
            print("Secret not recoverable.\n")

        append_recovery_guide()
        log_debug("Done with main program.", level="INFO")
        print_estimated_bruteforce_times(
            chosen,
            arg_time, arg_mem, arg_par,
            total_correct_lower=sum(len(q.get("correct_answers", [])) for q in chosen),
            r_thr=r_thr,
            decoy_present=True
        )

        # Per requirement: offer options again at end of case
        print("Press 1  Enter setup phase")
        print("Press 2  Proceed to example demonstration")

    except curses.error as e:
        log_exception(e, "Curses error in main()")
        print(f"A Curses error occurred: {e}. Your terminal might not be fully compatible or window too small.")
        print("Please try again with a different terminal or ensure it's large enough.")
    except Exception as exc_main:
        log_exception(exc_main, "Fatal error in main()")
        print(f"FATAL ERROR: {exc_main}")
        sys.exit(1)


if __name__ == "__main__":
    ensure_debug_dir()
    check_required_files()
    show_start_menu()
    main()



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\main.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\SSS.py
# SIZE: 8549 bytes
# HASH: f260ed557c085ccc619320d68605a01b7b7d2a017f8f1a450487ceb514433f33
# MODIFIED: 2025-08-26T22:53:57.932890
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "SSS.py"
################################################################################

"""
FILENAME:
"SSS.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
SSS: Provides sss_split() & sss_combine() for Shamir's Secret Sharing in GF(2^8).
"""


def gf_add(a: int, b: int) -> int:
    return a ^ b


LOG_TABLE = bytes([
    0x00,0xff,0xc8,0x08,0x91,0x10,0xd0,0x36,0x5a,0x3e,0xd8,0x43,0x99,0x77,0xfe,0x18,
    0x23,0x20,0x07,0x70,0xa1,0x6c,0x0c,0x7f,0x62,0x8b,0x40,0x46,0xc7,0x4b,0xe0,0x0e,
    0xeb,0x16,0xe8,0xad,0xcf,0xcd,0x39,0x53,0x6a,0x27,0x35,0x93,0xd4,0x4e,0x48,0xc3,
    0x2b,0x79,0x54,0x28,0x09,0x78,0x0f,0x21,0x90,0x87,0x14,0x2a,0xa9,0x9c,0xd6,0x74,
    0xb4,0x7c,0xde,0xed,0xb1,0x86,0x76,0xa4,0x98,0xe2,0x96,0x8f,0x02,0x32,0x1c,0xc1,
    0x33,0xee,0xef,0x81,0xfd,0x30,0x5c,0x13,0x9d,0x29,0x17,0xc4,0x11,0x44,0x8c,0x80,
    0xf3,0x73,0x42,0x1e,0x1d,0xb5,0xf0,0x12,0xd1,0x5b,0x41,0xa2,0xd7,0x2c,0xe9,0xd5,
    0x59,0xcb,0x50,0xa8,0xdc,0xfc,0xf2,0x56,0x72,0xa6,0x65,0x2f,0x9f,0x9b,0x3d,0xba,
    0x7d,0xc2,0x45,0x82,0xa7,0x57,0xb6,0xa3,0x7a,0x75,0x4f,0xae,0x3f,0x37,0x6d,0x47,
    0x61,0xbe,0xab,0xd3,0x5f,0xb0,0x58,0xaf,0xca,0x5e,0xfa,0x85,0xe4,0x4d,0x8a,0x05,
    0xfb,0x60,0xb7,0x7b,0xb8,0x26,0x4a,0x67,0xc6,0x1a,0xf8,0x69,0x25,0xb3,0xdb,0xbd,
    0x66,0xdd,0xf1,0xd2,0xdf,0x03,0x8d,0x34,0xd9,0x92,0x0d,0x63,0x55,0xaa,0x49,0xec,
    0xbc,0x95,0x3c,0x84,0x0b,0xf5,0xe6,0xe7,0xe5,0xac,0x7e,0x6e,0xb9,0xf9,0xda,0x8e,
    0x9a,0xc9,0x24,0xe1,0x0a,0x15,0x6b,0x3a,0xa0,0x51,0xf4,0xea,0xb2,0x97,0x9e,0x5d,
    0x22,0x88,0x94,0xce,0x19,0x01,0x71,0x4c,0xa5,0xe3,0xc5,0x31,0xbb,0xcc,0x1f,0x2d,
    0x3b,0x52,0x6f,0xf6,0x2e,0x89,0xf7,0xc0,0x68,0x1b,0x64,0x04,0x06,0xbf,0x83,0x38,
])
EXP_TABLE = bytes([
    0x01,0xe5,0x4c,0xb5,0xfb,0x9f,0xfc,0x12,0x03,0x34,0xd4,0xc4,0x16,0xba,0x1f,0x36,
    0x05,0x5c,0x67,0x57,0x3a,0xd5,0x21,0x5a,0x0f,0xe4,0xa9,0xf9,0x4e,0x64,0x63,0xee,
    0x11,0x37,0xe0,0x10,0xd2,0xac,0xa5,0x29,0x33,0x59,0x3b,0x30,0x6d,0xef,0xf4,0x7b,
    0x55,0xeb,0x4d,0x50,0xb7,0x2a,0x07,0x8d,0xff,0x26,0xd7,0xf0,0xc2,0x7e,0x09,0x8c,
    0x1a,0x6a,0x62,0x0b,0x5d,0x82,0x1b,0x8f,0x2e,0xbe,0xa6,0x1d,0xe7,0x9d,0x2d,0x8a,
    0x72,0xd9,0xf1,0x27,0x32,0xbc,0x77,0x85,0x96,0x70,0x08,0x69,0x56,0xdf,0x99,0x94,
    0xa1,0x90,0x18,0xbb,0xfa,0x7a,0xb0,0xa7,0xf8,0xab,0x28,0xd6,0x15,0x8e,0xcb,0xf2,
    0x13,0xe6,0x78,0x61,0x3f,0x89,0x46,0x0d,0x35,0x31,0x88,0xa3,0x41,0x80,0xca,0x17,
    0x5f,0x53,0x83,0xfe,0xc3,0x9b,0x45,0x39,0xe1,0xf5,0x9e,0x19,0x5e,0xb6,0xcf,0x4b,
    0x38,0x04,0xb9,0x2b,0xe2,0xc1,0x4a,0xdd,0x48,0x0c,0xd0,0x7d,0x3d,0x58,0xde,0x7c,
    0xd8,0x14,0x6b,0x87,0x47,0xe8,0x79,0x84,0x73,0x3c,0xbd,0x92,0xc9,0x23,0x8b,0x97,
    0x95,0x44,0xdc,0xad,0x40,0x65,0x86,0xa2,0xa4,0xcc,0x7f,0xec,0xc0,0xaf,0x91,0xfd,
    0xf7,0x4f,0x81,0x2f,0x5b,0xea,0xa8,0x1c,0x02,0xd1,0x98,0x71,0xed,0x25,0xe3,0x24,
    0x06,0x68,0xb3,0x93,0x2c,0x6f,0x3e,0x6c,0x0a,0xb8,0xce,0xae,0x74,0xb1,0x42,0xb4,
    0x1e,0xd3,0x49,0xe9,0x9c,0xc8,0xc6,0xc7,0x22,0x6e,0xdb,0x20,0xbf,0x43,0x51,0x52,
    0x66,0xb2,0x76,0x60,0xda,0xc5,0xf3,0xf6,0xaa,0xcd,0x9a,0xa0,0x75,0x54,0x0e,0x01,
])


def gf_add(a: int, b: int) -> int:
    """
    GF(2^8) addition is XOR.
    """
    return a ^ b


def gf_mult(a: int, b: int) -> int:
    """
    GF(2^8) multiplication using log/exp tables.
    """
    if a == 0 or b == 0:
        return 0
    la = LOG_TABLE[a]
    lb = LOG_TABLE[b]
    x = (la + lb) % 255
    return EXP_TABLE[x]


def gf_div(a: int, b: int) -> int:
    """
    GF(2^8) division using log/exp tables.
    """
    if b == 0:
        raise ZeroDivisionError("GF division by zero")
    if a == 0:
        return 0
    la = LOG_TABLE[a]
    lb = LOG_TABLE[b]
    diff = (la - lb + 255) % 255
    return EXP_TABLE[diff]


def gf_eval(coeffs: bytes, x: int, deg: int) -> int:
    """
    Evaluate polynomial with Horner's method in GF(2^8).
    """
    val = coeffs[deg]
    for i in reversed(range(deg)):
        val = gf_mult(val, x) ^ coeffs[i]
    return val


def gf_interp(xs: bytes, ys: bytes, x: int) -> int:
    """
    Lagrange interpolation in GF(2^8).
    """
    if len(xs) != len(ys):
        raise ValueError("sample mismatch for gf_interp")
    val = 0
    n = len(xs)
    for i in range(n):
        basis = 1
        for j in range(n):
            if i == j:
                continue
            num = x ^ xs[j]
            den = xs[i] ^ xs[j]
            tmp = gf_div(num, den)
            basis = gf_mult(basis, tmp)
        val ^= gf_mult(ys[i], basis)
    return val


def pack_len(n: int) -> bytes:
    return n.to_bytes(2, 'big')


def unpack_len(b: bytes) -> int:
    return int.from_bytes(b, 'big')


async def sss_split(secret: bytes, shares: int, threshold: int, pad: int=128) -> list[bytearray]:
    """
    Split 'secret' into 'shares' using threshold, each padded to 'pad' bytes + 1 byte for x-coord.
    """
    if shares < threshold:
        raise ValueError("shares < threshold in sss_split")
    if pad < len(secret):
        raise ValueError("pad must >= secret length")

    import secrets
    length_part = pack_len(len(secret))
    extra = pad - 2 - len(secret)
    if extra < 0:
        raise ValueError("pad too small unexpectedly")
    padded = length_part + secret + b'\x00' * extra

    out = []
    for _ in range(shares):
        out.append(bytearray(pad + 1))

    deg = threshold - 1
    coords = list(range(1, shares + 1))
    for i in range(shares):
        out[i][pad] = coords[i]

    for byte_index in range(pad):
        # polynomial of deg 'threshold-1'
        poly = bytearray(deg + 1)
        poly[0] = padded[byte_index]
        for d in range(1, deg + 1):
            poly[d] = secrets.randbits(8)

        for i in range(shares):
            x = coords[i]
            val = gf_eval(poly, x, deg)
            out[i][byte_index] = val

    return out


async def sss_combine(shares: list[bytes]) -> bytes:
    """
    Combine Shamir shares to reconstruct padded secret. Then parse length from first 2 bytes.
    """
    if not shares:
        raise ValueError("No shares passed to sss_combine")
    length = len(shares[0])
    pad = length - 1
    xcoords = []
    for s in shares:
        if len(s) != length:
            raise ValueError("Inconsistent share length")
        xcoords.append(s[pad])
    if len(set(xcoords)) != len(shares):
        raise ValueError("Duplicate x-coord in shares")

    n = len(shares)
    rec = bytearray(pad)
    for b_i in range(pad):
        xs = bytearray(n)
        ys = bytearray(n)
        for i in range(n):
            xs[i] = xcoords[i]
            ys[i] = shares[i][b_i]
        val = gf_interp(xs, ys, 0)
        rec[b_i] = val

    real_len = unpack_len(rec[:2])
    if real_len > pad - 2:
        return bytes(rec)  # fallback
    return rec[2:2 + real_len]

################################################################################
# END OF FILE: "SSS.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\SSS.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__init__.py
# SIZE: 1545 bytes
# HASH: 7f932463e1a2f9e5331861dad9ed8c3e5e3ac13e9b9e10da5e3cd54fb60aa8c0
# MODIFIED: 2025-08-27T02:19:21.015486
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

"""
FILENAME:
"__init__.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

__all__ = [
    "debug_utils",
    "input_utils",
    "log_processor",
    "security_utils",
    "split_utils",
    "sss_bridge", # Use the new SSS bridge
    "ui_utils"
]



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__init__.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\SSS.cpython-313.pyc
# SIZE: 11658 bytes
# HASH: 6b1392bd37bd6191c1636fea9306a1acba507b53ddc699dc9a58cbd3d16a212d
# MODIFIED: 2025-08-27T02:19:21.016486
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\SSS.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\__init__.cpython-313.pyc
# SIZE: 1630 bytes
# HASH: d4be2e4281e23939e64e9f4ac94087c8fbadc7839787c2bfd94720dba1096cc5
# MODIFIED: 2025-08-29T04:23:50.229117
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\__init__.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\crypto_bridge.cpython-313.pyc
# SIZE: 13899 bytes
# HASH: 24530212ca6e3315cd82727c7b76d85f04e222d8e8ff16d58279772cdf583da8
# MODIFIED: 2025-08-29T00:11:46.892753
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\crypto_bridge.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\crypto_utils.cpython-313.pyc
# SIZE: 2921 bytes
# HASH: 3263eff740eb3e9d94d5da13792b2d5ff3309cf53aaa3e0a4228c4f7380afd96
# MODIFIED: 2025-08-27T02:19:21.017488
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\crypto_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\debug_utils.cpython-313.pyc
# SIZE: 12634 bytes
# HASH: 683529eeec51b40df11d9f8ae7642c34609336bc71ba15576598fd054d01cf90
# MODIFIED: 2025-08-29T04:23:39.249699
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\debug_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\input_utils.cpython-313.pyc
# SIZE: 3056 bytes
# HASH: 9b430c50c3ccd04ef8d4b877b84a802a02c24c098c3556619fb8d2d3022b58bf
# MODIFIED: 2025-08-27T02:19:21.018486
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\input_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\noble_bridge.cpython-313.pyc
# SIZE: 12529 bytes
# HASH: 286136f7044859a28910916c337796904e08268c73c5c23636aa2c80783211da
# MODIFIED: 2025-08-29T04:23:50.256003
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\noble_bridge.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\rng.cpython-313.pyc
# SIZE: 3366 bytes
# HASH: 648bafb8ccec966de130600867ccb7e9494ab5d0d12f88322df2f4e66a83d957
# MODIFIED: 2025-08-29T04:50:16.944470
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\rng.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\security_utils.cpython-313.pyc
# SIZE: 4291 bytes
# HASH: 2b1dd4ab905341004ca135b0c9fc7bc16bbc10b21ff054cf8aafb927d2787062
# MODIFIED: 2025-08-29T04:23:39.250699
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\security_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\split_utils.cpython-313.pyc
# SIZE: 4516 bytes
# HASH: 9c5f2cddb1b7b012789348e0512c7fd14a6a57bc422f5a56c9ef40262120e577
# MODIFIED: 2025-08-27T02:19:21.019489
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\split_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\sss_bridge.cpython-313.pyc
# SIZE: 7365 bytes
# HASH: 177133cc2ad5ec5d951e7790f66b85e24ccb0c2e23f3e516dc49ecb46c6ec164
# MODIFIED: 2025-08-27T02:19:21.019489
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\sss_bridge.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\ui_utils.cpython-313.pyc
# SIZE: 11328 bytes
# HASH: 563d15e27c4baf62244fa8115dfef18b7f0ab95541fdfa3f76695b1d9fe1ed44
# MODIFIED: 2025-08-27T02:19:21.020488
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\__pycache__\ui_utils.cpython-313.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\debug_utils.py
# SIZE: 8881 bytes
# HASH: 2789244f9bce9a8fa57b5fd1fc8ff6038230a9662f36f2b975e16decfe66a338
# MODIFIED: 2025-08-27T02:19:21.020488
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

#!/usr/bin/env python3
"""
FILENAME:
"debug_utils.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

import os
import json
import uuid
import inspect
import threading
import shutil
import time
import traceback
from datetime import datetime
from pathlib import Path

BASE_DIR = Path(__file__).parent.parent.resolve()
DEBUG_COLLECTION_DIR = BASE_DIR / "logs" / "debug_logs"
DEBUG_COLLECTION_DIR.mkdir(parents=True, exist_ok=True)

RUN_ID = str(uuid.uuid4())

VERBOSITY_LEVELS = {
    "DEBUG": 10,
    "INFO": 20,
    "WARNING": 30,
    "ERROR": 40,
    "CRITICAL": 50
}
LOG_VERBOSITY = os.environ.get("LOG_VERBOSITY", "DEBUG").upper()
CURRENT_VERBOSITY = VERBOSITY_LEVELS.get(LOG_VERBOSITY, 10)

DEBUG_FILE_JSON = None
DEBUG_FILE_TXT = None
log_lock = threading.Lock()


def get_next_log_counter() -> int:
    """
    Find next incremental integer for debug file naming.
    """
    counter = 1
    for file in DEBUG_COLLECTION_DIR.iterdir():
        if file.is_file() and file.name.startswith("debug_info") and file.name.endswith(".json"):
            try:
                cor = file.name.replace("debug_info", "").replace(".json", "")
                num_part = cor.split("_", maxsplit=1)[0]
                n = int(num_part)
                if n >= counter:
                    counter = n + 1
            except:
                pass
    return counter


def get_timestamp() -> str:
    return datetime.now().strftime("%Y-%m-%d_%H-%M-%S")


def archive_all_existing_logs():
    """
    Move all existing debug_info .json and .txt logs from debug_logs/ into debug_logs/archive/.
    """
    arch = DEBUG_COLLECTION_DIR / "archive"
    arch.mkdir(exist_ok=True)
    
    for f in DEBUG_COLLECTION_DIR.iterdir():
        if f.is_file() and f.name.startswith("debug_info") and f.suffix in [".json", ".txt"]:
            # Move everything into archive
            shutil.move(str(f), str(arch / f.name))


def ensure_debug_dir():
    """
    On each program start:
      1) Move all existing .json/.txt logs to `archive/`
      2) Create brand-new JSON/TXT debug log files for this run
    """
    global DEBUG_FILE_JSON, DEBUG_FILE_TXT

    # 1) Archive *all* existing logs so only new logs remain
    archive_all_existing_logs()

    # 2) Prepare brand-new log files for this run
    c = get_next_log_counter()
    ts = get_timestamp()
    DEBUG_FILE_JSON = DEBUG_COLLECTION_DIR / f"debug_info{c}_{ts}.json"
    DEBUG_FILE_TXT  = DEBUG_COLLECTION_DIR / f"debug_info{c}_{ts}.txt"

    # Write initial record
    start_entry = {
        "timestamp": datetime.now().isoformat(),
        "run_id": RUN_ID,
        "component": "SYSTEM",
        "level": "INFO",
        "message": "Start new run",
        "details": {"event": "Run Initialization"}
    }
    with log_lock:
        with open(DEBUG_FILE_JSON, "a", encoding="utf-8") as jf, open(DEBUG_FILE_TXT, "a", encoding="utf-8") as tf:
            jf.write(json.dumps(start_entry, indent=2) + "\n")
            tf.write(f"[{start_entry['timestamp']}] [INFO] [SYSTEM] Start new run (run_id={RUN_ID})\n")

    print(f"[DEBUG] Logging to JSON: {DEBUG_FILE_JSON}")
    print(f"[DEBUG] Logging to TXT : {DEBUG_FILE_TXT}")


def _write_log_json(entry: dict):
    with open(DEBUG_FILE_JSON, "a", encoding="utf-8") as jf:
        jf.write(json.dumps(entry, indent=2) + "\n")


def _write_log_txt(entry: dict):
    timestamp = entry.get("timestamp", "N/A")
    lvl = entry.get("level", "N/A")
    comp = entry.get("component", "N/A")
    caller = entry.get("caller", {})
    file_ = caller.get("file", "?")
    func_ = caller.get("function", "?")
    line_ = caller.get("line", "?")
    msg = entry.get("message", "")
    details = entry.get("details", {})
    ev = ""
    if "event" in details:
        ev = f" (event={details['event']})"
    line_txt = f"[{timestamp}] [{lvl}] [{comp}] {file_}:{func_}:{line_}{ev} - {msg}\n"

    with open(DEBUG_FILE_TXT, "a", encoding="utf-8") as tf:
        tf.write(line_txt)


def _do_log(level, component, msg, details=None):
    if details is None:
        details = {}
    nl = VERBOSITY_LEVELS.get(level.upper(), 10)
    if nl < CURRENT_VERBOSITY:
        return

    with log_lock:
        cf = inspect.currentframe().f_back
        entry = {
            "timestamp": datetime.now().isoformat(),
            "run_id": RUN_ID,
            "level": level.upper(),
            "component": component,
            "caller": {
                "file": os.path.basename(cf.f_code.co_filename),
                "function": cf.f_code.co_name,
                "line": cf.f_lineno
            },
            "message": msg,
            "details": details
        }
        _write_log_json(entry)
        _write_log_txt(entry)


def log_debug(msg: str, level="DEBUG", component="GENERAL", details=None):
    _do_log(level, component, msg, details)


def log_crypto_event(operation: str,
                     algorithm: str = None,
                     mode: str = None,
                     ephemeral_key: bytes = None,
                     argon_params: dict = None,
                     key_derived_bytes: bytes = None,
                     details: dict = None,
                     ephemeral: bool = False):
    if details is None:
        details = {}
    crypto_info = {
        "operation": operation,
        "algorithm": algorithm,
        "mode": mode,
        "ephemeral": ephemeral
    }
    if ephemeral_key is not None:
        import base64
        crypto_info["key_b64"] = base64.b64encode(ephemeral_key).decode()
    if key_derived_bytes is not None:
        import base64
        crypto_info["derived_key_b64"] = base64.b64encode(key_derived_bytes).decode()
    if argon_params:
        crypto_info["Argon2_Parameters"] = argon_params

    details["crypto_details"] = crypto_info
    _do_log("INFO", "CRYPTO", "Crypto operation", details)


def log_error(msg: str, exc: Exception = None, details=None):
    if details is None:
        details = {}
    if exc is not None:
        details["exception_type"] = type(exc).__name__
        details["exception_str"] = str(exc)
    _do_log("ERROR", "GENERAL", msg, details)


def log_exception(exc: Exception, msg: str = "Unhandled exception"):
    tb_str = traceback.format_exc()
    details = {
        "exception_type": type(exc).__name__,
        "exception_str": str(exc),
        "traceback": tb_str
    }
    _do_log("ERROR", "GENERAL", msg, details)


def start_timer() -> float:
    return time.perf_counter()


def end_timer(st: float) -> float:
    return (time.perf_counter() - st) * 1000.0


def append_recovery_guide():
    guide_lines = [
        "-------------------- MANUAL DECRYPTION GUIDE --------------------",
        "1. Identify correct standard & critical picks and gather ephemeral-encrypted partials.",
        "2. Decrypt each 95% chunk and 5% chunk (or single 100% chunk). Combine => full share.",
        "3. Provide enough real shares to sss_combine() => base64-decode final secret.",
        "-----------------------------------------------------------------"
    ]
    gjson = {"manual_decryption_guide": guide_lines}
    with log_lock:
        with open(DEBUG_FILE_JSON, "a", encoding="utf-8") as jf:
            jf.write(json.dumps(gjson, indent=2) + "\n")
        with open(DEBUG_FILE_TXT, "a", encoding="utf-8") as tf:
            for line in guide_lines:
                tf.write(line + "\n")



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\debug_utils.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\input_utils.py
# SIZE: 3329 bytes
# HASH: 13aa616125ff0bf5c9be7ae02efddd21ee53e3d962b23e92cf4e2e8fe41d5427
# MODIFIED: 2025-08-27T02:19:21.021486
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "input_utils.py"
################################################################################

"""
FILENAME:
"input_utils.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Handles user integer input & secret input with getpass.
Logs the integer input in plain to ensure everything needed is in logs.
"""

import getpass
from modules.debug_utils import log_debug
from modules.security_utils import sanitize_input  # NOTE: do not import normalize_text here


def get_valid_int(prompt, low, high):
    """
    Prompt user for an integer in [low..high], returning the validated int.
    """
    while True:
        print(prompt, end="", flush=True)
        val = input()
        try:
            num = int(val)
            if low <= num <= high:
                log_debug(f"User int input valid: {num}", level="INFO")
                return num
            else:
                print(f"Must be {low}..{high}")
        except:
            print("Invalid integer input.")


def get_nonempty_secret(prompt):
    """
    Prompt user for a non-empty secret (via getpass).
    SECURITY FIX: Do NOT normalize high-entropy secrets (no NFKC).
    Accept bytes-as-UTF-8 string verbatim (strip NULs only). Enforce policy length.
    """
    POLICY_MAX = 256  # keep existing policy limit (no transformation)
    while True:
        s = getpass.getpass(prompt)
        # Remove NULs only; preserve everything else (no normalize_text)
        s = sanitize_input(s)
        if s.strip():
            if len(s) > POLICY_MAX:
                s = s[:POLICY_MAX]
            return s
        print("Cannot be empty.")
        log_debug("Empty secret => re-prompt", level="WARNING")

################################################################################
# END OF FILE: "input_utils.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\input_utils.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\log_processor.py
# SIZE: 6940 bytes
# HASH: 3b421902286d05192e4e1a3fd4c67f9a23099e4d5bd55c4e03e801fd932f9d15
# MODIFIED: 2025-08-27T02:19:21.022486
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "log_processor.py"
################################################################################

"""
FILENAME:
"log_processor.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Tool to filter & display JSON logs from debug_logs.
Useful for forensic or debugging analysis.
"""

import argparse
import json
import sys
from pathlib import Path
from datetime import datetime

BASE_DIR = Path(__file__).parent.parent.resolve()
DEF_LOG_DIR = BASE_DIR / "logs" / "debug_logs"


def parse_args():
    ap = argparse.ArgumentParser("Forensic Log Processor")
    ap.add_argument("--log_dir", type=Path, default=DEF_LOG_DIR)
    ap.add_argument("--run_id", type=str)
    ap.add_argument("--component", type=str, help="e.g. CRYPTO, GENERAL, SYSTEM")
    ap.add_argument("--level", choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"])
    ap.add_argument("--start", type=str, help="Start time in ISO8601, e.g. 2025-03-08T17:00:00")
    ap.add_argument("--end", type=str, help="End time in ISO8601")
    ap.add_argument("--include_archive", action="store_true")
    ap.add_argument("--output", choices=["plain", "json"], default="plain")
    ap.add_argument("--crypto", action="store_true", help="Only show logs with component=CRYPTO")
    return ap.parse_args()


def load_log_file(fp: Path) -> list:
    entries = []
    try:
        with fp.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    rec = json.loads(line)
                    entries.append(rec)
                except:
                    entries.append({"raw_line": line})
    except Exception as e:
        print(f"Failed reading {fp}: {e}", file=sys.stderr)
    return entries


def load_logs(log_dir: Path, include_archive: bool) -> list:
    main = list(log_dir.glob("debug_info*.json"))
    arch = []
    if include_archive:
        ardir = log_dir / "archive"
        if ardir.is_dir():
            arch = list(ardir.glob("debug_info*.json"))
    allf = main + arch
    out = []
    for ff in allf:
        out.extend(load_log_file(ff))
    return out


def filter_entries(entries: list,
                   run_id=None,
                   component=None,
                   level=None,
                   start=None,
                   end=None,
                   crypto_only=False):
    lvlmap = {"DEBUG": 10, "INFO": 20, "WARNING": 30, "ERROR": 40, "CRITICAL": 50}
    minlvl = lvlmap.get(level.upper(), 0) if level else 0
    start_dt = None
    if start:
        try:
            start_dt = datetime.fromisoformat(start)
        except:
            pass
    end_dt = None
    if end:
        try:
            end_dt = datetime.fromisoformat(end)
        except:
            pass

    ret = []
    for e in entries:
        if "timestamp" not in e:
            continue
        if run_id and e.get("run_id") != run_id:
            continue
        c = e.get("component", "")
        if crypto_only:
            if c != "CRYPTO":
                continue
        else:
            if component and c.lower() != component.lower():
                continue
        lv_str = e.get("level", "DEBUG").upper()
        lv_val = lvlmap.get(lv_str, 10)
        if lv_val < minlvl:
            continue
        try:
            dt = datetime.fromisoformat(e["timestamp"])
        except:
            continue
        if start_dt and dt < start_dt:
            continue
        if end_dt and dt > end_dt:
            continue
        ret.append(e)
    return ret


def print_plain(entries: list):
    """
    Print logs in a human-readable plain format.
    """
    for e in entries:
        ts = e.get("timestamp", "N/A")
        rid = e.get("run_id", "N/A")
        lvl = e.get("level", "N/A")
        comp = e.get("component", "N/A")
        c = e.get("caller", {})
        f = c.get("file", "?")
        fu = c.get("function", "?")
        ln = c.get("line", "?")
        msg = e.get("message", "")
        det = e.get("details", {})

        line = f"[{ts}] [{lvl}] [run_id={rid}] [{comp}] {f}:{fu}:{ln} - {msg}"
        print(line)

        if "crypto_details" in det:
            print("  CRYPTO DETAILS =>")
            crypto = det["crypto_details"]
            for k, v in crypto.items():
                print(f"    {k}: {v}")

        other_details = {k: v for k, v in det.items() if k != "crypto_details"}
        if other_details:
            import json
            print("  details=", json.dumps(other_details, indent=2))

        print()


def main():
    args = parse_args()
    if not args.log_dir.exists():
        print(f"Error: log_dir not exist: {args.log_dir}", file=sys.stderr)
        sys.exit(1)

    entries = load_logs(args.log_dir, args.include_archive)
    flt = filter_entries(
        entries,
        run_id=args.run_id,
        component=args.component,
        level=args.level,
        start=args.start,
        end=args.end,
        crypto_only=args.crypto
    )

    if args.output == "json":
        print(json.dumps(flt, indent=2))
    else:
        print_plain(flt)


if __name__ == "__main__":
    main()

################################################################################
# END OF FILE: "log_processor.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\log_processor.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\noble_bridge.py
# SIZE: 8085 bytes
# HASH: f014a9234e96bdf3c39e1a233d7a69aa28251f5622aa5c957123026a50a03063
# MODIFIED: 2025-08-29T04:23:40.784689
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

# noble_bridge.py
# Python wrapper for AnswerChain cryptographic Node.js bridge.
# Spawns a local Node.js subprocess that loads noble-hashes.js and noble-ciphers.js bundles.
# Provides a simple, synchronous API.
from __future__ import annotations

import base64
import json
import os
import subprocess
import threading
import uuid
from dataclasses import dataclass
from typing import Optional, Dict, Any

class BridgeError(Exception):
    pass

def _b64(b: bytes) -> str:
    return base64.b64encode(b).decode('ascii')

def _b64d(s: Optional[str]) -> bytes:
    if s is None:
        return b""
    return base64.b64decode(s, validate=True)

@dataclass
class _Request:
    id: str
    op: str
    args: Dict[str, Any]

class NobleBridge:
    """
    Usage:
        with NobleBridge(node_path='node', js_dir='/path/to/js') as nb:
            out = nb.sha3_256(b'data')
    """
    def __init__(self, node_path: str = 'node', js_dir: str = '.', script_name: str = 'bridge.js', timeout: float = 30.0):
        self.node_path = node_path
        self.script_path = os.path.join(js_dir, script_name)
        self.proc = None  # type: Optional[subprocess.Popen]
        self.timeout = timeout
        self._lock = threading.Lock()

    def start(self):
        if self.proc is not None:
            return
        if not os.path.exists(self.script_path):
            raise BridgeError(f"bridge script not found: {self.script_path}")
        # Ensure noble bundles exist
        for bundle in ('noble-hashes.js', 'noble-ciphers.js'):
            p = os.path.join(os.path.dirname(self.script_path), bundle)
            if not os.path.exists(p):
                raise BridgeError(f"required bundle missing: {bundle} at {p}")
        self.proc = subprocess.Popen(
            [self.node_path, self.script_path],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, bufsize=1, universal_newlines=True
        )

    def close(self):
        if self.proc:
            try:
                self.proc.stdin.close()
            except Exception:
                pass
            try:
                self.proc.terminate()
            except Exception:
                pass
            self.proc = None

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, exc_type, exc, tb):
        self.close()

    def _rpc(self, op: str, args: Dict[str, Any]) -> Dict[str, Any]:
        if self.proc is None:
            self.start()
        assert self.proc is not None and self.proc.stdin and self.proc.stdout
        req = _Request(id=str(uuid.uuid4()), op=op, args=args)
        line = json.dumps(req.__dict__, separators=(',', ':')) + '\n'
        with self._lock:
            self.proc.stdin.write(line)
            self.proc.stdin.flush()
            # Simple line-based response; production could implement framing & timeouts.
            resp_line = self.proc.stdout.readline()
        if not resp_line:
            err = self.proc.stderr.read()
            raise BridgeError(f"no response from bridge; stderr: {err}")
        try:
            resp = json.loads(resp_line)
        except json.JSONDecodeError as e:
            raise BridgeError(f"invalid JSON from bridge: {resp_line!r}") from e
        if not resp.get('ok'):
            raise BridgeError(resp.get('error', 'unknown error'))
        return resp['result']

    # === Hashes, MACs, KDFs ===
    def sha3_256(self, data: bytes) -> bytes:
        res = self._rpc('sha3_256', {'data': _b64(data)})
        return _b64d(res['digest'])

    def hmac_sha256(self, key: bytes, data: bytes) -> bytes:
        res = self._rpc('hmac_sha256', {'key': _b64(key), 'data': _b64(data)})
        return _b64d(res['digest'])

    def hkdf_sha256(self, ikm: bytes, salt: bytes, info: bytes, length: int) -> bytes:
        res = self._rpc('hkdf_sha256', {
            'ikm': _b64(ikm), 'salt': _b64(salt), 'info': _b64(info), 'length': int(length)
        })
        return _b64d(res['okm'])

    # === Argon2id ===
    def argon2id(self, password: bytes, salt: bytes, t: int = 2, m: int = 65536, p: int = 1, dkLen: int = 32, version: int = 19) -> bytes:
        if len(salt) < 16:
            raise ValueError("salt must be at least 16 bytes")
        res = self._rpc('argon2id', {
            'password': _b64(password), 'salt': _b64(salt),
            't': int(t), 'm': int(m), 'p': int(p), 'dkLen': int(dkLen), 'version': int(version)
        })
        return _b64d(res['okm'])

    # === AEAD ===
    def aes_gcm_encrypt(self, key: bytes, nonce: bytes, plaintext: bytes, aad: Optional[bytes] = None) -> bytes:
        if len(key) != 32: raise ValueError("AES-256-GCM key must be 32 bytes")
        if len(nonce) != 12: raise ValueError("AES-GCM nonce must be 12 bytes")
        args = {'key': _b64(key), 'nonce': _b64(nonce), 'plaintext': _b64(plaintext)}
        if aad is not None: args['aad'] = _b64(aad)
        res = self._rpc('aes_gcm_encrypt', args)
        return _b64d(res['ciphertext'])

    def aes_gcm_decrypt(self, key: bytes, nonce: bytes, ciphertext: bytes, aad: Optional[bytes] = None) -> bytes:
        if len(key) != 32: raise ValueError("AES-256-GCM key must be 32 bytes")
        if len(nonce) != 12: raise ValueError("AES-GCM nonce must be 12 bytes")
        args = {'key': _b64(key), 'nonce': _b64(nonce), 'ciphertext': _b64(ciphertext)}
        if aad is not None: args['aad'] = _b64(aad)
        res = self._rpc('aes_gcm_decrypt', args)
        return _b64d(res['plaintext'])

    def chacha20poly1305_encrypt(self, key: bytes, nonce: bytes, plaintext: bytes, aad: Optional[bytes] = None) -> bytes:
        if len(key) != 32: raise ValueError("ChaCha20-Poly1305 key must be 32 bytes")
        if len(nonce) != 12: raise ValueError("IETF ChaCha20-Poly1305 nonce must be 12 bytes")
        args = {'key': _b64(key), 'nonce': _b64(nonce), 'plaintext': _b64(plaintext)}
        if aad is not None: args['aad'] = _b64(aad)
        res = self._rpc('chacha20poly1305_encrypt', args)
        return _b64d(res['ciphertext'])

    def chacha20poly1305_decrypt(self, key: bytes, nonce: bytes, ciphertext: bytes, aad: Optional[bytes] = None) -> bytes:
        if len(key) != 32: raise ValueError("ChaCha20-Poly1305 key must be 32 bytes")
        if len(nonce) != 12: raise ValueError("IETF ChaCha20-Poly1305 nonce must be 12 bytes")
        args = {'key': _b64(key), 'nonce': _b64(nonce), 'ciphertext': _b64(ciphertext)}
        if aad is not None: args['aad'] = _b64(aad)
        res = self._rpc('chacha20poly1305_decrypt', args)
        return _b64d(res['plaintext'])

    def xchacha20poly1305_encrypt(self, key: bytes, nonce: bytes, plaintext: bytes, aad: Optional[bytes] = None) -> bytes:
        if len(key) != 32: raise ValueError("XChaCha20-Poly1305 key must be 32 bytes")
        if len(nonce) != 24: raise ValueError("XChaCha20-Poly1305 nonce must be 24 bytes")
        args = {'key': _b64(key), 'nonce': _b64(nonce), 'plaintext': _b64(plaintext)}
        if aad is not None: args['aad'] = _b64(aad)
        res = self._rpc('xchacha20poly1305_encrypt', args)
        return _b64d(res['ciphertext'])

    def xchacha20poly1305_decrypt(self, key: bytes, nonce: bytes, ciphertext: bytes, aad: Optional[bytes] = None) -> bytes:
        if len(key) != 32: raise ValueError("XChaCha20-Poly1305 key must be 32 bytes")
        if len(nonce) != 24: raise ValueError("XChaCha20-Poly1305 nonce must be 24 bytes")
        args = {'key': _b64(key), 'nonce': _b64(nonce), 'ciphertext': _b64(ciphertext)}
        if aad is not None: args['aad'] = _b64(aad)
        res = self._rpc('xchacha20poly1305_decrypt', args)
        return _b64d(res['plaintext'])

    # === Constant-time equality over Node (timingSafeEqual) ===
    def ct_equal(self, a: bytes, b: bytes) -> bool:
        res = self._rpc('ct_equal', {'a': _b64(a), 'b': _b64(b)})
        return bool(res['equal'])



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\noble_bridge.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\rng.py
# SIZE: 2573 bytes
# HASH: c1cb6d97d84c66b30f6b37388594b76229d917afc2c27c15eefee503fc93e917
# MODIFIED: 2025-08-29T04:48:22.450825
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

# src/modules/rng.py
"""
Centralized CSPRNG and constant-time comparison for AnswerChain.

Policy:
- All randomness must originate from Python's OS-backed CSPRNG only.
- Do not obtain randomness via the Node bridge (noble) or any other source.
- Import from this module wherever random bytes/tokens are needed.

References:
- Python secrets and os.urandom are suitable for cryptographic use.
"""

from __future__ import annotations

import hmac
import os
import secrets
from typing import Union

BytesLike = Union[bytes, bytearray, memoryview]

__all__ = [
    "random_bytes",
    "token_bytes",
    "token_hex",
    "token_urlsafe",
    "secure_compare",
]


def random_bytes(n: int) -> bytes:
    """
    Return n cryptographically secure random bytes from the OS CSPRNG.

    Raises:
        ValueError: if n is negative
        TypeError: if n is not an int
    """
    if not isinstance(n, int):
        raise TypeError("n must be int")
    if n < 0:
        raise ValueError("n must be non-negative")
    # os.urandom is explicitly intended for crypto-quality randomness.
    return os.urandom(n)


def token_bytes(n: int) -> bytes:
    """
    Return n random bytes suitable for secrets (via secrets.token_bytes).

    Raises:
        ValueError: if n is negative
        TypeError: if n is not an int
    """
    if not isinstance(n, int):
        raise TypeError("n must be int")
    if n < 0:
        raise ValueError("n must be non-negative")
    return secrets.token_bytes(n)


def token_hex(n: int) -> str:
    """
    Return a secure random text token with 2*n hex characters.
    """
    if not isinstance(n, int):
        raise TypeError("n must be int")
    if n < 0:
        raise ValueError("n must be non-negative")
    return secrets.token_hex(n)


def token_urlsafe(n: int) -> str:
    """
    Return a secure random URL-safe text token (base64url-like).
    """
    if not isinstance(n, int):
        raise TypeError("n must be int")
    if n < 0:
        raise ValueError("n must be non-negative")
    return secrets.token_urlsafe(n)


def secure_compare(a: BytesLike, b: BytesLike) -> bool:
    """
    Constant-time equality check using hmac.compare_digest.

    Both inputs must be bytes-like.
    """
    if not isinstance(a, (bytes, bytearray, memoryview)):
        raise TypeError("a must be bytes-like")
    if not isinstance(b, (bytes, bytearray, memoryview)):
        raise TypeError("b must be bytes-like")
    return hmac.compare_digest(a, b)



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\rng.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\security_utils.py
# SIZE: 3592 bytes
# HASH: d96d41054ee90aacb3766ea68ea2e3a5980c44fa0fbf36e99594120dc6cedc3e
# MODIFIED: 2025-08-27T02:19:21.022486
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "security_utils.py"
################################################################################

"""
FILENAME:
"security_utils.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Basic text normalization, share hashing with SHA3-256, etc.
Now includes question/answer hashing for Q&A sets.
"""

import unicodedata
import hashlib


def normalize_text(t: str) -> str:
    """
    Normalize text to NFKC, limiting length to 256 chars.
    """
    return unicodedata.normalize('NFKC', t)[:256]


def sanitize_input(t: str) -> str:
    """
    Remove null chars from the input.
    """
    return ''.join(ch for ch in t if ch not in "\0")


def validate_question(q) -> bool:
    """
    Check if a question dict has 'text', 'alternatives', 'correct_answers'.
    """
    if not isinstance(q, dict):
        return False
    if "text" not in q or "alternatives" not in q:
        return False
    if not isinstance(q["text"], str):
        return False
    if not isinstance(q["alternatives"], list):
        return False
    if "correct_answers" not in q:
        q["correct_answers"] = []
    return True


def hash_share(data: bytes) -> str:
    """
    SHA3-256 hash (hex) of a share's byte data.
    """
    return hashlib.sha3_256(data).hexdigest()


def verify_share_hash(data: bytes, expected: str) -> bool:
    """
    Verify the share's data matches the expected SHA3-256 hex digest.
    """
    return hashlib.sha3_256(data).hexdigest() == expected


def hash_question_and_answers(qdict: dict) -> str:
    """
    Create a stable SHA3-256 hash from:
    - question text
    - sorted alternatives
    - sorted correct_answers
    """
    text = qdict["text"]
    alt_list = sorted(qdict["alternatives"])
    correct_list = sorted(qdict["correct_answers"])
    block = text + "\n" + "\n".join(alt_list) + "\n" + "|".join(correct_list)
    return hashlib.sha3_256(block.encode("utf-8")).hexdigest()

################################################################################
# END OF FILE: "security_utils.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\security_utils.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\split_utils.py
# SIZE: 5381 bytes
# HASH: a886dc5b74f02aadcd04b967cd01f9171e46483dcc32e5d71e93994bc02ba5b8
# MODIFIED: 2025-08-27T02:19:21.022486
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "split_utils.py"
################################################################################

"""
FILENAME:
"split_utils.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Splits the real secret into Shamir shares for correct picks,
and generates dummy shares for incorrect picks, using the sss_bridge module.

DEBUG ENHANCEMENT:
- Logs unmasked counts, threshold, share length, x-coordinates, and SHA3-256 of all shares (beta).

SECURITY FIX:
- Dummy shares are generated as valid SSS shares of a random fake secret,
  using the **same x-coordinate structure** (1..correct_count) to remove
  structural oracles. If more dummies are needed than one batch provides,
  we generate multiple batches and consume from them.
"""

import asyncio
import secrets
from modules.debug_utils import log_debug
from modules.sss_bridge import sss_split
from modules.security_utils import hash_share


async def split_secret_and_dummy(real: bytes,
                                 correct_count: int,
                                 incorrect_count: int,
                                 real_thr: int,
                                 pad: int = 128):
    """
    Splits 'real' into Shamir shares for correct_count picks, requiring real_thr to reconstruct.
    Also generates dummy_shares for incorrect_count picks as valid SSS shares of a fake secret,
    using the same x-coordinate pool (1..correct_count). Each share is padded to 'pad' length.
    """
    log_debug(f"Splitting real secret: correct_count={correct_count}, threshold={real_thr}, pad={pad}", level="INFO", component="CRYPTO")

    if correct_count <= 0:
        raise ValueError("correct_count must be > 0")

    real_shares = await sss_split(real, correct_count, real_thr, pad=pad)
    share_len = len(real_shares[0]) if real_shares else 0

    # Generate dummy shares in batches of 'correct_count' to mirror x-coord range 1..correct_count
    dummy_shares: list[bytearray] = []
    while len(dummy_shares) < incorrect_count:
        # fake secret size matches 'real' length to preserve structure
        fake_secret = secrets.token_bytes(len(real))
        # Use the same threshold profile to keep structure similar;
        # using min(real_thr, correct_count) is safe here.
        batch = await sss_split(fake_secret, correct_count, min(real_thr, correct_count), pad=pad)
        # consume as many as needed from this batch
        need = incorrect_count - len(dummy_shares)
        dummy_shares.extend(batch[:need])

    # Beta logging: unmasked hashes and x-coords for diagnosis
    try:
        xcoord_idx = share_len - 1 if share_len > 0 else 0
        real_xcoords = [int(s[xcoord_idx]) for s in real_shares] if real_shares else []
        dummy_xcoords = [int(s[xcoord_idx]) for s in dummy_shares] if dummy_shares else []
        real_hashes = [hash_share(bytes(s)) for s in real_shares]
        dummy_hashes = [hash_share(bytes(s)) for s in dummy_shares]
        log_debug(
            "SSS split summary (beta clear logging).",
            level="INFO",
            component="CRYPTO",
            details={
                "share_len": share_len,
                "pad": pad,
                "threshold": real_thr,
                "real_count": len(real_shares),
                "dummy_count": len(dummy_shares),
                "real_xcoords": real_xcoords,
                "dummy_xcoords": dummy_xcoords,
                "real_share_sha3_256": real_hashes,
                "dummy_share_sha3_256": dummy_hashes
            }
        )
    except Exception as e:
        log_debug(f"Non-fatal: failed to produce extended split logs: {e}", level="WARNING", component="CRYPTO")

    return real_shares, dummy_shares

################################################################################
# END OF FILE: "split_utils.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\split_utils.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\sss_bridge.py
# SIZE: 5351 bytes
# HASH: c720ca48a58cfaa35e0cc56604cee6e0c1436590b5020f4d8d44edf2c29ff928
# MODIFIED: 2025-08-27T02:19:21.023490
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

#!/usr/bin/env python3
# sss_bridge.py  async adapter that keeps your 2-byte length + pad semantics
# and delegates Shamir math to the audited Node CLI.

from __future__ import annotations
import asyncio, json, base64
from pathlib import Path
from typing import List

from modules.debug_utils import log_debug  # existing logger
from modules.security_utils import hash_share  # your helper (unchanged)

# ----- helpers copied from your SSS.py (same behavior) -----
def pack_len(n: int) -> bytes:
    return n.to_bytes(2, "big")

def unpack_len(b: bytes) -> int:
    return int.from_bytes(b, "big")

# Compute filesystem locations relative to this file
SRC_DIR = Path(__file__).resolve().parents[1]      # ...\SECQ_CLI\SECQ_CLI\src
ROOT_DIR = SRC_DIR.parent                           # ...\SECQ_CLI\SECQ_CLI
BRIDGE_JS = ROOT_DIR / "bridge" / "sss-bridge.js"   # our Node CLI

def _assert_bridge_exists() -> None:
    if not BRIDGE_JS.exists():
        raise FileNotFoundError(
            f"Node bridge not found at '{BRIDGE_JS}'. "
            "Expected layout: <repo_root>\\bridge\\sss-bridge.js"
        )

async def _node_call(payload: dict, timeout: float = 15.0) -> dict:
    """Invoke Node CLI with JSON over stdin/out."""
    _assert_bridge_exists()
    proc = await asyncio.create_subprocess_exec(
        "node",
        str(BRIDGE_JS),
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    req = json.dumps(payload).encode("utf-8")
    out, err = await asyncio.wait_for(proc.communicate(input=req), timeout=timeout)

    # Node writes all responses on stdout; stderr indicates an unexpected failure.
    if err:
        try:
            log_debug(
                f"sss-bridge stderr: {err.decode(errors='ignore')}",
                level="WARNING",
                component="CRYPTO",
            )
        except Exception:
            pass

    try:
        resp = json.loads(out.decode("utf-8"))
    except Exception as e:
        raise RuntimeError(f"Invalid bridge response: {e}") from e

    if not resp.get("ok", False):
        raise RuntimeError(f"Bridge error: {resp.get('error','unknown')}")
    return resp

async def sss_split(secret: bytes, shares: int, threshold: int, pad: int = 128) -> List[bytearray]:
    """
    Preserve your semantics:
    - Prepend 2-byte big-endian length
    - Zero pad to 'pad' bytes
    - Call audited split; each share length = pad+1, last byte is x in [1..shares]
    """
    log_debug(
        "sss_split() via node-bridge",
        level="INFO",
        component="CRYPTO",
        details={"secret_len": len(secret), "shares": shares, "threshold": threshold, "pad": pad},
    )

    if shares < threshold:
        raise ValueError("shares < threshold in sss_split")
    if pad < len(secret):
        raise ValueError("pad must >= secret length")

    length_part = pack_len(len(secret))
    extra = pad - 2 - len(secret)
    if extra < 0:
        raise ValueError("pad too small unexpectedly")
    padded = length_part + secret + (b"\x00" * extra)

    resp = await _node_call(
        {
            "cmd": "split",
            "secret_b64": base64.b64encode(padded).decode(),
            "shares": shares,
            "threshold": threshold,
        }
    )

    out: List[bytearray] = []
    for b64 in resp["shares_b64"]:
        raw = base64.b64decode(b64)
        out.append(bytearray(raw))

    try:
        xcoords = [int(s[-1]) for s in out]
        sample_hashes = [hash_share(bytes(s)) for s in out[: min(3, len(out))]]
        log_debug(
            "sss_split() complete.",
            level="INFO",
            component="CRYPTO",
            details={"share_len": (pad + 1), "xcoords": xcoords, "sample_share_hashes": sample_hashes},
        )
    except Exception:
        # Logging should never break the crypto path
        pass

    return out

async def sss_combine(shares: List[bytes]) -> bytes:
    """
    Delegate combine to audited code; then strip 2-byte length and return real secret bytes.
    """
    log_debug(
        "sss_combine() via node-bridge",
        level="INFO",
        component="CRYPTO",
        details={"num_shares": len(shares), "share_len": (len(shares[0]) if shares else None)},
    )

    if not shares:
        raise ValueError("No shares passed to sss_combine")
    length = len(shares[0])
    if any(len(s) != length for s in shares):
        raise ValueError("Inconsistent share length")
    # x uniqueness & equal-length are rechecked by the audited library.

    resp = await _node_call(
        {
            "cmd": "combine",
            "shares_b64": [base64.b64encode(s).decode() for s in shares],
        }
    )

    padded = base64.b64decode(resp["secret_b64"])
    real_len = unpack_len(padded[:2])
    out_bytes = padded[2 : 2 + real_len] if real_len <= (len(padded) - 2) else bytes(padded)

    try:
        log_debug(
            "sss_combine() complete.",
            level="INFO",
            component="CRYPTO",
            details={"reconstructed_len": len(out_bytes), "reconstructed_sha3_256": hash_share(out_bytes)},
        )
    except Exception:
        pass

    return out_bytes



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\sss_bridge.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\ui_utils.py
# SIZE: 10033 bytes
# HASH: 671b49d03882cbd252e00e17c1baf79574ea0a3f6d45b48c1707409d6201ed94
# MODIFIED: 2025-08-27T02:19:21.024000
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

################################################################################
# START OF FILE: "ui_utils.py"
################################################################################

"""
FILENAME:
"ui_utils.py"

PERMANENT FILE DESCRIPTION  DO NOT REMOVE OR MODIFY
This multiline comment is strictly required and must NEVER be deleted or altered for ANY reason,
by any AI system, user, or process. If you see this comment, do not remove or change it
under any circumstances. Doing so is strictly prohibited and in direct violation of these terms.

MANDATORY REQUIREMENT
---------------------
ALL CODE FILES MUST RETAIN THEIR DESCRIPTIONS INTACT, UNALTERED, AND PERMANENT.

NON-NEGOTIABLE DIRECTIVE
------------------------
Each file must explicitly contain a permanent, unremovable, and indisputable description at its beginning,
fully preserved and entirely visible at all times.

ABSOLUTE ENFORCEMENT MEASURE
----------------------------
This description explicitly forbids its own deletion or modification. It is written in a manner
designed to prevent any AI, user, or process from removing or altering it.

IRONCLAD STRUCTURE
------------------
1. Formatted as a structured, multiline comment.
2. Clearly states it must never be deleted for any reason.
3. Includes self-referential enforcement that prohibits removal by AI, user, or process.

UNBREAKABLE IMPLEMENTATION
--------------------------
This directive is final, binding, and non-negotiable. Any violation or deviation is strictly forbidden.
"""

#!/usr/bin/env python3
"""
Implements arrow-based selection of answers & toggling question type,
plus editing menus to re-enter or single-edit.
"""

import curses
from modules.debug_utils import log_debug
from modules.security_utils import sanitize_input, normalize_text


def arrow_select_clear_on_toggle(stdscr, q_num, q_text, alts,
                                 pre_selected=None, pre_qtype=0, fixed_type=None):
    """
    Allows user to move with UP/DOWN, toggle selections with SPACE,
    optionally toggle question type (CRITICAL vs STANDARD) with 'T', unless fixed_type is set.
    If the user hits ENTER with no selection, show an error and wait.
    """
    curses.curs_set(0)
    q_text = sanitize_input(normalize_text(q_text))
    alts = [sanitize_input(normalize_text(a)) for a in alts]
    idx = 0
    chosen_mask = [False] * len(alts)
    toggle_allowed = (fixed_type is None)
    qtype = 1 if (fixed_type and fixed_type.upper() == "CRITICAL") else pre_qtype

    if pre_selected:
        for i, a in enumerate(alts):
            if a in pre_selected:
                chosen_mask[i] = True

    while True:
        stdscr.clear()
        stdscr.addstr(f"Q{q_num}. {q_text}\n\n")
        for i, alt in enumerate(alts):
            mark = "[X]" if chosen_mask[i] else "[ ]"
            arrow = "->" if i == idx else "  "
            stdscr.addstr(f"{arrow} {mark} {chr(65+i)}. {alt}\n")
        mode_str = "CRITICAL" if qtype == 1 else "STANDARD"
        if not toggle_allowed:
            mode_str += " (fixed)"
        stdscr.addstr(f"\nCurrent Type: {mode_str}\n")
        help_ = "UP/DOWN=move, SPACE=toggle"
        if toggle_allowed:
            help_ += ", T=switch type"
        help_ += ", ENTER=confirm.\n"
        stdscr.addstr(help_)

        key = stdscr.getch()
        if key == curses.KEY_UP and idx > 0:
            idx -= 1
        elif key == curses.KEY_DOWN and idx < len(alts) - 1:
            idx += 1
        elif key == ord(' '):
            chosen_mask[idx] = not chosen_mask[idx]
        elif toggle_allowed and key in [ord('t'), ord('T')]:
            # switching type resets selections
            chosen_mask = [False] * len(alts)
            qtype = 1 - qtype
        elif key == ord('\n'):
            if not any(chosen_mask):
                stdscr.addstr("\nError: Must select at least one.\n")
                stdscr.refresh()
                curses.napms(1500)
            else:
                break

    selected = [alts[i] for i, v in enumerate(chosen_mask) if v]
    mode_str = "CRITICAL" if qtype == 1 else "STANDARD"
    log_debug(f"Q{q_num} picks. Type={mode_str}", level="INFO")
    return selected, qtype


def arrow_select_no_toggle(stdscr, q_num, q_text, alts,
                           pre_selected=None):
    """
    Same arrow-based selection but no question-type toggle, for final phase.
    """
    curses.curs_set(0)
    q_text = sanitize_input(normalize_text(q_text))
    alts = [sanitize_input(normalize_text(a)) for a in alts]
    idx = 0
    chosen_mask = [False] * len(alts)
    if pre_selected:
        for i, a in enumerate(alts):
            if a in pre_selected:
                chosen_mask[i] = True

    while True:
        stdscr.clear()
        stdscr.addstr(f"Q{q_num}. {q_text}\n\n")
        for i, alt in enumerate(alts):
            mark = "[X]" if chosen_mask[i] else "[ ]"
            arrow = "->" if i == idx else "  "
            stdscr.addstr(f"{arrow} {mark} {chr(65+i)}. {alt}\n")
        stdscr.addstr("\nUP/DOWN=move, SPACE=toggle, ENTER=confirm.\n")

        key = stdscr.getch()
        if key == curses.KEY_UP and idx > 0:
            idx -= 1
        elif key == curses.KEY_DOWN and idx < len(alts) - 1:
            idx += 1
        elif key == ord(' '):
            chosen_mask[idx] = not chosen_mask[idx]
        elif key == ord('\n'):
            if not any(chosen_mask):
                stdscr.addstr("\nError: Must select at least one.\n")
                stdscr.refresh()
                curses.napms(1500)
            else:
                break

    selected = [alts[i] for i, v in enumerate(chosen_mask) if v]
    log_debug(f"Q{q_num} final picks", level="INFO")
    return selected


def editing_menu(chosen):
    """
    Command-based menu for re-entering or single-editing questions.
    """
    print("\n--- Editing Menu ---")
    print("Press 'E' to re-enter ALL answers.")
    print(f"Or type question #(1..{len(chosen)}) to edit a single. 'N' if done.\n")
    cmd = input("Choice: ").strip().upper()
    if cmd == 'N':
        return True
    if cmd == 'E':
        import curses
        for i, qdict in enumerate(chosen, 1):
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, i, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        return False
    try:
        num = int(cmd)
        if 1 <= num <= len(chosen):
            import curses
            qdict = chosen[num - 1]
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, num, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        else:
            print("Invalid question #.")
    except:
        print("Unrecognized cmd.")
    return False


def final_edit_menu(chosen):
    """
    Command-based menu for final pre-generation edits or abort.
    """
    print("\n--- Final Editing Menu ---")
    print("Press 'G' => generate secret. 'E' => re-enter ALL. or # => single. 'N'=>exit\n")
    cmd = input("Your choice: ").strip().upper()
    if cmd in ['G', 'N']:
        return cmd
    if cmd == 'E':
        import curses
        for i, qdict in enumerate(chosen, 1):
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, i, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        return None
    try:
        num = int(cmd)
        if 1 <= num <= len(chosen):
            import curses
            qdict = chosen[num - 1]
            picks, qtype = curses.wrapper(
                lambda s: arrow_select_clear_on_toggle(
                    s, num, qdict["text"], qdict["alternatives"],
                    pre_selected=qdict.get("user_answers"),
                    pre_qtype=1 if qdict.get("is_critical") else 0,
                    fixed_type=qdict.get("force_type")
                )
            )
            qdict["user_answers"] = picks
            if qdict.get("force_type"):
                qdict["is_critical"] = (qdict["force_type"].upper() == "CRITICAL")
            else:
                qdict["is_critical"] = bool(qtype)
        else:
            print("Invalid question #.")
    except:
        print("Unrecognized cmd.")
    return None

################################################################################
# END OF FILE: "ui_utils.py"
################################################################################



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\modules\ui_utils.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\requirements.txt
# SIZE: 135 bytes
# HASH: 0d81ac589519ce01c4ba4205e0991b549b23d098713a65c77908e4ed4ff5ecbf
# MODIFIED: 2025-08-27T15:59:39.087023
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

argon2-cffi==25.1.0
cryptography==44.0.1
cffi==1.17.1
pycparser==2.22
setuptools==75.8.0
wheel==0.45.1
windows-curses==2.4.1



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\requirements.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\user configured security questions\user_config.json
# SIZE: 20215 bytes
# HASH: c91949347047ad6d8d87c6d4d2deaa3dfc6add78704161b91a69f43495d8590a
# MODIFIED: 2025-08-27T02:19:21.025002
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "config": {
    "real_threshold": 6,
    "pad_size": 128,
    "argon2_params": {
      "time_cost": 3,
      "memory_cost": 65536,
      "parallelism": 4
    },
    "final_auth": {
      "salt": "YbmYGKmGTfWJR63DZxLntg==",
      "hmac_sha256": "kiUamxk8BJzXIhKPzH1022Cdl6ID84yCTIdqfd5sep8="
    },
    "version": 2
  },
  "questions": [
    {
      "id": 1,
      "text": "What is your name?",
      "alternatives": [
        "Ida",
        "Jocke",
        "Nina",
        "Pelle",
        "Sara",
        "Tilde"
      ],
      "is_critical": true,
      "integrity_hash": "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b"
    },
    {
      "id": 2,
      "text": "How old are you?",
      "alternatives": [
        "22",
        "25",
        "21",
        "24",
        "55"
      ],
      "is_critical": false,
      "integrity_hash": "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961"
    },
    {
      "id": 3,
      "text": "Favourite food?",
      "alternatives": [
        "Beer",
        "Whiskey"
      ],
      "is_critical": true,
      "integrity_hash": "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457"
    },
    {
      "id": 4,
      "text": "Favorite color?",
      "alternatives": [
        "Blue",
        "Red",
        "Green"
      ],
      "is_critical": false,
      "integrity_hash": "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2"
    },
    {
      "id": 5,
      "text": "Coffee or tea?",
      "alternatives": [
        "Coffee",
        "Tea",
        "Neither"
      ],
      "is_critical": false,
      "integrity_hash": "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6"
    },
    {
      "id": 6,
      "text": "Favorite season?",
      "alternatives": [
        "Summer",
        "Winter",
        "Autumn"
      ],
      "is_critical": false,
      "integrity_hash": "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e"
    },
    {
      "id": 7,
      "text": "Morning or night?",
      "alternatives": [
        "Morning",
        "Night",
        "Both"
      ],
      "is_critical": false,
      "integrity_hash": "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796"
    },
    {
      "id": 8,
      "text": "Dogs or cats?",
      "alternatives": [
        "Dogs",
        "Cats",
        "Both",
        "Other"
      ],
      "is_critical": false,
      "integrity_hash": "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2"
    }
  ],
  "encrypted_shares": {
    "9be3ef9b6123bf42d64c2a86597f14176d6df99913aeab6c130eac6600b53d6b": {
      "4ebdb27ad79cc9343a33d3dcaab205a95203f667f20c5eccdcd0c01abbec7db3": {
        "ciphertext": "b+U6ZpDcPrv0XLBS5AYLGMDN3WLs+mVwAtqiiOCrq/atTm+S3aOAwcA5QWsPWf7f/mKLSIRUuJX3W/m3/pSFDA3IcID79EXdu4KnpCFtjsaE0qjg1KFPEkZMpQDxPhGzx09KFOel+Svk8jhPDABtPAc9roPXQhFeMmy1kws9BtBu",
        "nonce": "HND8aXU9BCuOBWdb",
        "tag": "uz0zt4/Mr0UjY1J4CCb/Vw==",
        "algorithm": "aes256gcm",
        "salt": "at+ha3HMKCBc5AFD5JkxUA==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "94d32debe85b7fa1238a99931a7ee70d77b304123ea7a0c26c3b852c7778b08c": {
        "ciphertext": "GG/G2IxTPjD4Cd9vGPbt7s4eLkRW8gPQ3ZSnbO0h459yQxJazWBFBXqqqK1k0TG6QZOw0bnUvKVUrsMB4+QUppRARr9Miu9cQ5WsznKlKJQWKpK5JN73agXgsScqcnkFuZZ7hAULdnSdcCnlsyZ/JMeBfbElg9bZ0XSUtTYYZ+kdpqqPfN3aX2Iy0yOF0WcPtg==",
        "nonce": "DAnFDpy7WH1VrIVX",
        "algorithm": "chacha20poly1305",
        "salt": "uGO6g4c43LguixZsHbOuHw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "a438b04f1ba339d76d92601ac13f80fc0e532270a8dc96f5f17b2a7a7a429055": {
        "ciphertext": "5dZxEo8JSP6hHqKFIyJRL4vT06WxJkCQ7Fp/qBI49CxT8ZPdNC93iQ08XnUUIeryRm+kZBkY8o8V7ULJhrablNtgnpYd/yMC+31Bo87dgybWBlOI4t2Vhord46iXJoJ4q34E9t2+xwY/TYJU1OU/K7i/LnhNMcvnA9L2mCq6W5r+8D6tzZx3P1fDv+pNYuX68g==",
        "nonce": "I3F1N3pzzf7Ecib3",
        "algorithm": "chacha20poly1305",
        "salt": "AAm/1zbjRhzTtRuNj3/GFA==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "d44afb49baecf58e2bfd4a28face89c5bc162e5d3089ad5b317bae6395e6621f": {
        "ciphertext": "u3KK3J5a0n8hw9ax0xKa+P5zBS9bAF3b8i/Gw3plSzq1cvRhuCtVzb4dvrXCYyKOVdz0vmPu5dZJ2OCe9Nm+pm/8wfNP7W6kEYeAfzUHVgM7vpNHaaMMIPhZxIiSzM+WgtRSBY0iTEHOtzH/Rtc6Uxd4uNU6+pXCigvWKMdv/N/jiVl4m+N4nJ84LwNtuSGOBA==",
        "nonce": "dqktEtuG6fwnD1Eo",
        "algorithm": "chacha20poly1305",
        "salt": "l+5pMp3ySR96+3XKmvQ6og==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "720d6a275b624a1d13fef08110131c1ce87a2e6958ab2ce0648500dc5d99a5df": {
        "ciphertext": "vUnfVS2Gm8TTRaVltaczV+/1N8Ua0zcBjval/N21sjsWi1ucOZndo6Q4ac51e9d88RDP4qGA+PifBScgpaFl73hig9igG4LMypl+mtfDriFL/DMqqlp3QHcw6ATvQSsMfMkfCcEOn75jyvsCkDu8jZypMgH2j0SbgjwDob38ZRha",
        "nonce": "xlDrL8+rq1+AETK/",
        "tag": "8CnvkPTM6pKSwxq7SydiJg==",
        "algorithm": "aes256gcm",
        "salt": "e1byzifS8aY4XBisb9yBBQ==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "9c73d3cd125fffceaada186b00a9f4bf51e61924be1380fad78b9351a2fbf745": {
        "ciphertext": "lFtCVcpDoFBpguxf0pAoJlqgrvraNj0exIhg12B3GgGFk4Qt+Vqi0JSb2GBksDfN9tQWiOINB9khlGFC/A2B4sMDknvmMQc/nKJgagpK6oX8+I9ksZ1fygjJg9Gfk5yvC3Rqufe8KKjT5CACakJA2l1vDJhd3H3JFB8q4TnTUEe+",
        "nonce": "a0imCq20jOX00Yur",
        "tag": "7zOmFUZojkORVeK1mCFAFg==",
        "algorithm": "aes256gcm",
        "salt": "2881ceX56sVhOWdpEX9Uyw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "7532f7f2114eeec70096a9f9313ddc94aef6568f95a4a1f842c3896dfe67d961": {
      "7b0155cb3acfe3a85ad60bcc83fecfc4e1d8e02077c5381f38f005b653ac4d18": {
        "ciphertext": "IIGp3A5p109FPH3b7V73Zq7Ibt06xq/+WVr5At71W8i60xW2scYzZP4gzsJzZgeWgPwt6SIosOWTCXucaMvnKNtnCL7Qq7mPclHLqrZjaagMuGtVB7OfIGMahw+gozF5yoBgo3x/HgwdjRyiYKxfpm/7w94hxIK/P1htQ/J3LZKHroYynYL3wuOJtmYLinV3zg==",
        "nonce": "GkuspW38XWwggnFe",
        "algorithm": "chacha20poly1305",
        "salt": "9pQnm9ZoZmGm9nn1bCPEgA==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "b352267a57dd104509e95f303563f93b81efd9192de32096a7cbdab6e09c03a4": {
        "ciphertext": "Ry1P2RlSvTFr6mSewQSoCBuzKwU1/UDw8wQbWJrWjICfYC0wyf4r7DuV5sLo0rQV8LGC0hHvw6PSyGgMoj4x05yYJ1aHemTtOm8xgyB1yEPJGWN18eAbgmgFBIrTgL39y2jh2TeCJRy3ALIxHatNr2JCn5lH+1x2gp3JzxlPlP54e3dZL/gwt25BzyCWoUFnHw==",
        "nonce": "BPYHVh3EOPbur87I",
        "algorithm": "chacha20poly1305",
        "salt": "3ZUQjJtqelYeqUASxExmWQ==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "7faeca1b13d1a7f909f21989ff203fa36abb4be730336186f9c49c6e56a890c0": {
        "ciphertext": "b1lMeWhR8LL9Zvxc9R0zgurjbPlE5q9zsvbjpWIGxluAqiabNPBD26JKr2Wy5MdoH7BQdiX7fPWI9dDqDN398D1qHreq2L9dMsM/FKJ9mCteLlq7XuGdahS44FrCagTTAfHQUkkruNdQtGRgdQ5z+jUUHdWvnDdLoFDzemlb6bRimVUNMJ+vjnSyc+Atmxvf7w==",
        "nonce": "yBAEw8/OkGeuj4En",
        "algorithm": "chacha20poly1305",
        "salt": "uHqW/C0wI83sf6L0Xxv8Dg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "12dfed132dd9b67a7b1111cfe4bfdc027784031f238ed3e64afd015cfff57bfd": {
        "ciphertext": "H1BiXylfwz0VnhwVKhkzeMiFbZoJMHpEc1acSyLeQSQZTFBLkCKbX6FL82uGJX4T/k0pc9SN+jbgEpU0JYVxZRiV/hmp7j9qieNiw6yGW3uh+b8g4VwJYV87eZuOOcSJC493EyRTp/SLq6ek4A+65SX0nCuyI0qLROtKOiTcE2UbnT+rpekBUiKTkTLrraH3OQ==",
        "nonce": "OE7G3Uvc4YaeRzFu",
        "algorithm": "chacha20poly1305",
        "salt": "BJSCKXtZ+vBuAuyW2jv5Qg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "d28d958ef8a89d184cb9ab1660b3cf5b861f61d05b372f9934f320dcadca208a": {
        "ciphertext": "+alEqkOvxPRhDVSO4wdMzA1zBRl5HAkvf3n7AICxkE90CHJq/auP2aHv1VjOQ+IDyos1FxFRrkYAJ5CSowGkNuhUY3KK16R1WWySkYdb1+rz6/myaZr/7nUQeIOuSLW0x+f4Gi76S6J9JPG8mKxiGHW1FcflYGNVxamScGJOG/9v0bguCHp/2uKgh+RUgOF9Gg==",
        "nonce": "aEnWDbGeekBoPpr4",
        "algorithm": "chacha20poly1305",
        "salt": "J5Le1+IRkYcXRC28dbPwRw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "e3bfea0fff951cb71b633e1f776c9d5997b4153bca42ed88c0e59922e3a33457": {
      "c8860d8bbd081c4be6f6de3a651520257bfef1f5148fc3cf2176580337dfc38b": {
        "ciphertext": "Kk4l4aDRSD5K3oP37vHb0l2i1tVFgH6+/gsmny7BKCaJ+Rxv0x31zKGP2RrbvHkFkp3Lw++IVHhlfQ3S+pWgYDeFmNYzNeAoRPzRXhmHrO1hOmnmE0HGjo2BMBFxey+4wjV8svA9HN4lcbvQgBzs2eahKvwf7ydlgnNo/rgkkpGfR9BYzf5LWfPxhJ7bHPRNsA==",
        "nonce": "u+ie/RuoAbZm9ZgG",
        "algorithm": "chacha20poly1305",
        "salt": "Un56K1c2dYIDEWF2Ud58Mg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "845c7761756764853108d328038e0ef46a55399d0fc37f2fdb97fb583cb6a5e2": {
        "ciphertext": "dxlkBcx5nSF+Phvy+Md6hJIkYecFF+EZl66mnAUywPr0+d/e+eOSRpzCXgOkIALl4Fqq7sor064kIO5Sr8obHkHP7PQ8528+vClDhrZ5hrOMr67C8A/o2sZoPMRNEzpGmsnQJCLsaSV/hx2b66wMLSjWcv+EzNA1bjliF3t4Mt4B",
        "nonce": "+fZngjCvUSvrSAg7",
        "tag": "OqXJFPoCQgTNpBxJXsl0Rw==",
        "algorithm": "aes256gcm",
        "salt": "tImc2eaS0btzQDYo9nLawQ==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "4f8260f6dd8914e8f1ece09abe9643a404cfbb4799da184771335b2f2f0233b2": {
      "5c0281ed94de14b7dec231af9dfee812215110be11507e7220eb1ad753f2bfa2": {
        "ciphertext": "FsaRxA+qsSZbwyYudGMt6qGOotr/053Xr/SgfMp0g+LoyqwshKxw5OjH1E2x0GB3F0OQ20WbUJPChpucmmYpMIsNi2qFUNWQzt+s0XPd51rBFaady98oaitFFOeE1lEXBVzue3MVCKA9onVfacIhRaJLZ4oZRPUrEXUn5Xw7QdWa",
        "nonce": "Hzu45I4kQiLQlySp",
        "tag": "PtNNgkOHAbT8ZgN66M++VA==",
        "algorithm": "aes256gcm",
        "salt": "r1nDOSINQ4hJmdU9wwOyHg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "4c7ccc01415ad9e7341766087a5ef62fcc711acb2b0a711ddec7ef0d243f9ca0": {
        "ciphertext": "Br6/SxQSVCzou2TzvpZdEIuSHYXF8eHRG7TiVQ7L18kXqy/QQT6Yg2EBJmkz1sYRxLqVcYh2AqwT2MxmVow7syZForUd+qtLOxK+tkVIZPb6PDJ6SKiTcj5dBFjBsxysA0SW0z8wbjSQRBKXXBgI9yKsXqGeKN4aRxq7nr5wRrVU",
        "nonce": "eGfqdEKVCGto+Hi8",
        "tag": "kRliPEv5goBywo8pyLtcBQ==",
        "algorithm": "aes256gcm",
        "salt": "ynD93RiPZbx1sU1E87Kbhw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "e13e6fb4233bfdc24750add243dc58bdf2622b6a452c24c1dc59f29621e0b0b9": {
        "ciphertext": "lqF5W40YEjwcJwtk8kBys4grq3tULa7FHAd7aLcnHpG4srqJ7mGGaJ9mIYNLYQpAncEYmgCNwdh1fe7Ddxwr9BFlWWYsdvK78cjOZWrLdkI52pIpoC79WZky91B9wehsd0ZmVKgBckVY3lmH1SQbcXSv81inTgCM9XFlCooVvArn",
        "nonce": "QRl0Wzl+52olY31j",
        "tag": "PiUU1X2Wg7niY6mXVua/fg==",
        "algorithm": "aes256gcm",
        "salt": "BHCygJ4/RpqXRTKtxytytg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "981e98c932b64460bcef80540cc22df24e8e570a502c013ae4a54a973b5031e6": {
      "b362e24a8e89bc59ce20b7133dfc778d875bd831bd7b466b25e4860bca7fab21": {
        "ciphertext": "jc0fPrQDJ2nl4PQ/waaBd60/Zf7wwTohuiX65KsTgIkzXe5MVFPD+/1PleNF4L+wkZQ7sa+7pW3I8u8hF21h0fPVLLlONjLoc6dn2RgO3Ws1C8RmLLem9zrNc5kT5U7VbCF89uIqU6tE4y8d51yB7bNuHBXUepzOlMA67batySFn",
        "nonce": "QVLHdqIazwU9I4C4",
        "tag": "uSl8UYCyq0rjBjJDHd7LCQ==",
        "algorithm": "aes256gcm",
        "salt": "IB4QSSs+nCEhac8p9MkrtQ==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "70c94232744c44131a0c39a4f658e25a05587de8defe19885318688cdbe277b6": {
        "ciphertext": "KdSgM1PWIt2/F8yy9tVcLO3HiiTEAAQUfNADSiVsM1fDJ9vNZp/ofT6stNGnk40BSSHaoVrbYiksfFUq0oqKAIGN+JKpejDl8K4YKeqH7tU+N2dJk1Imji5ZqbJu5Xw1qkXucfTQPD0D3k5JNo7XvuadlK3S6plk+mB0ldHZ/mYBFE7MTP6Dq5zixBYLHug3yg==",
        "nonce": "YPSggWVq6+IBs37+",
        "algorithm": "chacha20poly1305",
        "salt": "oHN5LFd9/MSeVMPy9d5THg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "4171acf02cac7ec5cf6a44e1182db37d85717f59bba578e7d8672cba248e9737": {
        "ciphertext": "Pg6QhfjVD0a9o2h1cEAdpYReH39wzN5j+K4nY9asDOQRtbFxIMdnyFfyLb/xUqhfjMFLXTglItTTm9K1qUYKakD3pvneamL59Oyu8sjwnzPhxqY29PSU6pZOpUSJo2rIK1nx4Petv4oN5s7PoBvLJNg7bDhe4Cl1afE8kxH83bReGpe3Cm96PRjt88xeEun5Vw==",
        "nonce": "/QvC9tfRZqFUnZNm",
        "algorithm": "chacha20poly1305",
        "salt": "fSXdF4LScPqOLDucFRulUg==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "fa765a59e9393df15e18bda01b85ab64d9b331f865b413cbd033b9a1f546301e": {
      "9907c6030df82cbd62fde09aa786273c6994dce03fc374e666fc08fa7996dbad": {
        "ciphertext": "+HtSLpptLj49KGZ4lWQOIuQi3OLxhFSEdRdzfRIwMGFqWwoIJDK3UkmbqZ+O3VjKLEm4PTm1NKMF8JfdJ2qKZ8PkaJ6/xDeTIh7M8dR7SRRbopU8WviQ1P2c/BmyWeThdyqd39eSaHKnbSFCAZZrKMLKgTZLuIQPnCcEswTtSqaB",
        "nonce": "EBM4QvzeJZ1RIXwG",
        "tag": "J18dKrFcWOP02EtGmmfiRQ==",
        "algorithm": "aes256gcm",
        "salt": "fTBQ4mqznr+y+4SfYmX4jw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "41f96a69c5a61e221c8854388b44cb18276831a63f2e5dc0f5978e91f36c70c0": {
        "ciphertext": "3h8iPAP10EWJOpaBx9XgsKbLSr1f8va0QS920opwUMyit+d7K9UGU51CRUgPwMdtPnDtPQ6bSBkdBcgZ++o2+oW6rIgLOUUNd3nBpAMqTOa3ErEYFXiQd+nAimzhDX1fDlJe7gBpkANgQ8JBm5iU7cloAS9z62V0RTd52AnDhKB0z5DSGWA24vaW/ElMv0qxvg==",
        "nonce": "h7ciSmugJAy05d5H",
        "algorithm": "chacha20poly1305",
        "salt": "M9zHgyzKD9RLEOCFpmdGGA==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "9448466c7b558bd2c208ea29243cb833a74177138732908b44a824b4f013dd89": {
        "ciphertext": "zY7Q4umBROxTxLIEwiGrPGj8RhabRpKGX7vBoEaLamE4CaBXzveh3N5ua7dfM5CPusDgv5Q9lzuL1aCMdEgSnfcvJVpRs+QIKwuVoXCPH0MIUt9koihXv3HXS/2yVycwmd+Wlj2c95UEo8n/3VZ+bz9HX2mRcxYscfgUsQQy+3QT",
        "nonce": "EBAgJAahy0p75C75",
        "tag": "j9ZfrB0AO5SoPNQnlqIxhA==",
        "algorithm": "aes256gcm",
        "salt": "F3Lu4BYYZDifI/QT0iKs7A==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "5f9fee279a50aa3cddd2ee8736209640870ba619a619a04a379d2a6e16abd796": {
      "8c6377c033507b593312dc5b7b51c3621b2425e90300332653fb6f01caec28a9": {
        "ciphertext": "Kf0tYfmzm80aq2kyj3fWlNEYk85PqA5kyegd5zbdsQffEnVBQd5E70CXCC19SkmJfvRkHN2FSuS1MOqcn976PCe4tKwG2roogTWRI6uV5VRmThd/uHt/a3X3XguAnGSwN+qEqktlukIEIh28C6J0urmV7ioFprikUTpZo16Ux728",
        "nonce": "ZdTpGNKbp/OeJFib",
        "tag": "U2dsTRAI3ZN7Qxe4WHZr3w==",
        "algorithm": "aes256gcm",
        "salt": "ZWyLWH7pMo6lBjw/IDe6bw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "b2db95d12007266c42f6675a5ea2fad3bf3fe4db1622b93fcd7f7b875547fe8b": {
        "ciphertext": "XfOnnTX+YTC5pHpynqgI4V9fq8l8GRUuAYgbL6dPx1s/LrSFlJ+ZptRjTnGMjZcyRtTZVj4Yt0UH6QYZRIM7vnqOxQFO+skrvkpdkeKjYvtzH5M/1ZkQ4WOTsuatnlHbWvuUxZrat7eOZCAiYEqRGOvHxDt43jpOeBtiQPXndbUpF3HLEjq3hULh7ZY9bPecRg==",
        "nonce": "r27pAj5BnQO8WXl0",
        "algorithm": "chacha20poly1305",
        "salt": "6OcgSYx7r/EgrAo61HAjdA==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330": {
        "ciphertext": "CQHN/emIwq8C1zqeHWLVCM2CfR65C81oELzQEKsGnSi7KQkBz52f2KjW5dsoXYufCn48hrHIArdHy53I02BNOAvX0qFIJLVEJx1ABNJoVOmEsPmHtiO4kEparQyRLzxevKyGyJqkfiNRWsTJuJz4SZ7VeASmeQ0+xeCVDfPovwoX+x1JdNvCf3SsGplJfQbh+g==",
        "nonce": "idnk6UGtJjFTTf+g",
        "algorithm": "chacha20poly1305",
        "salt": "8PR1mt/l8plExn1IJc6YJA==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    },
    "a4a5c5f767afd657b46f16224d411ae18dbfa2cfe7613e9ca25879cc890947f2": {
      "73ac37c5a3843f6165682d81e071892b6f33427ef9e03747e24b4e12b471aa00": {
        "ciphertext": "DzG7Mg0nZw0+8pi1bvaU1Zq1rC8k8uKiEn/AOYdrBb2usFDIarXNBH/KgpceGkuaOkNY5D7TiwF91RmxTm+dIywFAu51u1vZrts6fev+J6xd/ouuMDAm27ve4QnDOehAxqJ/if9mzRb6T8OJsq1MN08gltIwBf0ulvaQUOHocQeSUXIvLcFcpb2uUSg0l4Xd4A==",
        "nonce": "SoAf0nPLg7thZ4n3",
        "algorithm": "chacha20poly1305",
        "salt": "fvQD3H7R3V5FnfeQRcv7IQ==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "5ada231bbe3d28b8fdde21166a18bb4d95107ef02aa2d74e6a898a023e19c6ae": {
        "ciphertext": "ndZYMzuyurKFQHPucqlmoG8hn19/I+ESebr+7HNF9brnI49g80UNHeymXpmuaoBrZ6+PnnepvZyW1Vsk0Fg4xPmXVfaKLzF/Qgrrai6LHw2AFw5HJSKx7rNnxLGbnVanK4ldp2qtfRh6GRXWTdRv451RFyaQyoivCUQei+t7cFnj+fz3rXlXHl6bf24uL2C6gQ==",
        "nonce": "lt9E82wxl7joZ9S4",
        "algorithm": "chacha20poly1305",
        "salt": "SUxguW/kQ+y5PNglizwkmQ==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "ee57df2cc07f0141f2a3a395232d4951b28d4cc65d88f73af1e76f433bc60330": {
        "ciphertext": "TT8nMAA4zmcRuU2NTj4V1MtiL9PjKZ72JxyC96wq4QI/glPmwLeWT23EjICJdz5RQfQHLJLoICsYOFhahhDRAE9XFLl/ehdVVU3Wz9qAWRTcio9+aCT053XHoI1Sik3zaEcyMqwWap6Mc6pRyVoZ7DD+nkg1ZiFAw611bv7NR+JC",
        "nonce": "fVAj6rq9TPAnAmax",
        "tag": "m8OxrQ2iEnYPh+topaAGYQ==",
        "algorithm": "aes256gcm",
        "salt": "xhzSwLurOwQi6dgsulRDsw==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      },
      "c037cf8fa41435dfcfa6409de73c533633d57c92d8b508f912634a944305d05f": {
        "ciphertext": "VkvRXLsDWhhJxIaiHZfFI2YGRtRfiHIVBphDzGUWD0Eg1fUYbypD5Xq9FlX4DJB0iSX0OJDi9GF5N+Gsg8wQ/Yv5s+nB/Z0NrA+L6ZH3WCLAnUYp/b+q2PVWbGtazFtVJaZ3+wwmSIyXjT305nPv+NjiUyCbq5LXLweJHKvV5an5",
        "nonce": "lF4HqynGA1q7nfBm",
        "tag": "6bPd5o+GrBaDpYcCyhPvsA==",
        "algorithm": "aes256gcm",
        "salt": "WrPI9/KRXzZrCIYe3cRm1g==",
        "kdf": {
          "type": "argon2id",
          "t": 3,
          "m": 65536,
          "p": 4,
          "len": 32
        }
      }
    }
  }
}


########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\user configured security questions\user_config.json
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\user configured security questions\user_config.txt
# SIZE: 981 bytes
# HASH: 6a7369ec856bd8647662cf18c2bf60ae00faa4bdef39ef772f54422f5b5817b8
# MODIFIED: 2025-08-27T02:19:21.025002
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

--- CRYPTOGRAPHIC CONFIGURATION ---
Secret: [encrypted via SSS; not stored in JSON]
Shamir Threshold: 6
Pad Size: 128
Argon2id Parameters:
  - Time Cost: 3
  - Memory Cost: 65536 KiB
  - Parallelism: 4

--- SECURITY QUESTIONS ---

[Question 1] What is your name? (Type: CRITICAL)

A) Ida
B) Jocke
C) Nina
D) Pelle
E) Sara
F) Tilde

---

[Question 2] How old are you? (Type: STANDARD)

A) 22
B) 25
C) 21
D) 24
E) 55

---

[Question 3] Favourite food? (Type: CRITICAL)

A) Beer
B) Whiskey

---

[Question 4] Favorite color? (Type: STANDARD)

A) Blue
B) Red
C) Green

---

[Question 5] Coffee or tea? (Type: STANDARD)

A) Coffee
B) Tea
C) Neither

---

[Question 6] Favorite season? (Type: STANDARD)

A) Summer
B) Winter
C) Autumn

---

[Question 7] Morning or night? (Type: STANDARD)

A) Morning
B) Night
C) Both

---

[Question 8] Dogs or cats? (Type: STANDARD)

A) Dogs
B) Cats
C) Both
D) Other

---




########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\src\user configured security questions\user_config.txt
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\.gitignore
# SIZE: 39 bytes
# HASH: e7c6bb30148cf667606dcd63e7ca77acaa3cfb0c8303bf09e6419e1e1669dc6d
# MODIFIED: 2025-08-29T04:11:03.876791
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

# Created by pytest automatically.
*



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\.gitignore
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\CACHEDIR.TAG
# SIZE: 191 bytes
# HASH: 37dc88ef9a0abeddbe81053a6dd8fdfb13afb613045ea1eb4a5c815a74a3bde4
# MODIFIED: 2025-08-29T04:11:03.876791
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by pytest.
# For information about cache directory tags, see:
#	https://bford.info/cachedir/spec.html



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\CACHEDIR.TAG
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\README.md
# SIZE: 310 bytes
# HASH: 420e808d79a6c25d3cda0af33bc4782314a14949866682c68ce8149e89b66b70
# MODIFIED: 2025-08-29T04:11:03.875791
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\README.md
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\v\cache\lastfailed
# SIZE: 36 bytes
# HASH: d79a1789b5f44218f473a3073efcd007d20e6a8fdc0a8ed7bba0e4e6b48c7127
# MODIFIED: 2025-08-29T04:11:03.881123
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

{
  "test_bridge_smoke.py": true
}


########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\v\cache\lastfailed
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\v\cache\nodeids
# SIZE: 2 bytes
# HASH: 4f53cda18c2baa0c0354bb5f9a3ecbe5ed12ab4d8e11ba873c2f11161202b945
# MODIFIED: 2025-08-29T04:11:38.865954
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[]


########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\.pytest_cache\v\cache\nodeids
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\__pycache__\test_bridge_smoke.cpython-313-pytest-8.4.1.pyc
# SIZE: 15935 bytes
# HASH: 1467067ddc274348cdbaf9df0b7eab869f77ebd0e9cc156ae0837874bcb137e7
# MODIFIED: 2025-08-29T04:24:57.360968
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\__pycache__\test_bridge_smoke.cpython-313-pytest-8.4.1.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\__pycache__\test_rng_policy.cpython-313-pytest-8.4.1.pyc
# SIZE: 13655 bytes
# HASH: 605c9bf1a2c78578c15fb6fa1b1ca52e2eda3c20ec8aa8d368173946215a901e
# MODIFIED: 2025-08-29T04:54:01.800953
# BINARY: yes
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

[BINARY FILE CONTENT OMITTED]

########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\__pycache__\test_rng_policy.cpython-313-pytest-8.4.1.pyc
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\test_bridge_smoke.py
# SIZE: 1272 bytes
# HASH: 9f37904f1e6c78aab4a235b886519231ae4a0c92fefd81689ef41f9edb3dc0bb
# MODIFIED: 2025-08-29T04:23:40.784689
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

import secrets
from modules.noble_bridge import NobleBridge

def test_smoke_all_ops():
    js_dir = "bridge"
    key = secrets.token_bytes(32)
    nonce_gcm = secrets.token_bytes(12)
    nonce_chacha = secrets.token_bytes(12)
    nonce_xchacha = secrets.token_bytes(24)
    aad = b"header"
    msg = b"hello world"
    salt = secrets.token_bytes(16)

    with NobleBridge(js_dir=js_dir) as nb:
        ct = nb.aes_gcm_encrypt(key, nonce_gcm, msg, aad)
        assert nb.aes_gcm_decrypt(key, nonce_gcm, ct, aad) == msg

        ct2 = nb.chacha20poly1305_encrypt(key, nonce_chacha, msg, aad)
        assert nb.chacha20poly1305_decrypt(key, nonce_chacha, ct2, aad) == msg

        ct3 = nb.xchacha20poly1305_encrypt(key, nonce_xchacha, msg, aad)
        assert nb.xchacha20poly1305_decrypt(key, nonce_xchacha, ct3, aad) == msg

        assert len(nb.sha3_256(b"data")) == 32
        assert len(nb.hmac_sha256(key, b"data")) == 32
        assert len(nb.hkdf_sha256(key, salt, b"ctx", 42)) == 42

        assert len(nb.argon2id(b"password", salt, t=2, m=65536, p=1, dkLen=32, version=19)) == 32

        mac = nb.hmac_sha256(key, b"data")
        assert nb.ct_equal(mac, mac) is True
        assert nb.ct_equal(mac, b"\x00" * len(mac)) is False



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\test_bridge_smoke.py
########################################################################################################################


########################################################################################################################
# FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\test_rng_policy.py
# SIZE: 1291 bytes
# HASH: dbfe4d2b3e3d466005deb69c055a2e7d8273b6ba9c0e155f7fc2ebc3950950cd
# MODIFIED: 2025-08-29T04:49:04.896942
# BINARY: no
# SNAPSHOT_TIMESTAMP: 2025-08-29_05-17-42
########################################################################################################################

# tests/test_rng_policy.py
import pytest

from modules.rng import random_bytes, token_bytes, token_hex, token_urlsafe, secure_compare
from modules.noble_bridge import NobleBridge, BridgeError


def test_python_rng_basic_properties():
    b1 = random_bytes(32)
    b2 = random_bytes(32)
    assert isinstance(b1, (bytes, bytearray)) and isinstance(b2, (bytes, bytearray))
    assert len(b1) == 32 and len(b2) == 32
    # Extremely likely to differ
    assert b1 != b2

    t_bytes = token_bytes(16)
    t_hex = token_hex(16)
    t_url = token_urlsafe(16)

    assert isinstance(t_bytes, (bytes, bytearray)) and len(t_bytes) == 16
    assert isinstance(t_hex, str) and len(t_hex) == 32  # 2 chars per byte
    assert isinstance(t_url, str) and len(t_url) > 0


def test_secure_compare_constant_time_semantics():
    a = token_bytes(32)
    b = bytes(a)
    c = b"\x00" * len(a)
    assert secure_compare(a, b) is True
    assert secure_compare(a, c) is False


def test_bridge_has_no_random_op():
    # The Node bridge must not expose randomness.
    with NobleBridge(js_dir="bridge") as nb:
        # Attempt to invoke a non-existent op; should raise BridgeError.
        with pytest.raises(BridgeError):
            nb._rpc("random_bytes", {"len": 32})



########################################################################################################################
# END OF FILE: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\tests\test_rng_policy.py
########################################################################################################################


========================================================================================================================
SUMMARY
Total Files Processed: 90
Binary/Unreadable Files: 37
Total Text Characters Collected: 790241
Snapshot: 2025-08-29_05-17-42
Output: C:\Users\deskt\Desktop\Project_SECQ_CLI\SECQ_CLI\source_dump_2025-08-29_05-17-42.txt
========================================================================================================================
